# TOTETAXI - BACKEND CODE SNAPSHOT
# AUTO-GENERATED - CODE FILES ONLY
# Created: 2025-10-02 13:12:59
# Total files: 121
# 🔒 SECURITY: .env files excluded (contain secrets)
# 📋 INCLUDES: All Django apps, migrations, configuration
# Apps: accounts (STAFF), bookings, crm, customers, documents, logistics, notifications, payments, services
# Tech Stack: Django 5.2.5, DRF 3.16.1, PostgreSQL, Redis, Celery
# Integration: S3 storage, SES email, mocked Stripe/Onfleet


# ========================= CONFIGURATION & ROOT FILES =========================


# ==== .dockerignore ====

```
# Git
.git
.gitignore

# Docker
.docker
Dockerfile
docker-compose*

# Python
__pycache__
*.pyc
*.pyo
*.pyd
.Python
venv/
.venv/
pip-log.txt
pip-delete-this-directory.txt
.tox
.coverage
.coverage.*
.pytest_cache
.cache
htmlcov
.mypy_cache
.dmypy.json
dmypy.json

# IDEs
.vscode
.idea
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs
*.log
npm-debug.log*

# Environment
.env
.env.local
.env.development
.env.production

# Media files
media/

# Node (if any)
node_modules
npm-debug.log
```

# ==== .gitignore ====

```
# Python
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
__pycache__/
*.py[cod]
*$py.class

# Django
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal
/media
/staticfiles
/static

# Environment variables
.env
.env.local
.env.production
.env.*.local
*.env

# Virtual Environment
venv/
env/
ENV/
env.bak/
venv.bak/
.venv/

# IDEs
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store

# Testing
.pytest_cache/
.coverage
htmlcov/
.tox/
.nox/

# Celery
celerybeat-schedule
celerybeat.pid

# Jupyter Notebook
.ipynb_checkpoints

# pyenv
.python-version

# Backup files
*.bak
*.backup

# Database dumps
*.sql
*.dump

# Stripe webhook CLI (if used)
stripe-webhook-*

# Logs
logs/
*.log
```

# ==== Dockerfile ====

```dockerfile
FROM python:3.11-slim

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONPATH=/app \
    PORT=8000

# Set work directory
WORKDIR /app

# Install system dependencies
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
        postgresql-client \
        build-essential \
        libpq-dev \
        curl \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt /app/
RUN pip install --no-cache-dir -r requirements.txt

# Copy project
COPY . /app/

# Create directories for logs and static files
RUN mkdir -p /app/logs /app/staticfiles /app/media

# Make entrypoint executable
RUN chmod +x /app/scripts/entrypoint.sh

# Collect static files
RUN python manage.py collectstatic --no-input --clear || echo "Collectstatic skipped"

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD curl -f http://localhost:8000/admin/ || exit 1

# Run entrypoint
ENTRYPOINT ["/app/scripts/entrypoint.sh"]
CMD ["gunicorn", "config.wsgi:application", "--bind", "0.0.0.0:8000", "--workers", "2", "--timeout", "120"]
```

# ==== cookies.txt ====

```
# Netscape HTTP Cookie File
# https://curl.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

#HttpOnly_totetaxi-backend.fly.dev	FALSE	/	TRUE	1760990467	totetaxi_sessionid	05xyvmlfcux7jse31rqs0e8w7k45qyvx
totetaxi-backend.fly.dev	FALSE	/	TRUE	1789848067	csrftoken	gKVTP9PScbQqDkZkmqwAYrOgUQhGagRD
```

# ==== docker-compose.prod.yml ====

```yaml
name: totetaxi-production

services:
  # PostgreSQL Database - Internal only for security
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: ${DB_NAME:-totetaxi}
      POSTGRES_USER: ${DB_USER:-postgres}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_INITDB_ARGS: "--auth-host=scram-sha-256"
    volumes:
      - postgres_data:/var/lib/postgresql/data/
      - ./postgresql.conf:/etc/postgresql/postgresql.conf:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-postgres}"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - internal
    restart: unless-stopped
    # No external ports - database is internal only

  # Redis for Celery - Internal only with authentication
  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD} --maxmemory 256mb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "--no-auth-warning", "-a", "${REDIS_PASSWORD}", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - internal
    restart: unless-stopped

  # Django Backend with Gunicorn
  web:
    build:
      context: .
      dockerfile: Dockerfile.prod
    command: gunicorn config.wsgi:application --bind 0.0.0.0:8000 --workers 4 --worker-class sync --max-requests 1000 --access-logfile - --error-logfile -
    volumes:
      - static_volume:/app/staticfiles:ro
      - media_volume:/app/media
      - logs_volume:/app/logs
    ports:
      - "8005:8000"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env.production
    environment:
      - DATABASE_URL=postgres://${DB_USER:-postgres}:${DB_PASSWORD}@db:5432/${DB_NAME:-totetaxi}?sslmode=prefer
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
    networks:
      - internal
      - external
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 512M

  # Celery Worker
  celery:
    build:
      context: .
      dockerfile: Dockerfile.prod
    command: celery -A config worker -l info --concurrency 4 --max-tasks-per-child 1000
    volumes:
      - logs_volume:/app/logs
      - media_volume:/app/media
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env.production
    environment:
      - DATABASE_URL=postgres://${DB_USER:-postgres}:${DB_PASSWORD}@db:5432/${DB_NAME:-totetaxi}?sslmode=prefer
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
    networks:
      - internal
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 512M

  # Celery Beat Scheduler
  celery-beat:
    build:
      context: .
      dockerfile: Dockerfile.prod
    command: celery -A config beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler
    volumes:
      - logs_volume:/app/logs
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env.production
    environment:
      - DATABASE_URL=postgres://${DB_USER:-postgres}:${DB_PASSWORD}@db:5432/${DB_NAME:-totetaxi}?sslmode=prefer
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
    networks:
      - internal
    restart: unless-stopped

volumes:
  postgres_data:
    driver: local
  static_volume:
    driver: local
  media_volume:
    driver: local
  redis_data:
    driver: local
  logs_volume:
    driver: local

networks:
  internal:
    driver: bridge
    internal: true
  external:
    driver: bridge
```

# ==== docker-compose.yml ====

```yaml
name: totetaxi-backend

services:
  # PostgreSQL Database - PORT 5435
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: totetaxi
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5435:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis for Celery - PORT 6382
  redis:
    image: redis:7-alpine
    ports:
      - "6382:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Django Backend - PORT 8005
  web:
    build: .
    command: python manage.py runserver 0.0.0.0:8000
    volumes:
      - .:/app
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    ports:
      - "8005:8000"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/totetaxi
      - REDIS_URL=redis://redis:6379/0

  # Celery Worker
  celery:
    build: .
    command: celery -A config worker -l info
    volumes:
      - .:/app
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/totetaxi
      - REDIS_URL=redis://redis:6379/0

  # Celery Beat Scheduler
  celery-beat:
    build: .
    command: celery -A config beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler
    volumes:
      - .:/app
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/totetaxi
      - REDIS_URL=redis://redis:6379/0

volumes:
  postgres_data:
  static_volume:
  media_volume:
  redis_data:
```

# ==== fly.toml ====

```toml
# fly.toml app configuration file
app = 'totetaxi-backend'
primary_region = 'ewr'

[build]
  dockerfile = 'Dockerfile.prod'

[env]
  DEBUG = "False"
  DJANGO_LOG_LEVEL = "INFO"
  DJANGO_SETTINGS_MODULE = 'config.settings'
  PORT = '8000'
  PYTHONUNBUFFERED = '1'
  PYTHONPATH = '/app'

[http_service]
  internal_port = 8000
  force_https = true
  auto_stop_machines = false
  auto_start_machines = true
  min_machines_running = 1
  processes = ['app']

  [http_service.concurrency]
    type = 'requests'
    hard_limit = 200
    soft_limit = 100

# REMOVED: [[http_service.checks]] - causing ALLOWED_HOSTS issues

[machines]
  cpu_kind = 'shared'
  cpus = 1
  memory_mb = 1024

[[statics]]
  guest_path = "/app/staticfiles"
  url_prefix = "/static/"
```

# ==== gunicorn.conf.py ====

```python
import multiprocessing

# Server socket
bind = "0.0.0.0:8000"
backlog = 2048

# Worker processes
workers = multiprocessing.cpu_count() * 2 + 1
worker_class = "sync"
worker_connections = 1000
timeout = 30
keepalive = 2
max_requests = 1000
max_requests_jitter = 100

# Logging
accesslog = "-"
errorlog = "-"
loglevel = "info"

# Process naming
proc_name = "totetaxi"

# Server mechanics
preload_app = True
pidfile = "/tmp/gunicorn.pid"
```

# ==== manage.py ====

```python
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
```

# ==== pyproject.toml ====

```toml
[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "totetaxi-backend"
version = "0.1.0"
description = "ToteTaxi luxury delivery service backend API"
requires-python = ">=3.11"

[tool.black]
line-length = 88
target-version = ['py311']
include = '\.pyi?$'
extend-exclude = '''
/(
  migrations
)/
'''

[tool.isort]
profile = "black"
multi_line_output = 3
line_length = 88
skip_glob = ["**/migrations/*.py"]

[tool.coverage.run]
source = "."
omit = [
    "*/migrations/*",
    "*/venv/*",
    "*/tests/*",
    "manage.py",
    "config/wsgi.py",
    "config/asgi.py",
]
```

# ==== pytest.ini ====

```ini
[tool:pytest]
DJANGO_SETTINGS_MODULE = config.settings.testing
python_files = tests.py test_*.py *_tests.py
python_classes = Test*
python_functions = test_*
addopts = --tb=short --strict-markers --disable-warnings
markers =
    slow: marks tests as slow (deselect with '-m "not slow"')
    integration: marks tests as integration tests
```

# ==== recreate_services.py ====

```python
# backend/recreate_services.py
# Service Catalog Recreation Script
# Run this after fresh database migration: python manage.py shell < recreate_services.py

from apps.services.models import *

print("🚀 Creating service catalog...")

# Mini Move Packages
print("📦 Creating Mini Move Packages...")
MiniMovePackage.objects.create(
    package_type='petite',
    name='Petite',
    description='15 items <50 lbs. Shared van with COI available for +$50.',
    base_price_cents=99500,
    max_items=15,
    max_weight_per_item_lbs=50,
    coi_included=False,
    coi_fee_cents=5000,
    priority_scheduling=False,
    protective_wrapping=False,
    is_most_popular=False,
    is_active=True
)


MiniMovePackage.objects.create(
    package_type='standard',
    name='Standard',
    description='30 items <50 lbs. COI included, protective wrapping, priority scheduling.',
    base_price_cents=172500,
    max_items=30,
    max_weight_per_item_lbs=50,
    coi_included=True,
    coi_fee_cents=0,
    priority_scheduling=True,
    protective_wrapping=True,
    is_most_popular=True,
    is_active=True
)

MiniMovePackage.objects.create(
    package_type='full',
    name='Full Move',
    description='Van exclusive, unlimited items within van capacity. Direct pickup-to-delivery.',
    base_price_cents=249000,
    max_items=None,
    max_weight_per_item_lbs=50,
    coi_included=True,
    coi_fee_cents=0,
    priority_scheduling=True,
    protective_wrapping=True,
    is_most_popular=False,
    is_active=True
)

# Specialty Items
print("🏄 Creating Specialty Items...")
SpecialtyItem.objects.create(
    item_type='peloton',
    name='Peloton / Large Equipment',
    description='Peloton bikes and large equipment moving',
    price_cents=50000,
    special_handling=True,
    is_active=True
)

SpecialtyItem.objects.create(
    item_type='surfboard',
    name='Surfboard',
    description='Professional surfboard transport',
    price_cents=35000,
    special_handling=True,
    is_active=True
)

SpecialtyItem.objects.create(
    item_type='crib',
    name='Crib',
    description='Foldable crib delivery (may vary for non-foldable)',
    price_cents=35000,
    special_handling=True,
    is_active=True
)

SpecialtyItem.objects.create(
    item_type='wardrobe_box',
    name='Wardrobe Box',
    description='Professional wardrobe box handling',
    price_cents=27500,
    special_handling=True,
    is_active=True
)

# Standard Delivery Config
print("🚚 Creating Standard Delivery Config...")
StandardDeliveryConfig.objects.create(
    price_per_item_cents=9500,
    minimum_items=1,
    minimum_charge_cents=28500,
    same_day_flat_rate_cents=36000,
    max_weight_per_item_lbs=50,
    is_active=True
)

# Surcharge Rules
print("💰 Creating Surcharge Rules...")
SurchargeRule.objects.create(
    surcharge_type='weekend',
    name='Mini Move Weekend Surcharge',
    description='Weekend surcharge for Mini Move packages - $175 for Sat/Sun bookings',
    applies_to_service_type='mini_move',
    calculation_type='fixed_amount',
    percentage=None,
    fixed_amount_cents=17500,
    specific_date=None,
    applies_saturday=True,
    applies_sunday=True,
    is_active=True
)

SurchargeRule.objects.create(
    surcharge_type='weekend',
    name='Standard Delivery Weekend Surcharge',
    description='Weekend surcharge for Standard Delivery service - $50 for Sat/Sun bookings',
    applies_to_service_type='standard_delivery',
    calculation_type='fixed_amount',
    percentage=None,
    fixed_amount_cents=5000,
    specific_date=None,
    applies_saturday=True,
    applies_sunday=True,
    is_active=True
)

SurchargeRule.objects.create(
    surcharge_type='geographic',
    name='CT/NJ Distance Surcharge',
    description='Additional charge for CT/NJ pickups (30+ min outside Manhattan)',
    applies_to_service_type='all',
    calculation_type='fixed_amount',
    percentage=None,
    fixed_amount_cents=22000,
    specific_date=None,
    applies_saturday=False,
    applies_sunday=False,
    is_active=True
)

SurchargeRule.objects.create(
    surcharge_type='geographic',
    name='Amagansett/Montauk Surcharge',
    description='Additional charge for Amagansett/Montauk deliveries',
    applies_to_service_type='all',
    calculation_type='fixed_amount',
    percentage=None,
    fixed_amount_cents=12000,
    specific_date=None,
    applies_saturday=False,
    applies_sunday=False,
    is_active=True
)

print("✅ Service catalog created successfully!")
print(f"📦 {MiniMovePackage.objects.count()} Mini Move Packages")
print(f"🏄 {SpecialtyItem.objects.count()} Specialty Items") 
print(f"🚚 {StandardDeliveryConfig.objects.count()} Standard Delivery Configs")
print(f"💰 {SurchargeRule.objects.count()} Surcharge Rules")
print(f"📋 {OrganizingService.objects.count()} Organizing Services (from migration)")
```

# ==== requirements.txt ====

```
# Django Core - Latest LTS with full compatibility
Django==5.2.5
djangorestframework==3.16.1
django-cors-headers==4.6.0
django-environ==0.11.2

# Database
psycopg2-binary==2.9.9
dj-database-url==2.1.0

# Authentication & Security
djangorestframework-simplejwt==5.3.0
django-allauth==0.63.6
django-ipware==7.0.1

# API Documentation
drf-yasg==1.21.7

# Background Jobs - Latest stable versions
celery==5.5.3
redis==5.1.1
django-celery-beat==2.8.1

# File Storage
boto3==1.35.19
django-storages==1.14.4
Pillow==10.4.0

# Integrations - Latest versions
stripe==12.4.0
requests==2.32.3

# Monitoring & Logging
sentry-sdk==2.13.0

# Development
django-debug-toolbar==4.4.6
django-extensions==3.2.3

# Testing
pytest==8.3.2
pytest-django==4.9.0
pytest-cov==5.0.0
factory-boy==3.3.0

# Production Server
gunicorn==23.0.0
whitenoise==6.7.0

django-ratelimit==4.1.0
django-redis==5.4.0

```

# ==== staff_cookies.txt ====

```
# Netscape HTTP Cookie File
# https://curl.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

#HttpOnly_localhost	FALSE	/	FALSE	1758066188	sessionid	fwh9hh6geqv27ua54oalc21vmmdbzz6a
localhost	FALSE	/	FALSE	1788306188	csrftoken	9q6dfu6t1kUNO5j926PupDyEP2bSl9gP
```

# ========================= DJANGO PROJECT SETTINGS (config/) =========================


# ==== config/__init__.py ====

```python
# This will make sure the app is always imported when
# Django starts so that shared_task will use this app.
from .celery import app as celery_app

__all__ = ('celery_app',)
```

# ==== config/asgi.py ====

```python
"""
ASGI config for config project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_asgi_application()
```

# ==== config/celery.py ====

```python
import os
from celery import Celery

# Set the default Django settings module for the 'celery' program.
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

app = Celery('totetaxi')

# Using a string here means the worker doesn't have to serialize
# the configuration object to child processes.
app.config_from_object('django.conf:settings', namespace='CELERY')

# Load task modules from all registered Django apps.
app.autodiscover_tasks()

@app.task(bind=True, ignore_result=True)
def debug_task(self):
    print(f'Request: {self.request!r}')
```

# ==== config/settings.py ====

```python
# config/settings.py
import os
import environ
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Environment variables
env = environ.Env(
    DEBUG=(bool, False),
)

# Take environment variables from .env file
environ.Env.read_env(BASE_DIR / '.env')

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = env('SECRET_KEY', default='django-insecure-change-me-in-production')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = env('DEBUG', default=False)

# Fly.io support
FLY_APP_NAME = env('FLY_APP_NAME', default='')

ALLOWED_HOSTS = env.list('ALLOWED_HOSTS', default=['localhost', '127.0.0.1', '0.0.0.0'])

# Add Fly.io hostnames
if FLY_APP_NAME:
    ALLOWED_HOSTS.extend([
        f'{FLY_APP_NAME}.fly.dev',
        f'{FLY_APP_NAME}.internal',
        '.fly.dev',
    ])

# Application definition
DJANGO_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

THIRD_PARTY_APPS = [
    'rest_framework',
    'corsheaders',
    'django_celery_beat',
    'drf_yasg',
    'django_ratelimit',
]

# LOCAL_APPS - All ToteTaxi apps
LOCAL_APPS = [
    'apps.accounts',
    'apps.bookings',
    'apps.services', 
    'apps.payments',
    'apps.logistics',
    'apps.documents',
    'apps.notifications',
    'apps.crm',
    'apps.customers',
]

INSTALLED_APPS = DJANGO_APPS + THIRD_PARTY_APPS + LOCAL_APPS

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'

# Database
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': env('DB_NAME', default='totetaxi'),
        'USER': env('DB_USER', default='postgres'),
        'PASSWORD': env('DB_PASSWORD', default='postgres'),
        'HOST': env('DB_HOST', default='db'),
        'PORT': env('DB_PORT', default='5432'),
    }
}

# Alternative: use DATABASE_URL if provided (Fly.io provides this)
database_url = env('DATABASE_URL', default=None)
if database_url:
    import dj_database_url
    DATABASES['default'] = dj_database_url.config(
        default=database_url,
        conn_max_age=600,
        conn_health_checks=True,
    )

# CACHES - Redis configuration for rate limiting
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': env('REDIS_URL', default='redis://redis:6379/1'),
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'IGNORE_EXCEPTIONS': True,
        }
    }
}

# Rate limiting configuration
RATELIMIT_USE_CACHE = 'default'
RATELIMIT_ENABLE = True

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'America/New_York'
USE_I18N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
STATIC_URL = '/static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'

# Create static directory if it doesn't exist
STATICFILES_DIRS = []
if (BASE_DIR / 'static').exists():
    STATICFILES_DIRS.append(BASE_DIR / 'static')

# WhiteNoise configuration for static files
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'

# Media files
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Django REST Framework - UPDATED FOR HYBRID AUTH
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'apps.customers.authentication.HybridAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.BrowsableAPIRenderer',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 20,
}

# CORS settings - FIXED FOR MOBILE CROSS-DOMAIN
CORS_ALLOWED_ORIGINS = env.list('CORS_ALLOWED_ORIGINS', default=[
    'http://localhost:3000',
    'http://127.0.0.1:3000',
    'https://totetaxi.netlify.app',
])

# Add Fly.io to CORS allowed origins if needed
if FLY_APP_NAME:
    CORS_ALLOWED_ORIGINS.append(f'https://{FLY_APP_NAME}.fly.dev')

CORS_ALLOW_CREDENTIALS = True
CORS_ALLOW_HEADERS = [
    'accept',
    'accept-encoding',
    'authorization',
    'content-type',
    'dnt',
    'origin',
    'user-agent',
    'x-csrftoken',
    'x-requested-with',
    'x-session-id',
]

# CSRF Settings - FIXED FOR MOBILE CROSS-DOMAIN
CSRF_COOKIE_SECURE = env.bool('CSRF_COOKIE_SECURE', default=not DEBUG)
CSRF_COOKIE_HTTPONLY = False
CSRF_COOKIE_SAMESITE = 'None'
CSRF_TRUSTED_ORIGINS = env.list('CSRF_TRUSTED_ORIGINS', default=[
    'http://localhost:3000',
    'http://127.0.0.1:3000',
    'https://totetaxi.netlify.app',
])

# Add Fly.io to CSRF trusted origins
if FLY_APP_NAME:
    CSRF_TRUSTED_ORIGINS.extend([
        f'https://{FLY_APP_NAME}.fly.dev',
    ])

# Session Settings - FIXED FOR MOBILE CROSS-DOMAIN
SESSION_COOKIE_SECURE = env.bool('SESSION_COOKIE_SECURE', default=not DEBUG)
SESSION_COOKIE_SAMESITE = 'None'
SESSION_COOKIE_AGE = 60 * 60 * 24 * 30  # 30 days
SESSION_EXPIRE_AT_BROWSER_CLOSE = False
SESSION_SAVE_EVERY_REQUEST = True
SESSION_COOKIE_NAME = 'totetaxi_sessionid'
SESSION_ENGINE = 'django.contrib.sessions.backends.db'

# Celery Configuration
CELERY_BROKER_URL = env('REDIS_URL', default='redis://redis:6379/0')
CELERY_RESULT_BACKEND = env('REDIS_URL', default='redis://redis:6379/0')
CELERY_ACCEPT_CONTENT = ['application/json']
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TIMEZONE = TIME_ZONE

# Security Settings for Production - FIXED FOR CROSS-DOMAIN
if not DEBUG:
    SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
    SECURE_SSL_REDIRECT = True
    SECURE_BROWSER_XSS_FILTER = True
    SECURE_CONTENT_TYPE_NOSNIFF = True
    SECURE_HSTS_INCLUDE_SUBDOMAINS = True
    SECURE_HSTS_SECONDS = 31536000
    SECURE_HSTS_PRELOAD = True
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True

# Logging with rate limiting
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'INFO',
    },
    'loggers': {
        'django': {
            'handlers': ['console'],
            'level': env('DJANGO_LOG_LEVEL', default='INFO'),
            'propagate': False,
        },
        'django.request': {
            'handlers': ['console'],
            'level': 'DEBUG',
            'propagate': False,
        },
        'django_ratelimit': {
            'handlers': ['console'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}

# Stripe Configuration
STRIPE_SECRET_KEY = env('STRIPE_SECRET_KEY', default='')
STRIPE_PUBLISHABLE_KEY = env('STRIPE_PUBLISHABLE_KEY', default='')
STRIPE_WEBHOOK_SECRET = env('STRIPE_WEBHOOK_SECRET', default='')
```

# ==== config/urls.py ====

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/customer/', include('apps.customers.urls')),
    path('api/public/', include('apps.bookings.urls')),
    
    path('api/payments/', include('apps.payments.urls')),
    path('api/staff/', include('apps.accounts.urls')),  # Add this line
    # In config/urls.py, add this to urlpatterns:
    path('api/staff/logistics/', include('apps.logistics.urls')),
]
```

# ==== config/wsgi.py ====

```python
"""
WSGI config for config project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_wsgi_application()
```

# ========================= DJANGO APPLICATIONS (apps/) =========================


# ==== apps/accounts/__init__.py ====

```python

```

# ==== apps/accounts/admin.py ====

```python
from django.contrib import admin
from django.core.exceptions import ValidationError
from django.contrib import messages
from .models import StaffProfile, StaffAction


@admin.register(StaffProfile)
class StaffProfileAdmin(admin.ModelAdmin):
    list_display = ('user', 'user_email', 'role', 'department', 'can_approve_refunds', 'can_manage_staff', 'is_active', 'created_at')
    list_filter = ('role', 'department', 'is_active', 'created_at')
    search_fields = ('user__username', 'user__email', 'user__first_name', 'user__last_name')
    readonly_fields = ('can_approve_refunds', 'can_manage_staff', 'can_view_financial_reports', 'is_account_locked', 'created_at', 'updated_at')
    
    fieldsets = (
        ('User Information', {
            'fields': ('user', 'role', 'department', 'phone')
        }),
        ('Permissions', {
            'fields': ('can_approve_refunds', 'can_manage_staff', 'can_view_financial_reports'),
            'classes': ('collapse',)
        }),
        ('Security', {
            'fields': ('login_attempts', 'account_locked_until', 'is_account_locked', 'last_login_ip'),
            'classes': ('collapse',)
        }),
        ('Management', {
            'fields': ('is_active', 'hire_date', 'created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
    )
    
    def user_email(self, obj):
        return obj.user.email
    user_email.short_description = 'Email'
    user_email.admin_order_field = 'user__email'
    
    def save_model(self, request, obj, form, change):
        try:
            super().save_model(request, obj, form, change)
        except ValidationError as e:
            messages.error(request, f"Cannot save staff profile: {e}")
            raise
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related('user')


@admin.register(StaffAction)
class StaffActionAdmin(admin.ModelAdmin):
    list_display = ('staff_user', 'action_type', 'created_at', 'ip_address', 'customer_id', 'booking_id')
    list_filter = ('action_type', 'created_at')
    search_fields = ('staff_user__username', 'staff_user__email', 'description', 'ip_address')
    readonly_fields = ('staff_user', 'action_type', 'description', 'ip_address', 'user_agent', 'customer_id', 'booking_id', 'created_at')
    ordering = ('-created_at',)
    
    def has_add_permission(self, request):
        # Staff actions should only be created programmatically
        return False
    
    def has_change_permission(self, request, obj=None):
        # Staff actions should be immutable audit logs
        return False
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related('staff_user')
```

# ==== apps/accounts/apps.py ====

```python
from django.apps import AppConfig

class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.accounts'  # Changed from 'accounts' to 'apps.accounts'
```

# ==== apps/accounts/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.5 on 2025-09-02 20:54

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='StaffProfile',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('role', models.CharField(choices=[('staff', 'Staff'), ('admin', 'Admin')], default='staff', max_length=20)),
                ('department', models.CharField(blank=True, max_length=50)),
                ('hire_date', models.DateField(blank=True, null=True)),
                ('phone', models.CharField(blank=True, max_length=20)),
                ('last_login_ip', models.GenericIPAddressField(blank=True, null=True)),
                ('login_attempts', models.PositiveIntegerField(default=0)),
                ('account_locked_until', models.DateTimeField(blank=True, null=True)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='staff_profile', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Staff Profile',
                'verbose_name_plural': 'Staff Profiles',
                'db_table': 'accounts_staff_profile',
            },
        ),
        migrations.CreateModel(
            name='StaffAction',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('action_type', models.CharField(choices=[('login', 'Login'), ('logout', 'Logout'), ('view_customer', 'View Customer'), ('modify_booking', 'Modify Booking'), ('process_refund', 'Process Refund'), ('approve_refund', 'Approve Refund'), ('upload_document', 'Upload Document'), ('send_notification', 'Send Notification'), ('export_data', 'Export Data')], max_length=30)),
                ('description', models.TextField()),
                ('ip_address', models.GenericIPAddressField()),
                ('user_agent', models.TextField(blank=True)),
                ('customer_id', models.UUIDField(blank=True, help_text='Customer affected by action', null=True)),
                ('booking_id', models.UUIDField(blank=True, help_text='Booking affected by action', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('staff_user', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='staff_actions', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'accounts_staff_action',
                'ordering': ['-created_at'],
                'indexes': [models.Index(fields=['staff_user', '-created_at'], name='accounts_st_staff_u_7518f9_idx'), models.Index(fields=['action_type', '-created_at'], name='accounts_st_action__992fd0_idx'), models.Index(fields=['customer_id'], name='accounts_st_custome_407eb4_idx'), models.Index(fields=['booking_id'], name='accounts_st_booking_824dc4_idx')],
            },
        ),
    ]
```

# ==== apps/accounts/migrations/0002_alter_staffaction_action_type.py ====

```python
# Generated by Django 5.2.5 on 2025-09-25 23:09

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0001_initial'),
    ]

    operations = [
        migrations.AlterField(
            model_name='staffaction',
            name='action_type',
            field=models.CharField(choices=[('login', 'Login'), ('logout', 'Logout'), ('view_customer', 'View Customer'), ('modify_booking', 'Modify Booking'), ('process_refund', 'Process Refund'), ('approve_refund', 'Approve Refund'), ('upload_document', 'Upload Document'), ('send_notification', 'Send Notification'), ('export_data', 'Export Data'), ('view_dashboard', 'View Dashboard'), ('modify_customer', 'Modify Customer')], max_length=30),
        ),
    ]
```

# ==== apps/accounts/migrations/__init__.py ====

```python

```

# ==== apps/accounts/models.py ====

```python
import uuid
from django.contrib.auth.models import User
from django.db import models
from django.core.exceptions import ValidationError
from django.utils import timezone


class StaffProfile(models.Model):
    """Extended profile for staff users (Django User model + additional fields)"""
    
    ROLE_CHOICES = [
        ('staff', 'Staff'),
        ('admin', 'Admin'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='staff_profile')
    
    # Staff role within the staff system
    role = models.CharField(max_length=20, choices=ROLE_CHOICES, default='staff')
    
    # Staff-specific information
    department = models.CharField(max_length=50, blank=True)
    hire_date = models.DateField(null=True, blank=True)
    phone = models.CharField(max_length=20, blank=True)
    
    # Permissions tracking
    last_login_ip = models.GenericIPAddressField(null=True, blank=True)
    login_attempts = models.PositiveIntegerField(default=0)
    account_locked_until = models.DateTimeField(null=True, blank=True)
    
    # Management
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'accounts_staff_profile'
        verbose_name = 'Staff Profile'
        verbose_name_plural = 'Staff Profiles'
    
    def clean(self):
        """Prevent hybrid accounts - users cannot have both staff and customer profiles"""
        if self.user and hasattr(self.user, 'customer_profile'):
            raise ValidationError(
                f"User {self.user.email} already has a customer profile. "
                "Users cannot have both staff and customer profiles."
            )
    
    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)
    
    def __str__(self):
        return f"{self.user.get_full_name()} ({self.role})"
    
    @property
    def can_approve_refunds(self):
        """Only admin role can approve refunds"""
        return self.role == 'admin'
    
    @property
    def can_manage_staff(self):
        """Only admin role can manage other staff accounts"""
        return self.role == 'admin'
    
    @property
    def can_view_financial_reports(self):
        """Both staff and admin can view financial reports"""
        return self.role in ['staff', 'admin']
    
    @property
    def full_name(self):
        """Get full name from associated User model"""
        return self.user.get_full_name()
    
    @property
    def email(self):
        """Get email from associated User model"""
        return self.user.email
    
    def lock_account(self, minutes=30):
        """Lock account for specified minutes after failed login attempts"""
        self.account_locked_until = timezone.now() + timezone.timedelta(minutes=minutes)
        self.save()
    
    def unlock_account(self):
        """Unlock account and reset login attempts"""
        self.account_locked_until = None
        self.login_attempts = 0
        self.save()
    
    @property
    def is_account_locked(self):
        """Check if account is currently locked"""
        if self.account_locked_until:
            return timezone.now() < self.account_locked_until
        return False

    @classmethod
    def ensure_single_profile_type(cls, user):
        """Ensure user only has one type of profile"""
        if hasattr(user, 'staff_profile') and hasattr(user, 'customer_profile'):
            raise ValidationError(
                f"User {user.email} cannot have both staff and customer profiles. "
                "Please remove one profile type."
            )


class StaffAction(models.Model):
    """Audit log for staff actions - required for compliance"""
    
    ACTION_TYPES = [
        ('login', 'Login'),
        ('logout', 'Logout'),
        ('view_customer', 'View Customer'),
        ('modify_booking', 'Modify Booking'),
        ('process_refund', 'Process Refund'),
        ('approve_refund', 'Approve Refund'),
        ('upload_document', 'Upload Document'),
        ('send_notification', 'Send Notification'),
        ('export_data', 'Export Data'),
        ('view_dashboard', 'View Dashboard'),
        ('modify_customer', 'Modify Customer'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Who performed the action
    staff_user = models.ForeignKey(User, on_delete=models.PROTECT, related_name='staff_actions')
    
    # What action was performed
    action_type = models.CharField(max_length=30, choices=ACTION_TYPES)
    description = models.TextField()
    
    # Context information
    ip_address = models.GenericIPAddressField()
    user_agent = models.TextField(blank=True)
    
    # Related objects (for tracking what was accessed/modified)
    customer_id = models.UUIDField(null=True, blank=True, help_text="Customer affected by action")
    booking_id = models.UUIDField(null=True, blank=True, help_text="Booking affected by action")
    
    # Timing
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'accounts_staff_action'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['staff_user', '-created_at']),
            models.Index(fields=['action_type', '-created_at']),
            models.Index(fields=['customer_id']),
            models.Index(fields=['booking_id']),
        ]
    
    def __str__(self):
        return f"{self.staff_user.username} - {self.action_type} - {self.created_at}"
    
    @classmethod
    def log_action(cls, staff_user, action_type, description, request=None, customer_id=None, booking_id=None):
        """Helper method to log staff actions with proper IP detection"""
        ip_address = '127.0.0.1'  # default fallback
        user_agent = ''
        
        if request:
            # Get client IP from request
            x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
            if x_forwarded_for:
                ip_address = x_forwarded_for.split(',')[0].strip()
            else:
                ip_address = request.META.get('REMOTE_ADDR', '127.0.0.1')
            
            user_agent = request.META.get('HTTP_USER_AGENT', '')
        
        return cls.objects.create(
            staff_user=staff_user,
            action_type=action_type,
            description=description,
            ip_address=ip_address,
            user_agent=user_agent,
            customer_id=customer_id,
            booking_id=booking_id
        )
```

# ==== apps/accounts/serializers.py ====

```python
from rest_framework import serializers
from django.contrib.auth.models import User
from django.core.exceptions import ValidationError
from .models import StaffProfile, StaffAction


class StaffUserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ('id', 'username', 'email', 'first_name', 'last_name', 'is_active', 'date_joined')
        read_only_fields = ('id', 'date_joined')


class StaffProfileSerializer(serializers.ModelSerializer):
    user = StaffUserSerializer(read_only=True)
    full_name = serializers.ReadOnlyField()
    email = serializers.ReadOnlyField()
    can_approve_refunds = serializers.ReadOnlyField()
    can_manage_staff = serializers.ReadOnlyField()
    can_view_financial_reports = serializers.ReadOnlyField()
    
    class Meta:
        model = StaffProfile
        fields = (
            'id', 'user', 'role', 'department', 'hire_date', 'phone',
            'full_name', 'email', 'is_active', 'can_approve_refunds',
            'can_manage_staff', 'can_view_financial_reports', 'created_at'
        )
        read_only_fields = ('id', 'created_at')


class StaffLoginSerializer(serializers.Serializer):
    username = serializers.CharField()
    password = serializers.CharField(write_only=True)
    
    def validate(self, attrs):
        username = attrs.get('username')
        password = attrs.get('password')
        
        if not username or not password:
            raise serializers.ValidationError("Must include username and password")
        
        return attrs


class StaffActionSerializer(serializers.ModelSerializer):
    staff_user_name = serializers.SerializerMethodField()
    
    class Meta:
        model = StaffAction
        fields = (
            'id', 'action_type', 'description', 'staff_user_name',
            'ip_address', 'customer_id', 'booking_id', 'created_at'
        )
        read_only_fields = ('id', 'created_at')
    
    def get_staff_user_name(self, obj):
        return obj.staff_user.get_full_name() if obj.staff_user else None


class StaffCreateSerializer(serializers.Serializer):
    """Serializer for creating staff accounts with hybrid prevention"""
    username = serializers.CharField(max_length=150)
    email = serializers.EmailField()
    password = serializers.CharField(min_length=8, write_only=True)
    first_name = serializers.CharField(max_length=150)
    last_name = serializers.CharField(max_length=150)
    role = serializers.ChoiceField(choices=StaffProfile.ROLE_CHOICES)
    department = serializers.CharField(max_length=50, required=False, allow_blank=True)
    phone = serializers.CharField(max_length=20, required=False, allow_blank=True)
    
    def validate(self, attrs):
        # Check if email already exists
        if User.objects.filter(email__iexact=attrs['email']).exists():
            existing_user = User.objects.get(email__iexact=attrs['email'])
            if hasattr(existing_user, 'customer_profile'):
                raise serializers.ValidationError("This email is already registered as a customer account. Please use a different email.")
            else:
                raise serializers.ValidationError("User with this email already exists")
        
        # Check if username already exists
        if User.objects.filter(username=attrs['username']).exists():
            raise serializers.ValidationError("Username already exists")
        
        return attrs
    
    def create(self, validated_data):
        # Extract staff profile fields
        role = validated_data.pop('role')
        department = validated_data.pop('department', '')
        phone = validated_data.pop('phone', '')
        
        try:
            # Create User
            user = User.objects.create_user(**validated_data)
            
            # Create StaffProfile with validation
            StaffProfile.objects.create(
                user=user,
                role=role,
                department=department,
                phone=phone
            )
            
            return user
            
        except ValidationError as e:
            # Clean up user if profile creation fails
            if 'user' in locals():
                user.delete()
            raise serializers.ValidationError(str(e))
```

# ==== apps/accounts/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/accounts/urls.py ====

```python
from django.urls import path
from . import views

# Staff API patterns
urlpatterns = [
    # Authentication
    path('auth/login/', views.StaffLoginView.as_view(), name='staff-login'),
    path('auth/logout/', views.StaffLogoutView.as_view(), name='staff-logout'),
    
    # Dashboard and operations
    path('dashboard/', views.StaffDashboardView.as_view(), name='staff-dashboard'),
    path('bookings/', views.BookingManagementView.as_view(), name='staff-bookings'),
    path('bookings/<uuid:booking_id>/', views.BookingDetailView.as_view(), name='staff-booking-detail'),
    
    # Customer management
    path('customers/', views.CustomerManagementView.as_view(), name='staff-customers'),
    path('customers/<int:customer_id>/', views.CustomerDetailView.as_view(), name='staff-customer-detail'),
    path('customers/<int:customer_id>/notes/', views.CustomerNotesUpdateView.as_view(), name='staff-customer-notes'),
]
```

# ==== apps/accounts/views.py ====

```python
# backend/apps/accounts/views.py
from rest_framework import generics, status, permissions
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.contrib.auth import login, logout, authenticate
from django.contrib.auth.models import User
from django.middleware.csrf import get_token
from django.views.decorators.csrf import ensure_csrf_cookie
from django.utils.decorators import method_decorator
from django.shortcuts import get_object_or_404
from django.db.models import Q, Count
from django_ratelimit.decorators import ratelimit
from .models import StaffProfile, StaffAction
from .serializers import (
    StaffLoginSerializer,
    StaffProfileSerializer,
    StaffUserSerializer,
    StaffActionSerializer
)
from apps.bookings.models import Booking
from apps.customers.models import CustomerProfile
from apps.payments.models import Payment, Refund


@method_decorator(ratelimit(key='ip', rate='5/m', method='POST', block=True), name='post')
@method_decorator(ratelimit(key='header:user-agent', rate='10/m', method='POST', block=True), name='post')
class StaffLoginView(APIView):
    """Staff authentication endpoint with rate limiting protection"""
    permission_classes = [permissions.AllowAny]
    
    @method_decorator(ensure_csrf_cookie)
    def post(self, request):
        serializer = StaffLoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        username = serializer.validated_data['username']
        password = serializer.validated_data['password']
        
        user = authenticate(username=username, password=password)
        
        if user and user.is_active:
            # Check if user has staff profile
            if not hasattr(user, 'staff_profile'):
                return Response(
                    {'error': 'This is not a staff account'}, 
                    status=status.HTTP_403_FORBIDDEN
                )
            
            # Check if account is locked
            if user.staff_profile.is_account_locked:
                return Response(
                    {'error': 'Account is temporarily locked. Contact administrator.'}, 
                    status=status.HTTP_403_FORBIDDEN
                )
            
            login(request, user)
            
            # Log successful login
            StaffAction.log_action(
                staff_user=user,
                action_type='login',
                description=f'Staff user {user.username} logged in successfully',
                request=request
            )
            
            # Reset failed login attempts
            user.staff_profile.login_attempts = 0
            user.staff_profile.save()
            
            return Response({
                'message': 'Login successful',
                'user': StaffUserSerializer(user).data,
                'staff_profile': StaffProfileSerializer(user.staff_profile).data,
                'csrf_token': get_token(request)
            })
        else:
            # Handle failed login attempt
            if user:
                staff_profile = getattr(user, 'staff_profile', None)
                if staff_profile:
                    staff_profile.login_attempts += 1
                    if staff_profile.login_attempts >= 5:
                        staff_profile.lock_account(minutes=30)
                    staff_profile.save()
            
            return Response(
                {'error': 'Invalid username or password'}, 
                status=status.HTTP_401_UNAUTHORIZED
            )


@method_decorator(ratelimit(key='user', rate='10/m', method='POST', block=True), name='post')
class StaffLogoutView(APIView):
    """Staff logout endpoint with rate limiting"""
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        # Log logout action
        StaffAction.log_action(
            staff_user=request.user,
            action_type='logout',
            description=f'Staff user {request.user.username} logged out',
            request=request
        )
        
        logout(request)
        return Response({'message': 'Logout successful'})


@method_decorator(ratelimit(key='user', rate='30/m', method='GET', block=True), name='get')
class StaffDashboardView(APIView):
    """Staff operations dashboard with KPIs and rate limiting"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        if not hasattr(request.user, 'staff_profile'):
            return Response(
                {'error': 'Not a staff account'}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        # Log dashboard access
        StaffAction.log_action(
            staff_user=request.user,
            action_type='view_dashboard',
            description='Accessed staff dashboard',
            request=request
        )
        
        # Get booking statistics
        total_bookings = Booking.objects.filter(deleted_at__isnull=True).count()
        pending_bookings = Booking.objects.filter(status='pending', deleted_at__isnull=True).count()
        confirmed_bookings = Booking.objects.filter(status='confirmed', deleted_at__isnull=True).count()
        paid_bookings = Booking.objects.filter(status='paid', deleted_at__isnull=True).count()
        completed_bookings = Booking.objects.filter(status='completed', deleted_at__isnull=True).count()
        
        # Get payment statistics
        total_payments = Payment.objects.filter(status='succeeded').count()
        pending_payments = Payment.objects.filter(status='pending').count()
        failed_payments = Payment.objects.filter(status='failed').count()
        
        # Calculate revenue
        from django.db.models import Sum
        total_revenue_cents = Payment.objects.filter(status='succeeded').aggregate(
            total=Sum('amount_cents')
        )['total'] or 0
        
        # Get recent bookings needing attention
        urgent_bookings = Booking.objects.filter(
            status__in=['pending', 'confirmed'],
            deleted_at__isnull=True
        ).order_by('pickup_date', 'created_at')[:10]
        
        # Get customer statistics
        total_customers = CustomerProfile.objects.count()
        vip_customers = CustomerProfile.objects.filter(is_vip=True).count()
        
        return Response({
            'staff_info': {
                'name': request.user.get_full_name(),
                'role': request.user.staff_profile.role,
                'permissions': {
                    'can_approve_refunds': request.user.staff_profile.can_approve_refunds,
                    'can_manage_staff': request.user.staff_profile.can_manage_staff,
                    'can_view_financial_reports': request.user.staff_profile.can_view_financial_reports
                }
            },
            'booking_stats': {
                'total_bookings': total_bookings,
                'pending_bookings': pending_bookings,
                'confirmed_bookings': confirmed_bookings,
                'paid_bookings': paid_bookings,
                'completed_bookings': completed_bookings
            },
            'payment_stats': {
                'total_payments': total_payments,
                'pending_payments': pending_payments,
                'failed_payments': failed_payments,
                'total_revenue_dollars': total_revenue_cents / 100
            },
            'customer_stats': {
                'total_customers': total_customers,
                'vip_customers': vip_customers
            },
            'urgent_bookings': self._serialize_urgent_bookings(urgent_bookings)
        })
    
    def _serialize_urgent_bookings(self, bookings):
        """Serialize urgent bookings for dashboard"""
        urgent_data = []
        for booking in bookings:
            urgent_data.append({
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'customer_name': booking.get_customer_name(),
                'customer_email': booking.get_customer_email(),
                'service_type': booking.get_service_type_display(),
                'pickup_date': booking.pickup_date,
                'status': booking.get_status_display(),
                'total_price_dollars': booking.total_price_dollars,
                'created_at': booking.created_at
            })
        return urgent_data


@method_decorator(ratelimit(key='user', rate='20/m', method='GET', block=True), name='get')
class CustomerManagementView(APIView):
    """Staff customer management with rate limiting - list and search customers"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Not a staff account'}, status=status.HTTP_403_FORBIDDEN)
        
        # Get query parameters
        search = request.query_params.get('search', '')
        vip = request.query_params.get('vip', '')
        
        # Start with all customer profiles
        customers = User.objects.filter(customer_profile__isnull=False).select_related('customer_profile')
        
        # Apply search filter
        if search:
            customers = customers.filter(
                Q(first_name__icontains=search) |
                Q(last_name__icontains=search) |
                Q(email__icontains=search) |
                Q(customer_profile__phone__icontains=search)
            )
        
        # Apply VIP filter
        if vip == 'true':
            customers = customers.filter(customer_profile__is_vip=True)
        elif vip == 'false':
            customers = customers.filter(customer_profile__is_vip=False)
        
        # Serialize customer data
        customer_data = []
        for user in customers[:100]:  # Limit to 100 results
            profile = user.customer_profile
            
            # Get recent bookings
            recent_bookings = user.bookings.filter(deleted_at__isnull=True).order_by('-created_at')[:5]
            
            customer_data.append({
                'id': user.id,
                'name': user.get_full_name(),
                'email': user.email,
                'phone': profile.phone,
                'is_vip': profile.is_vip,
                'total_bookings': profile.total_bookings,
                'total_spent_dollars': profile.total_spent_dollars,
                'last_booking_at': profile.last_booking_at,
                'created_at': profile.created_at,
                'notes': profile.notes,
                'recent_bookings': [{
                    'id': str(booking.id),
                    'booking_number': booking.booking_number,
                    'service_type': booking.get_service_type_display(),
                    'status': booking.status,
                    'total_price_dollars': booking.total_price_dollars,
                    'created_at': booking.created_at
                } for booking in recent_bookings],
                'saved_addresses': [{
                    'id': str(addr.id),
                    'address_line_1': addr.address_line_1,
                    'city': addr.city,
                    'state': addr.state,
                    'is_primary': addr.times_used > 0
                } for addr in user.saved_addresses.filter(is_active=True)[:3]]
            })
        
        return Response({
            'customers': customer_data,
            'total_count': customers.count(),
            'filters': {
                'search': search,
                'vip': vip
            }
        })


@method_decorator(ratelimit(key='user', rate='15/m', method='GET', block=True), name='get')
class CustomerDetailView(APIView):
    """Staff view for individual customer details with rate limiting"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request, customer_id):
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Not a staff account'}, status=status.HTTP_403_FORBIDDEN)
        
        try:
            user = User.objects.get(id=customer_id, customer_profile__isnull=False)
            profile = user.customer_profile
        except User.DoesNotExist:
            return Response({'error': 'Customer not found'}, status=status.HTTP_404_NOT_FOUND)
        
        # Log viewing customer data
        StaffAction.log_action(
            staff_user=request.user,
            action_type='view_customer',
            description=f'Viewed customer {user.get_full_name()} ({user.email})',
            request=request,
            customer_id=user.id
        )
        
        # Get all bookings
        all_bookings = user.bookings.filter(deleted_at__isnull=True).order_by('-created_at')
        
        return Response({
            'id': user.id,
            'name': user.get_full_name(),
            'email': user.email,
            'phone': profile.phone,
            'is_vip': profile.is_vip,
            'total_bookings': profile.total_bookings,
            'total_spent_dollars': profile.total_spent_dollars,
            'last_booking_at': profile.last_booking_at,
            'created_at': profile.created_at,
            'notes': profile.notes,
            'recent_bookings': [{
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'service_type': booking.get_service_type_display(),
                'status': booking.status,
                'total_price_dollars': booking.total_price_dollars,
                'created_at': booking.created_at
            } for booking in all_bookings],
            'saved_addresses': [{
                'id': str(addr.id),
                'address_line_1': addr.address_line_1,
                'address_line_2': addr.address_line_2,
                'city': addr.city,
                'state': addr.state,
                'zip_code': addr.zip_code,
                'is_primary': addr.times_used > 0
            } for addr in user.saved_addresses.filter(is_active=True)]
        })


@method_decorator(ratelimit(key='user', rate='5/m', method='PATCH', block=True), name='patch')
class CustomerNotesUpdateView(APIView):
    """Update customer notes with rate limiting - staff only"""
    permission_classes = [permissions.IsAuthenticated]
    
    def patch(self, request, customer_id):
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Staff access required'}, status=status.HTTP_403_FORBIDDEN)
        
        try:
            user = User.objects.get(id=customer_id, customer_profile__isnull=False)
            profile = user.customer_profile
        except User.DoesNotExist:
            return Response({'error': 'Customer not found'}, status=status.HTTP_404_NOT_FOUND)
        
        notes = request.data.get('notes', '')
        old_notes = profile.notes
        
        profile.notes = notes
        profile.save()
        
        # Log notes update
        StaffAction.log_action(
            staff_user=request.user,
            action_type='modify_customer',
            description=f'Updated notes for customer {user.get_full_name()}',
            request=request,
            customer_id=user.id
        )
        
        return Response({
            'message': 'Customer notes updated successfully',
            'notes': profile.notes
        })


@method_decorator(ratelimit(key='user', rate='30/m', method='GET', block=True), name='get')
class BookingManagementView(APIView):
    """Enhanced staff booking management with rate limiting and date range support"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        """List all bookings with enhanced filtering including date ranges"""
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Not a staff account'}, status=status.HTTP_403_FORBIDDEN)
        
        # Get query parameters
        status_filter = request.query_params.get('status', None)
        date_filter = request.query_params.get('date', None)
        start_date = request.query_params.get('start_date', None)
        end_date = request.query_params.get('end_date', None)
        search = request.query_params.get('search', None)
        
        # Build queryset
        bookings = Booking.objects.filter(deleted_at__isnull=True).order_by('-created_at')
        
        if status_filter:
            bookings = bookings.filter(status=status_filter)
        
        if date_filter:
            bookings = bookings.filter(pickup_date=date_filter)
        
        # Date range filtering for calendar
        if start_date and end_date:
            bookings = bookings.filter(
                pickup_date__gte=start_date,
                pickup_date__lte=end_date
            )
        elif start_date:
            bookings = bookings.filter(pickup_date__gte=start_date)
        elif end_date:
            bookings = bookings.filter(pickup_date__lte=end_date)
        
        if search:
            bookings = bookings.filter(
                Q(booking_number__icontains=search) |
                Q(customer__email__icontains=search) |
                Q(guest_checkout__email__icontains=search) |
                Q(customer__first_name__icontains=search) |
                Q(customer__last_name__icontains=search) |
                Q(guest_checkout__first_name__icontains=search) |
                Q(guest_checkout__last_name__icontains=search)
            )
        
        # Serialize bookings
        booking_data = []
        for booking in bookings[:50]:  # Limit to 50 results
            booking_data.append({
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'customer_name': booking.get_customer_name(),
                'customer_email': booking.get_customer_email(),
                'service_type': booking.get_service_type_display(),
                'pickup_date': booking.pickup_date,
                'pickup_time': booking.get_pickup_time_display(),
                'status': booking.get_status_display(),
                'total_price_dollars': booking.total_price_dollars,
                'payment_status': self._get_payment_status(booking),
                'created_at': booking.created_at,
                'coi_required': booking.coi_required
            })
        
        return Response({
            'bookings': booking_data,
            'total_count': bookings.count(),
            'filters': {
                'status': status_filter,
                'date': date_filter,
                'start_date': start_date,
                'end_date': end_date,
                'search': search
            }
        })
    
    def _get_payment_status(self, booking):
        """Get payment status for booking"""
        payment = booking.payments.first()
        return payment.status if payment else 'not_created'


@method_decorator(ratelimit(key='user', rate='20/m', method='GET', block=True), name='get')
@method_decorator(ratelimit(key='user', rate='10/m', method='PATCH', block=True), name='patch')
class BookingDetailView(APIView):
    """Staff view for individual booking details and management with rate limiting"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request, booking_id):
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Not a staff account'}, status=status.HTTP_403_FORBIDDEN)
        
        try:
            booking = Booking.objects.get(id=booking_id, deleted_at__isnull=True)
        except Booking.DoesNotExist:
            return Response({'error': 'Booking not found'}, status=status.HTTP_404_NOT_FOUND)
        
        # Log viewing booking data
        StaffAction.log_action(
            staff_user=request.user,
            action_type='view_booking',
            description=f'Viewed booking {booking.booking_number}',
            request=request,
            booking_id=booking.id
        )
        
        # Get payment information
        payment = booking.payments.first()
        payment_data = None
        if payment:
            payment_data = {
                'id': str(payment.id),
                'status': payment.status,
                'amount_dollars': payment.amount_dollars,
                'stripe_payment_intent_id': payment.stripe_payment_intent_id,
                'processed_at': payment.processed_at,
                'failure_reason': payment.failure_reason
            }
        
        # Get customer information
        customer_data = None
        if booking.customer:
            customer_data = {
                'id': booking.customer.id,
                'name': booking.customer.get_full_name(),
                'email': booking.customer.email,
                'phone': getattr(booking.customer.customer_profile, 'phone', ''),
                'is_vip': getattr(booking.customer.customer_profile, 'is_vip', False),
                'total_bookings': getattr(booking.customer.customer_profile, 'total_bookings', 0),
                'total_spent_dollars': getattr(booking.customer.customer_profile, 'total_spent_dollars', 0)
            }
        
        return Response({
            'booking': {
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'service_type': booking.get_service_type_display(),
                'status': booking.status,
                'pickup_date': booking.pickup_date,
                'pickup_time': booking.get_pickup_time_display(),
                'pickup_address': {
                    'address_line_1': booking.pickup_address.address_line_1,
                    'address_line_2': booking.pickup_address.address_line_2,
                    'city': booking.pickup_address.city,
                    'state': booking.pickup_address.state,
                    'zip_code': booking.pickup_address.zip_code
                },
                'delivery_address': {
                    'address_line_1': booking.delivery_address.address_line_1,
                    'address_line_2': booking.delivery_address.address_line_2,
                    'city': booking.delivery_address.city,
                    'state': booking.delivery_address.state,
                    'zip_code': booking.delivery_address.zip_code
                },
                'special_instructions': booking.special_instructions,
                'coi_required': booking.coi_required,
                'total_price_dollars': booking.total_price_dollars,
                'pricing_breakdown': booking.get_pricing_breakdown(),
                'created_at': booking.created_at,
                'updated_at': booking.updated_at
            },
            'customer': customer_data,
            'guest_checkout': {
                'first_name': booking.guest_checkout.first_name if booking.guest_checkout else None,
                'last_name': booking.guest_checkout.last_name if booking.guest_checkout else None,
                'email': booking.guest_checkout.email if booking.guest_checkout else None,
                'phone': booking.guest_checkout.phone if booking.guest_checkout else None
            } if booking.guest_checkout else None,
            'payment': payment_data
        })
    
    def patch(self, request, booking_id):
        """Update booking status and details"""
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Not a staff account'}, status=status.HTTP_403_FORBIDDEN)
        
        try:
            booking = Booking.objects.get(id=booking_id, deleted_at__isnull=True)
        except Booking.DoesNotExist:
            return Response({'error': 'Booking not found'}, status=status.HTTP_404_NOT_FOUND)
        
        # Get update data
        new_status = request.data.get('status')
        staff_notes = request.data.get('staff_notes', '')
        
        old_status = booking.status
        
        # Update booking
        if new_status and new_status != old_status:
            booking.status = new_status
            booking.save()
            
            # Log status change
            StaffAction.log_action(
                staff_user=request.user,
                action_type='modify_booking',
                description=f'Changed booking {booking.booking_number} status from {old_status} to {new_status}. Notes: {staff_notes}',
                request=request,
                booking_id=booking.id
            )
        
        return Response({
            'message': 'Booking updated successfully',
            'booking': {
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'status': booking.status,
                'updated_at': booking.updated_at
            }
        })
```

# ==== apps/bookings/__init__.py ====

```python

```

# ==== apps/bookings/admin.py ====

```python
from django.contrib import admin
from django.utils.html import format_html
from .models import Booking, Address, GuestCheckout

@admin.register(Booking)
class BookingAdmin(admin.ModelAdmin):
    list_display = (
        'booking_number', 
        'get_customer_name', 
        'service_type', 
        'get_service_details',
        'get_organizing_services',  # NEW!
        'status', 
        'pickup_date', 
        'total_price_dollars'
    )
    list_filter = ('service_type', 'status', 'pickup_date', 'coi_required', 'include_packing', 'include_unpacking')
    search_fields = ('booking_number', 'customer__email', 'guest_checkout__email')
    readonly_fields = (
        'booking_number', 'base_price_cents', 'surcharge_cents', 
        'coi_fee_cents', 'organizing_total_cents', 'total_price_cents', 
        'created_at', 'updated_at'
    )
    
    fieldsets = (
        ('Customer Info', {
            'fields': ('customer', 'guest_checkout')
        }),
        ('Service Selection', {
            'fields': (
                'service_type', 
                'mini_move_package', 
                'standard_delivery_item_count',
                'is_same_day_delivery',
                'specialty_items'
            )
        }),
        ('NEW: Organizing Services', {
            'fields': ('include_packing', 'include_unpacking'),
            'classes': ('wide',),
            'description': 'Professional packing and unpacking services (Mini Moves only)'
        }),
        ('Booking Details', {
            'fields': ('pickup_date', 'pickup_time', 'pickup_address', 'delivery_address')
        }),
        ('Requirements', {
            'fields': ('special_instructions', 'coi_required')
        }),
        ('Calculated Pricing', {
            'fields': ('base_price_cents', 'surcharge_cents', 'coi_fee_cents', 'organizing_total_cents', 'total_price_cents'),
            'classes': ('collapse',)
        }),
        ('Status', {
            'fields': ('status',)
        }),
        ('System Info', {
            'fields': ('booking_number', 'created_at', 'updated_at'),
            'classes': ('collapse',)
        })
    )
    
    filter_horizontal = ('specialty_items',)
    
    def get_customer_name(self, obj):
        return obj.get_customer_name()
    get_customer_name.short_description = 'Customer'
    
    def get_service_details(self, obj):
        if obj.service_type == 'mini_move' and obj.mini_move_package:
            return obj.mini_move_package.name
        elif obj.service_type == 'standard_delivery' and obj.standard_delivery_item_count:
            return f"{obj.standard_delivery_item_count} items"
        elif obj.service_type == 'specialty_item':
            items = list(obj.specialty_items.all())
            return ", ".join([item.name for item in items[:2]]) + ("..." if len(items) > 2 else "")
        return "Not configured"
    get_service_details.short_description = 'Service Details'
    
    def get_organizing_services(self, obj):
        """Show organizing services for this booking"""
        if obj.service_type != 'mini_move':
            return "—"
        
        services = []
        if obj.include_packing:
            services.append("📦 Packing")
        if obj.include_unpacking:
            services.append("📤 Unpacking")
        
        if services:
            services_text = " + ".join(services)
            return format_html(
                '<span style="color: #059669; font-weight: bold;">{}</span><br>'
                '<small style="color: #6b7280;">${}</small>',
                services_text,
                obj.organizing_total_dollars
            )
        return format_html('<span style="color: #9ca3af;">None</span>')
    get_organizing_services.short_description = 'Organizing Services'


@admin.register(Address)
class AddressAdmin(admin.ModelAdmin):
    list_display = ('address_line_1', 'city', 'state', 'customer', 'created_at')
    list_filter = ('state', 'city')
    search_fields = ('address_line_1', 'city', 'customer__email')


@admin.register(GuestCheckout)
class GuestCheckoutAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', 'email', 'phone', 'created_at')
    search_fields = ('first_name', 'last_name', 'email')
    readonly_fields = ('created_at',)
```

# ==== apps/bookings/apps.py ====

```python
from django.apps import AppConfig

class BookingsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.bookings'  # Changed from 'bookings' to 'apps.bookings'
```

# ==== apps/bookings/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.5 on 2025-09-02 20:54

import django.core.validators
import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('services', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='GuestCheckout',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('first_name', models.CharField(max_length=100)),
                ('last_name', models.CharField(max_length=100)),
                ('email', models.EmailField(max_length=254)),
                ('phone', models.CharField(max_length=20, validators=[django.core.validators.RegexValidator(regex='^\\+?1?\\d{9,15}$')])),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'db_table': 'bookings_guest_checkout',
            },
        ),
        migrations.CreateModel(
            name='Address',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('address_line_1', models.CharField(max_length=200)),
                ('address_line_2', models.CharField(blank=True, max_length=200)),
                ('city', models.CharField(max_length=100)),
                ('state', models.CharField(choices=[('NY', 'New York'), ('CT', 'Connecticut'), ('NJ', 'New Jersey')], max_length=2)),
                ('zip_code', models.CharField(max_length=10)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('customer', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='booking_addresses', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'bookings_address',
            },
        ),
        migrations.CreateModel(
            name='Booking',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('booking_number', models.CharField(blank=True, max_length=20, unique=True)),
                ('service_type', models.CharField(choices=[('mini_move', 'Mini Move'), ('standard_delivery', 'Standard Delivery'), ('specialty_item', 'Specialty Item')], max_length=20)),
                ('standard_delivery_item_count', models.PositiveIntegerField(blank=True, help_text='Number of items for standard delivery', null=True)),
                ('is_same_day_delivery', models.BooleanField(default=False, help_text='Same-day delivery (flat $360 rate)')),
                ('pickup_date', models.DateField()),
                ('pickup_time', models.CharField(choices=[('morning', '8 AM - 11 AM'), ('afternoon', '12 PM - 3 PM'), ('evening', '4 PM - 7 PM')], default='morning', max_length=20)),
                ('special_instructions', models.TextField(blank=True)),
                ('coi_required', models.BooleanField(default=False)),
                ('base_price_cents', models.PositiveBigIntegerField(default=0)),
                ('surcharge_cents', models.PositiveBigIntegerField(default=0)),
                ('coi_fee_cents', models.PositiveBigIntegerField(default=0)),
                ('total_price_cents', models.PositiveBigIntegerField(default=0)),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('confirmed', 'Confirmed'), ('paid', 'Paid'), ('completed', 'Completed'), ('cancelled', 'Cancelled')], default='pending', max_length=20)),
                ('deleted_at', models.DateTimeField(blank=True, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('customer', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='bookings', to=settings.AUTH_USER_MODEL)),
                ('delivery_address', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='delivery_bookings', to='bookings.address')),
                ('mini_move_package', models.ForeignKey(blank=True, help_text='Selected mini move package (Petite/Standard/Full)', null=True, on_delete=django.db.models.deletion.PROTECT, to='services.minimovepackage')),
                ('pickup_address', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='pickup_bookings', to='bookings.address')),
                ('specialty_items', models.ManyToManyField(blank=True, help_text='Selected specialty items (Peloton, Surfboard, etc.)', to='services.specialtyitem')),
                ('guest_checkout', models.OneToOneField(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='booking', to='bookings.guestcheckout')),
            ],
            options={
                'db_table': 'bookings_booking',
                'constraints': [models.CheckConstraint(condition=models.Q(models.Q(('customer__isnull', False), ('guest_checkout__isnull', True)), models.Q(('customer__isnull', True), ('guest_checkout__isnull', False)), _connector='OR'), name='booking_exactly_one_customer_type')],
            },
        ),
    ]
```

# ==== apps/bookings/migrations/0002_booking_include_packing_booking_include_unpacking_and_more.py ====

```python
# Generated by Django 5.2.5 on 2025-09-08 21:42

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('bookings', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='booking',
            name='include_packing',
            field=models.BooleanField(default=False, help_text='Include professional packing service for this Mini Move tier'),
        ),
        migrations.AddField(
            model_name='booking',
            name='include_unpacking',
            field=models.BooleanField(default=False, help_text='Include professional unpacking service for this Mini Move tier'),
        ),
        migrations.AddField(
            model_name='booking',
            name='organizing_total_cents',
            field=models.PositiveBigIntegerField(default=0, help_text='Total cost for packing and unpacking services'),
        ),
    ]
```

# ==== apps/bookings/migrations/0003_booking_geographic_surcharge_cents_and_more.py ====

```python
# Generated by Django 5.2.5 on 2025-09-19 23:12

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('bookings', '0002_booking_include_packing_booking_include_unpacking_and_more'),
    ]

    operations = [
        migrations.AddField(
            model_name='booking',
            name='geographic_surcharge_cents',
            field=models.PositiveBigIntegerField(default=0, help_text='$175 surcharge for 30+ miles from Manhattan'),
        ),
        migrations.AddField(
            model_name='booking',
            name='is_outside_core_area',
            field=models.BooleanField(default=False, help_text='True if pickup/delivery is 30+ miles from Manhattan'),
        ),
        migrations.AddField(
            model_name='booking',
            name='organizing_tax_cents',
            field=models.PositiveBigIntegerField(default=0, help_text='Tax on organizing services'),
        ),
        migrations.AddField(
            model_name='booking',
            name='specific_pickup_hour',
            field=models.PositiveSmallIntegerField(blank=True, choices=[(8, '8:00 AM - 9:00 AM'), (9, '9:00 AM - 10:00 AM'), (10, '10:00 AM - 11:00 AM')], help_text='Specific hour for 1-hour window pickup', null=True),
        ),
        migrations.AddField(
            model_name='booking',
            name='time_window_surcharge_cents',
            field=models.PositiveBigIntegerField(default=0, help_text='Surcharge for specific 1-hour window'),
        ),
        migrations.AlterField(
            model_name='booking',
            name='pickup_time',
            field=models.CharField(choices=[('morning', '8 AM - 11 AM'), ('morning_specific', 'Specific 1-hour window (surcharge applies)'), ('no_time_preference', 'No time preference (available for certain packages)')], default='morning', max_length=30),
        ),
    ]
```

# ==== apps/bookings/migrations/__init__.py ====

```python

```

# ==== apps/bookings/models.py ====

```python
import uuid
from django.db import models
from django.utils import timezone
from django.contrib.auth.models import User
from django.core.validators import RegexValidator


class Address(models.Model):
    """Address for pickup/delivery - can be saved by customer or one-time"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Optional customer link (for saved addresses)
    customer = models.ForeignKey(
        User, 
        on_delete=models.CASCADE, 
        null=True, 
        blank=True,
        related_name='booking_addresses'
    )
    
    # Address fields
    address_line_1 = models.CharField(max_length=200)
    address_line_2 = models.CharField(max_length=200, blank=True)
    city = models.CharField(max_length=100)
    state = models.CharField(max_length=2, choices=[
        ('NY', 'New York'),
        ('CT', 'Connecticut'), 
        ('NJ', 'New Jersey'),
    ])
    zip_code = models.CharField(max_length=10)
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'bookings_address'
    
    def __str__(self):
        return f"{self.address_line_1}, {self.city}, {self.state} {self.zip_code}"


class GuestCheckout(models.Model):
    """Guest customer info for non-authenticated bookings"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    email = models.EmailField()
    phone = models.CharField(
        max_length=20, 
        validators=[RegexValidator(regex=r'^\+?1?\d{9,15}$')]
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'bookings_guest_checkout'
    
    def __str__(self):
        return f"{self.first_name} {self.last_name} ({self.email})"


class Booking(models.Model):
    """Core booking - works with customer OR guest checkout - WITH SERVICES INTEGRATION"""
    
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('confirmed', 'Confirmed'),
        ('paid', 'Paid'),
        ('completed', 'Completed'),
        ('cancelled', 'Cancelled'),
    ]
    
    SERVICE_TYPE_CHOICES = [
        ('mini_move', 'Mini Move'),
        ('standard_delivery', 'Standard Delivery'),
        ('specialty_item', 'Specialty Item'),
    ]
    
    # UPDATED: Only morning pickup time available
    PICKUP_TIME_CHOICES = [
        ('morning', '8 AM - 11 AM'),
        ('morning_specific', 'Specific 1-hour window (surcharge applies)'),
        ('no_time_preference', 'No time preference (available for certain packages)'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    booking_number = models.CharField(max_length=20, unique=True, blank=True)
    
    # Customer - EITHER customer OR guest_checkout
    customer = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name='bookings'
    )
    guest_checkout = models.OneToOneField(
        GuestCheckout,
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name='booking'
    )
    
    # Service details
    service_type = models.CharField(max_length=20, choices=SERVICE_TYPE_CHOICES)
    
    # SERVICE CONNECTIONS
    # For Mini Move bookings
    mini_move_package = models.ForeignKey(
        'services.MiniMovePackage',
        on_delete=models.PROTECT,
        null=True,
        blank=True,
        help_text="Selected mini move package (Petite/Standard/Full)"
    )
    
    # For Standard Delivery bookings  
    standard_delivery_item_count = models.PositiveIntegerField(
        null=True,
        blank=True,
        help_text="Number of items for standard delivery"
    )
    is_same_day_delivery = models.BooleanField(
        default=False,
        help_text="Same-day delivery (flat $360 rate)"
    )
    
    # For Specialty Item bookings
    specialty_items = models.ManyToManyField(
        'services.SpecialtyItem',
        blank=True,
        help_text="Selected specialty items (Peloton, Surfboard, etc.)"
    )
    
    # NEW: ORGANIZING SERVICES (tied to Mini Move packages)
    include_packing = models.BooleanField(
        default=False,
        help_text="Include professional packing service for this Mini Move tier"
    )
    include_unpacking = models.BooleanField(
        default=False,
        help_text="Include professional unpacking service for this Mini Move tier"
    )
    
    # Addresses
    pickup_address = models.ForeignKey(
        Address, 
        on_delete=models.PROTECT, 
        related_name='pickup_bookings'
    )
    delivery_address = models.ForeignKey(
        Address, 
        on_delete=models.PROTECT, 
        related_name='delivery_bookings'
    )
    
    # Date and preferences - UPDATED: Only morning times
    pickup_date = models.DateField()
    pickup_time = models.CharField(
        max_length=30,
        choices=PICKUP_TIME_CHOICES,
        default='morning'
    )
    
    # NEW: Specific time window for morning_specific option
    specific_pickup_hour = models.PositiveSmallIntegerField(
        null=True,
        blank=True,
        choices=[
            (8, '8:00 AM - 9:00 AM'),
            (9, '9:00 AM - 10:00 AM'),
            (10, '10:00 AM - 11:00 AM'),
        ],
        help_text="Specific hour for 1-hour window pickup"
    )
    
    # Special requirements
    special_instructions = models.TextField(blank=True)
    coi_required = models.BooleanField(default=False)
    
    # NEW: Geographic surcharge tracking
    is_outside_core_area = models.BooleanField(
        default=False,
        help_text="True if pickup/delivery is 30+ miles from Manhattan"
    )
    
    # CALCULATED PRICING - Updated to include new fees
    base_price_cents = models.PositiveBigIntegerField(default=0)
    surcharge_cents = models.PositiveBigIntegerField(default=0)
    coi_fee_cents = models.PositiveBigIntegerField(default=0)
    organizing_total_cents = models.PositiveBigIntegerField(
        default=0,
        help_text="Total cost for packing and unpacking services"
    )
    geographic_surcharge_cents = models.PositiveBigIntegerField(
        default=0,
        help_text="$175 surcharge for 30+ miles from Manhattan"
    )
    time_window_surcharge_cents = models.PositiveBigIntegerField(
        default=0,
        help_text="Surcharge for specific 1-hour window"
    )
    organizing_tax_cents = models.PositiveBigIntegerField(
        default=0,
        help_text="Tax on organizing services"
    )
    total_price_cents = models.PositiveBigIntegerField(default=0)
    
    # Status
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    
    # Soft delete
    deleted_at = models.DateTimeField(null=True, blank=True)
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'bookings_booking'
        constraints = [
            models.CheckConstraint(
                check=(
                    models.Q(customer__isnull=False, guest_checkout__isnull=True) |
                    models.Q(customer__isnull=True, guest_checkout__isnull=False)
                ),
                name='booking_exactly_one_customer_type'
            )
        ]
    
    def save(self, *args, **kwargs):
        if not self.booking_number:
            # Simple booking number generation
            last_booking = Booking.objects.order_by('created_at').last()
            if last_booking and last_booking.booking_number:
                last_num = int(last_booking.booking_number.split('-')[1])
                next_num = last_num + 1
            else:
                next_num = 1
            self.booking_number = f"TT-{next_num:06d}"
        
        # Calculate pricing before saving
        self.calculate_pricing()
        super().save(*args, **kwargs)
    
    def __str__(self):
        customer_name = self.get_customer_name()
        return f"{self.booking_number} - {customer_name} - ${self.total_price_dollars}"
    
    def get_customer_name(self):
        if self.customer:
            return self.customer.get_full_name()
        elif self.guest_checkout:
            return f"{self.guest_checkout.first_name} {self.guest_checkout.last_name}"
        return "Unknown"
    
    def get_customer_email(self):
        if self.customer:
            return self.customer.email
        elif self.guest_checkout:
            return self.guest_checkout.email
        return None
    
    @property
    def total_price_dollars(self):
        return self.total_price_cents / 100
    
    @property
    def base_price_dollars(self):
        return self.base_price_cents / 100
    
    @property
    def surcharge_dollars(self):
        return self.surcharge_cents / 100
    
    @property
    def coi_fee_dollars(self):
        return self.coi_fee_cents / 100
    
    @property
    def organizing_total_dollars(self):
        return self.organizing_total_cents / 100
    
    @property
    def geographic_surcharge_dollars(self):
        return self.geographic_surcharge_cents / 100
    
    @property
    def time_window_surcharge_dollars(self):
        return self.time_window_surcharge_cents / 100
    
    @property
    def organizing_tax_dollars(self):
        return self.organizing_tax_cents / 100
    
    def calculate_organizing_costs(self):
        """Calculate organizing service costs based on Mini Move tier"""
        if self.service_type != 'mini_move' or not self.mini_move_package:
            return 0
        
        from apps.services.models import OrganizingService
        
        total_organizing_cents = 0
        tier = self.mini_move_package.package_type
        
        # Add packing service cost
        if self.include_packing:
            try:
                packing_service = OrganizingService.objects.get(
                    mini_move_tier=tier,
                    is_packing_service=True,
                    is_active=True
                )
                total_organizing_cents += packing_service.price_cents
            except OrganizingService.DoesNotExist:
                pass
        
        # Add unpacking service cost
        if self.include_unpacking:
            try:
                unpacking_service = OrganizingService.objects.get(
                    mini_move_tier=tier,
                    is_packing_service=False,
                    is_active=True
                )
                total_organizing_cents += unpacking_service.price_cents
            except OrganizingService.DoesNotExist:
                pass
        
        return total_organizing_cents
    
    def calculate_coi_fee(self):
        """Calculate COI fee - $50 for Petite moves if required"""
        if not self.coi_required:
            return 0
        
        if self.service_type == 'mini_move' and self.mini_move_package:
            # Petite moves require $50 COI charge
            if self.mini_move_package.package_type == 'petite':
                return 5000  # $50 in cents
            # Other packages may have different COI handling
            elif not self.mini_move_package.coi_included:
                return self.mini_move_package.coi_fee_cents
        
        return 0
    
    def calculate_geographic_surcharge(self):
        """Calculate $175 surcharge for 30+ miles from Manhattan"""
        if self.is_outside_core_area:
            return 17500  # $175 in cents
        return 0
    
    def calculate_time_window_surcharge(self):
        """UPDATED: Calculate $175 surcharge for 1-hour window selection"""
        if self.pickup_time == 'morning_specific':
            if self.service_type == 'mini_move' and self.mini_move_package:
                # Standard package: $175 surcharge (UPDATED from $25)
                if self.mini_move_package.package_type == 'standard':
                    return 17500  # $175 in cents
                # Full package: still free
                elif self.mini_move_package.package_type == 'full':
                    return 0
        return 0
    
    def calculate_organizing_tax(self):
        """UPDATED: Calculate tax on organizing services - 8.75% (changed from 8.25%)"""
        if self.organizing_total_cents > 0:
            return int(self.organizing_total_cents * 0.0875)  # Changed from 0.0825
        return 0
    
    def calculate_pricing(self):
        """Calculate total pricing using services pricing engine + all new features"""
        from apps.services.models import StandardDeliveryConfig, SurchargeRule
        
        # Reset pricing
        self.base_price_cents = 0
        self.surcharge_cents = 0
        self.coi_fee_cents = 0
        self.organizing_total_cents = 0
        self.geographic_surcharge_cents = 0
        self.time_window_surcharge_cents = 0
        self.organizing_tax_cents = 0
        
        # Calculate base price by service type
        if self.service_type == 'mini_move' and self.mini_move_package:
            self.base_price_cents = self.mini_move_package.base_price_cents
            
            # Calculate organizing services first
            self.organizing_total_cents = self.calculate_organizing_costs()
            
            # Calculate organizing tax
            self.organizing_tax_cents = self.calculate_organizing_tax()
            
            # NEW: COI handling with $50 for Petite
            self.coi_fee_cents = self.calculate_coi_fee()
            
        elif self.service_type == 'standard_delivery' and self.standard_delivery_item_count:
            try:
                config = StandardDeliveryConfig.objects.filter(is_active=True).first()
                if config:
                    self.base_price_cents = config.calculate_total(
                        self.standard_delivery_item_count,
                        is_same_day=self.is_same_day_delivery
                    )
            except StandardDeliveryConfig.DoesNotExist:
                pass
        
        elif self.service_type == 'specialty_item':
            # Calculate total for all selected specialty items
            specialty_total = 0
            for item in self.specialty_items.all():
                specialty_total += item.price_cents
            self.base_price_cents = specialty_total
        
        # UPDATED: Calculate surcharges with service type awareness
        if self.pickup_date and not self.is_same_day_delivery:
            active_surcharges = SurchargeRule.objects.filter(is_active=True)
            for surcharge in active_surcharges:
                surcharge_amount = surcharge.calculate_surcharge(
                    self.base_price_cents, 
                    self.pickup_date,
                    self.service_type  # NEW: Pass service type
                )
                self.surcharge_cents += surcharge_amount
        
        # NEW: Calculate additional fees
        self.geographic_surcharge_cents = self.calculate_geographic_surcharge()
        self.time_window_surcharge_cents = self.calculate_time_window_surcharge()
        
        # Calculate total (base + all surcharges + organizing + tax)
        self.total_price_cents = (
            self.base_price_cents + 
            self.surcharge_cents + 
            self.coi_fee_cents + 
            self.organizing_total_cents +
            self.organizing_tax_cents +
            self.geographic_surcharge_cents +
            self.time_window_surcharge_cents
        )
    
    def get_pricing_breakdown(self):
        """Return detailed pricing breakdown for display"""
        breakdown = {
            'base_price': self.base_price_dollars,
            'surcharges': self.surcharge_dollars,
            'coi_fee': self.coi_fee_dollars,
            'organizing_total': self.organizing_total_dollars,
            'organizing_tax': self.organizing_tax_dollars,
            'geographic_surcharge': self.geographic_surcharge_dollars,
            'time_window_surcharge': self.time_window_surcharge_dollars,
            'total': self.total_price_dollars,
            'service_type': self.get_service_type_display(),
        }
        
        # Add organizing service details if applicable
        if self.organizing_total_cents > 0:
            breakdown['organizing_services'] = self.get_organizing_services_breakdown()
        
        return breakdown
    
    def get_organizing_services_breakdown(self):
        """Get detailed breakdown of organizing services"""
        if self.service_type != 'mini_move' or not self.mini_move_package:
            return {}
        
        from apps.services.models import OrganizingService
        
        services = []
        tier = self.mini_move_package.package_type
        
        if self.include_packing:
            try:
                packing_service = OrganizingService.objects.get(
                    mini_move_tier=tier,
                    is_packing_service=True,
                    is_active=True
                )
                services.append({
                    'name': packing_service.name,
                    'price_dollars': packing_service.price_dollars,
                    'duration_hours': packing_service.duration_hours,
                    'organizer_count': packing_service.organizer_count,
                    'supplies_allowance': packing_service.supplies_allowance_dollars
                })
            except OrganizingService.DoesNotExist:
                pass
        
        if self.include_unpacking:
            try:
                unpacking_service = OrganizingService.objects.get(
                    mini_move_tier=tier,
                    is_packing_service=False,
                    is_active=True
                )
                services.append({
                    'name': unpacking_service.name,
                    'price_dollars': unpacking_service.price_dollars,
                    'duration_hours': unpacking_service.duration_hours,
                    'organizer_count': unpacking_service.organizer_count,
                    'supplies_allowance': 0  # Unpacking doesn't include supplies
                })
            except OrganizingService.DoesNotExist:
                pass
        
        return services
```

# ==== apps/bookings/serializers.py ====

```python
# backend/apps/bookings/serializers.py
from rest_framework import serializers
from django.contrib.auth.models import User
from .models import Booking, Address, GuestCheckout
from apps.services.models import MiniMovePackage, SpecialtyItem, OrganizingService


class AddressSerializer(serializers.ModelSerializer):
    class Meta:
        model = Address
        fields = (
            'id', 'address_line_1', 'address_line_2', 
            'city', 'state', 'zip_code'
        )


class GuestCheckoutSerializer(serializers.ModelSerializer):
    class Meta:
        model = GuestCheckout
        fields = ('first_name', 'last_name', 'email', 'phone')


class OrganizingServiceDetailSerializer(serializers.ModelSerializer):
    """Detailed organizing service info for booking responses"""
    price_dollars = serializers.ReadOnlyField()
    supplies_allowance_dollars = serializers.ReadOnlyField()
    
    class Meta:
        model = OrganizingService
        fields = (
            'id', 'service_type', 'name', 'description',
            'price_dollars', 'duration_hours', 'organizer_count',
            'supplies_allowance_dollars', 'is_packing_service'
        )


class BookingSerializer(serializers.ModelSerializer):
    customer_name = serializers.SerializerMethodField()
    customer_email = serializers.SerializerMethodField()
    pickup_address = AddressSerializer(read_only=True)
    delivery_address = AddressSerializer(read_only=True)
    guest_checkout = GuestCheckoutSerializer(read_only=True)
    total_price_dollars = serializers.ReadOnlyField()
    organizing_total_dollars = serializers.ReadOnlyField()
    pricing_breakdown = serializers.SerializerMethodField()
    organizing_services_breakdown = serializers.SerializerMethodField()
    
    class Meta:
        model = Booking
        fields = (
            'id', 'booking_number', 'customer_name', 'customer_email',
            'service_type', 'pickup_date', 'pickup_time', 'specific_pickup_hour', 'status',
            'pickup_address', 'delivery_address', 'guest_checkout',
            'special_instructions', 'coi_required', 'is_outside_core_area',
            'include_packing', 'include_unpacking',
            'total_price_dollars', 'organizing_total_dollars',
            'pricing_breakdown', 'organizing_services_breakdown', 'created_at'
        )
    
    def get_customer_name(self, obj):
        return obj.get_customer_name()
    
    def get_customer_email(self, obj):
        return obj.get_customer_email()
    
    def get_pricing_breakdown(self, obj):
        return obj.get_pricing_breakdown()
    
    def get_organizing_services_breakdown(self, obj):
        return obj.get_organizing_services_breakdown()


class BookingStatusSerializer(serializers.ModelSerializer):
    customer_name = serializers.SerializerMethodField()
    pickup_address = AddressSerializer(read_only=True)
    delivery_address = AddressSerializer(read_only=True)
    total_price_dollars = serializers.ReadOnlyField()
    organizing_total_dollars = serializers.ReadOnlyField()
    
    class Meta:
        model = Booking
        fields = (
            'booking_number', 'customer_name', 'service_type', 
            'pickup_date', 'pickup_time', 'specific_pickup_hour', 'status',
            'pickup_address', 'delivery_address',
            'include_packing', 'include_unpacking',
            'total_price_dollars', 'organizing_total_dollars', 'created_at'
        )
    
    def get_customer_name(self, obj):
        return obj.get_customer_name()


class PricingPreviewSerializer(serializers.Serializer):
    service_type = serializers.ChoiceField(choices=[
        ('mini_move', 'Mini Move'),
        ('standard_delivery', 'Standard Delivery'),
        ('specialty_item', 'Specialty Item')
    ])
    pickup_date = serializers.DateField()
    
    # Mini Move fields
    mini_move_package_id = serializers.UUIDField(required=False)
    coi_required = serializers.BooleanField(required=False, default=False)
    
    # NEW: Organizing service fields
    include_packing = serializers.BooleanField(required=False, default=False)
    include_unpacking = serializers.BooleanField(required=False, default=False)
    
    # UPDATED: New pickup time options
    pickup_time = serializers.ChoiceField(
        choices=[
            ('morning', '8 AM - 11 AM'),
            ('morning_specific', 'Specific 1-hour window'),
            ('no_time_preference', 'No time preference'),
        ],
        required=False,
        default='morning'
    )
    specific_pickup_hour = serializers.IntegerField(required=False, min_value=8, max_value=10)
    
    # NEW: Geographic surcharge
    is_outside_core_area = serializers.BooleanField(required=False, default=False)
    
    # Standard Delivery fields
    standard_delivery_item_count = serializers.IntegerField(required=False, min_value=1)
    is_same_day_delivery = serializers.BooleanField(required=False, default=False)
    
    # Specialty Items fields
    specialty_item_ids = serializers.ListField(
        child=serializers.UUIDField(),
        required=False,
        allow_empty=True
    )


class GuestBookingCreateSerializer(serializers.Serializer):
    # Guest customer info
    first_name = serializers.CharField(max_length=100)
    last_name = serializers.CharField(max_length=100)
    email = serializers.EmailField()
    phone = serializers.CharField(max_length=20)
    
    # Service selection
    service_type = serializers.ChoiceField(choices=[
        ('mini_move', 'Mini Move'),
        ('standard_delivery', 'Standard Delivery'),
        ('specialty_item', 'Specialty Item')
    ])
    
    # Service-specific fields
    mini_move_package_id = serializers.UUIDField(required=False)
    standard_delivery_item_count = serializers.IntegerField(required=False, min_value=1)
    is_same_day_delivery = serializers.BooleanField(default=False)
    specialty_item_ids = serializers.ListField(
        child=serializers.UUIDField(),
        required=False,
        allow_empty=True
    )
    
    # NEW: Organizing services for Mini Moves
    include_packing = serializers.BooleanField(default=False)
    include_unpacking = serializers.BooleanField(default=False)
    
    # Booking details - UPDATED: New pickup time options
    pickup_date = serializers.DateField()
    pickup_time = serializers.ChoiceField(choices=[
        ('morning', '8 AM - 11 AM'),
        ('morning_specific', 'Specific 1-hour window'),
        ('no_time_preference', 'No time preference'),
    ], default='morning')
    specific_pickup_hour = serializers.IntegerField(required=False, min_value=8, max_value=10)
    
    # NEW: Geographic surcharge
    is_outside_core_area = serializers.BooleanField(default=False)
    
    # Addresses
    pickup_address = serializers.DictField()
    delivery_address = serializers.DictField()
    
    # Additional info
    special_instructions = serializers.CharField(required=False, allow_blank=True)
    coi_required = serializers.BooleanField(default=False)
    
    def validate_pickup_address(self, value):
        required_fields = ['address_line_1', 'city', 'state', 'zip_code']
        for field in required_fields:
            if field not in value:
                raise serializers.ValidationError(f"Missing required field: {field}")
        return value
    
    def validate_delivery_address(self, value):
        required_fields = ['address_line_1', 'city', 'state', 'zip_code']
        for field in required_fields:
            if field not in value:
                raise serializers.ValidationError(f"Missing required field: {field}")
        return value
    
    def validate(self, attrs):
        service_type = attrs['service_type']
        pickup_time = attrs.get('pickup_time', 'morning')
        
        # Validate specific hour if morning_specific is selected
        if pickup_time == 'morning_specific' and not attrs.get('specific_pickup_hour'):
            raise serializers.ValidationError("specific_pickup_hour is required when pickup_time is 'morning_specific'")
        
        # Validate service-specific requirements
        if service_type == 'mini_move':
            if not attrs.get('mini_move_package_id'):
                raise serializers.ValidationError("mini_move_package_id is required for mini move service")
            
            # Validate organizing services only apply to mini moves
            include_packing = attrs.get('include_packing', False)
            include_unpacking = attrs.get('include_unpacking', False)
            
            if include_packing or include_unpacking:
                # Verify the mini move package exists and organizing services are available
                try:
                    package = MiniMovePackage.objects.get(id=attrs['mini_move_package_id'])
                    tier = package.package_type
                    
                    if include_packing:
                        if not OrganizingService.objects.filter(
                            mini_move_tier=tier,
                            is_packing_service=True,
                            is_active=True
                        ).exists():
                            raise serializers.ValidationError(f"Packing service not available for {tier} tier")
                    
                    if include_unpacking:
                        if not OrganizingService.objects.filter(
                            mini_move_tier=tier,
                            is_packing_service=False,
                            is_active=True
                        ).exists():
                            raise serializers.ValidationError(f"Unpacking service not available for {tier} tier")
                            
                except MiniMovePackage.DoesNotExist:
                    raise serializers.ValidationError("Invalid mini move package")
        else:
            # Organizing services only available for Mini Moves
            if attrs.get('include_packing') or attrs.get('include_unpacking'):
                raise serializers.ValidationError("Organizing services are only available for Mini Move bookings")
        
        if service_type == 'standard_delivery':
            if not attrs.get('standard_delivery_item_count'):
                raise serializers.ValidationError("standard_delivery_item_count is required for standard delivery")
        
        elif service_type == 'specialty_item':
            if not attrs.get('specialty_item_ids'):
                raise serializers.ValidationError("specialty_item_ids is required for specialty item service")
        
        return attrs
    
    def create(self, validated_data):
        # Create guest checkout
        guest_checkout = GuestCheckout.objects.create(
            first_name=validated_data['first_name'],
            last_name=validated_data['last_name'],
            email=validated_data['email'],
            phone=validated_data['phone']
        )
        
        # Create addresses
        pickup_address_data = validated_data.pop('pickup_address')
        pickup_address = Address.objects.create(**pickup_address_data)
        
        delivery_address_data = validated_data.pop('delivery_address')
        delivery_address = Address.objects.create(**delivery_address_data)
        
        # Create booking
        booking = Booking.objects.create(
            guest_checkout=guest_checkout,
            service_type=validated_data['service_type'],
            pickup_date=validated_data['pickup_date'],
            pickup_time=validated_data['pickup_time'],
            specific_pickup_hour=validated_data.get('specific_pickup_hour'),
            pickup_address=pickup_address,
            delivery_address=delivery_address,
            special_instructions=validated_data.get('special_instructions', ''),
            coi_required=validated_data.get('coi_required', False),
            is_outside_core_area=validated_data.get('is_outside_core_area', False),
            standard_delivery_item_count=validated_data.get('standard_delivery_item_count'),
            is_same_day_delivery=validated_data.get('is_same_day_delivery', False),
            # NEW: Organizing service fields
            include_packing=validated_data.get('include_packing', False),
            include_unpacking=validated_data.get('include_unpacking', False)
        )
        
        # Handle service-specific relationships
        if validated_data['service_type'] == 'mini_move':
            try:
                package = MiniMovePackage.objects.get(id=validated_data['mini_move_package_id'])
                booking.mini_move_package = package
            except MiniMovePackage.DoesNotExist:
                raise serializers.ValidationError("Invalid mini move package")
        
        elif validated_data['service_type'] == 'specialty_item':
            specialty_items = SpecialtyItem.objects.filter(
                id__in=validated_data.get('specialty_item_ids', [])
            )
            booking.save()  # Save first to get ID for M2M relationship
            booking.specialty_items.set(specialty_items)
        
        booking.save()  # This will trigger pricing calculation including organizing
        return booking
```

# ==== apps/bookings/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/bookings/urls.py ====

```python
from django.urls import path
from . import views

# Public booking API patterns - no authentication required
urlpatterns = [
    # Service information
    path('services/', views.ServiceCatalogView.as_view(), name='service-catalog'),
    path('pricing-preview/', views.PricingPreviewView.as_view(), name='pricing-preview'),
    path('availability/', views.CalendarAvailabilityView.as_view(), name='calendar-availability'),
    
    # NEW: Organizing service endpoints
    path('services/mini-moves-with-organizing/', views.ServiceCatalogWithOrganizingView.as_view(), name='mini-moves-with-organizing'),
    path('services/organizing-by-tier/', views.OrganizingServicesByTierView.as_view(), name='organizing-by-tier'),
    path('services/organizing/<uuid:service_id>/', views.OrganizingServiceDetailView.as_view(), name='organizing-service-detail'),
    
    # Guest booking
    path('guest-booking/', views.GuestBookingCreateView.as_view(), name='guest-booking-create'),
    
    # Booking status lookup
    path('booking-status/<str:booking_number>/', views.BookingStatusView.as_view(), name='booking-status'),
    path('calendar/availability/', views.CalendarAvailabilityView.as_view(), name='calendar-availability'),
    path('fix-organizing-services/', views.FixOrganizingServicesView.as_view()),


]
```

# ==== apps/bookings/views.py ====

```python
# backend/apps/bookings/views.py
from rest_framework import generics, status, permissions
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.shortcuts import get_object_or_404
from django.utils import timezone
from datetime import date, timedelta
from .models import Booking, Address, GuestCheckout
from .serializers import (
    BookingSerializer,
    GuestBookingCreateSerializer,
    BookingStatusSerializer,
    PricingPreviewSerializer,
    AddressSerializer
)
from apps.services.models import (
    MiniMovePackage, 
    StandardDeliveryConfig, 
    SpecialtyItem, 
    OrganizingService,
    SurchargeRule
)
from apps.services.serializers import (
    ServiceCatalogSerializer,
    MiniMovePackageSerializer,
    OrganizingServiceSerializer,
    StandardDeliveryConfigSerializer,
    SpecialtyItemSerializer,
    MiniMoveWithOrganizingSerializer,
    OrganizingServicesByTierSerializer
)
from apps.payments.services import StripePaymentService


class ServiceCatalogView(APIView):
    """Get all available services including organizing services - no authentication required"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request):
        print("=" * 50)
        print("DEBUG: ServiceCatalogView.get() called")
        
        # Debug: Verify the model import
        print(f"DEBUG: OrganizingService model: {OrganizingService}")
        print(f"DEBUG: OrganizingService._meta.app_label: {OrganizingService._meta.app_label}")
        print(f"DEBUG: OrganizingService._meta.db_table: {OrganizingService._meta.db_table}")
        
        # Query organizing services with debug info
        organizing_services = OrganizingService.objects.filter(is_active=True).order_by('mini_move_tier', 'is_packing_service')
        print(f"DEBUG: Raw organizing services query count: {organizing_services.count()}")
        print(f"DEBUG: Organizing services IDs: {list(organizing_services.values_list('id', 'name', 'mini_move_tier', 'is_active'))}")
        
        # Test serialization
        organizing_serializer = OrganizingServiceSerializer(organizing_services, many=True)
        serialized_organizing = organizing_serializer.data
        print(f"DEBUG: Serialized organizing services count: {len(serialized_organizing)}")
        print(f"DEBUG: Serialized organizing services: {serialized_organizing}")
        
        # Query other services (keeping existing code)
        mini_move_packages = MiniMovePackage.objects.filter(is_active=True).order_by('base_price_cents')
        specialty_items = SpecialtyItem.objects.filter(is_active=True)
        standard_config = StandardDeliveryConfig.objects.filter(is_active=True).first()
        
        response_data = {
            'mini_move_packages': MiniMovePackageSerializer(mini_move_packages, many=True).data,
            'organizing_services': serialized_organizing,  # Use the debug-traced version
            'specialty_items': SpecialtyItemSerializer(specialty_items, many=True).data,
            'standard_delivery': StandardDeliveryConfigSerializer(standard_config).data if standard_config else None
        }
        
        print(f"DEBUG: Final response organizing_services count: {len(response_data['organizing_services'])}")
        print("=" * 50)
        
        return Response(response_data)


class ServiceCatalogWithOrganizingView(APIView):
    """Get Mini Move packages with their organizing options - optimized for booking wizard"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request):
        serializer = MiniMoveWithOrganizingSerializer()
        return Response({
            'mini_moves_with_organizing': serializer.to_representation(None)
        })


class OrganizingServicesByTierView(APIView):
    """Get organizing services grouped by Mini Move tier - for easy frontend consumption"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request):
        serializer = OrganizingServicesByTierSerializer()
        return Response(serializer.to_representation(None))


class PricingPreviewView(APIView):
    """Calculate pricing for booking selection including organizing services - no authentication required"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = PricingPreviewSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        service_type = serializer.validated_data['service_type']
        pickup_date = serializer.validated_data['pickup_date']
        
        base_price_cents = 0
        surcharge_cents = 0
        coi_fee_cents = 0
        organizing_total_cents = 0
        organizing_tax_cents = 0
        geographic_surcharge_cents = 0
        time_window_surcharge_cents = 0
        details = {}
        
        if service_type == 'mini_move':
            package_id = serializer.validated_data.get('mini_move_package_id')
            if package_id:
                try:
                    package = MiniMovePackage.objects.get(id=package_id, is_active=True)
                    base_price_cents = package.base_price_cents
                    details['package_name'] = package.name
                    details['package_tier'] = package.package_type
                    
                    coi_required = serializer.validated_data.get('coi_required', False)
                    if coi_required and not package.coi_included:
                        coi_fee_cents = package.coi_fee_cents
                        details['coi_required'] = True
                    
                    include_packing = serializer.validated_data.get('include_packing', False)
                    include_unpacking = serializer.validated_data.get('include_unpacking', False)
                    
                    organizing_services_breakdown = []
                    
                    # FIXED: Better error handling and debugging for organizing services
                    if include_packing:
                        packing_service = OrganizingService.objects.filter(
                            mini_move_tier=package.package_type,
                            is_packing_service=True,
                            is_active=True
                        ).first()
                        
                        if packing_service:
                            organizing_total_cents += packing_service.price_cents
                            organizing_services_breakdown.append({
                                'service': 'packing',
                                'name': packing_service.name,
                                'price_dollars': packing_service.price_dollars,
                                'duration_hours': packing_service.duration_hours,
                                'organizer_count': packing_service.organizer_count,
                                'supplies_allowance_dollars': packing_service.supplies_allowance_dollars
                            })
                        else:
                            print(f"DEBUG: No packing service found for tier {package.package_type}")
                            available_services = OrganizingService.objects.filter(is_active=True).values_list('mini_move_tier', 'is_packing_service')
                            print(f"DEBUG: Available services: {list(available_services)}")
                            return Response({
                                'error': f'Packing service not available for {package.package_type} tier'
                            }, status=status.HTTP_400_BAD_REQUEST)
                    
                    if include_unpacking:
                        unpacking_service = OrganizingService.objects.filter(
                            mini_move_tier=package.package_type,
                            is_packing_service=False,
                            is_active=True
                        ).first()
                        
                        if unpacking_service:
                            organizing_total_cents += unpacking_service.price_cents
                            organizing_services_breakdown.append({
                                'service': 'unpacking',
                                'name': unpacking_service.name,
                                'price_dollars': unpacking_service.price_dollars,
                                'duration_hours': unpacking_service.duration_hours,
                                'organizer_count': unpacking_service.organizer_count,
                                'supplies_allowance_dollars': 0
                            })
                        else:
                            print(f"DEBUG: No unpacking service found for tier {package.package_type}")
                            return Response({
                                'error': f'Unpacking service not available for {package.package_type} tier'
                            }, status=status.HTTP_400_BAD_REQUEST)
                    
                    # Calculate tax on organizing services (8.25%)
                    if organizing_total_cents > 0:
                        organizing_tax_cents = int(organizing_total_cents * 0.0825)
                    
                    # Calculate time window surcharge for specific hour selection
                    pickup_time = serializer.validated_data.get('pickup_time', 'morning')
                    if pickup_time == 'morning_specific' and package.package_type == 'standard':
                        time_window_surcharge_cents = 17500  # $175
                    
                    # Calculate geographic surcharge
                    is_outside_core_area = serializer.validated_data.get('is_outside_core_area', False)
                    if is_outside_core_area:
                        geographic_surcharge_cents = 17500  # $175
                    
                    if organizing_services_breakdown:
                        details['organizing_services'] = organizing_services_breakdown
                    
                except MiniMovePackage.DoesNotExist:
                    return Response({'error': 'Invalid mini move package'}, status=status.HTTP_400_BAD_REQUEST)
        
        elif service_type == 'standard_delivery':
            if serializer.validated_data.get('include_packing') or serializer.validated_data.get('include_unpacking'):
                return Response({
                    'error': 'Organizing services are only available for Mini Move bookings'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            item_count = serializer.validated_data.get('standard_delivery_item_count', 0)
            is_same_day = serializer.validated_data.get('is_same_day_delivery', False)
            
            try:
                config = StandardDeliveryConfig.objects.filter(is_active=True).first()
                if config:
                    # FIXED: Calculate base and same-day separately for proper breakdown
                    item_total = config.price_per_item_cents * item_count
                    base_price_cents = max(item_total, config.minimum_charge_cents)
                    
                    details['item_count'] = item_count
                    details['per_item_rate'] = config.price_per_item_cents / 100
                    details['minimum_charge'] = config.minimum_charge_cents / 100
                    
                    if is_same_day:
                        # Add same-day as a surcharge, not part of base
                        surcharge_cents += config.same_day_flat_rate_cents
                        details['is_same_day'] = True
                        details['same_day_rate'] = config.same_day_flat_rate_cents / 100
                        
            except StandardDeliveryConfig.DoesNotExist:
                return Response({'error': 'Standard delivery not configured'}, status=status.HTTP_400_BAD_REQUEST)
        
        elif service_type == 'specialty_item':
            if serializer.validated_data.get('include_packing') or serializer.validated_data.get('include_unpacking'):
                return Response({
                    'error': 'Organizing services are only available for Mini Move bookings'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            specialty_item_ids = serializer.validated_data.get('specialty_item_ids', [])
            specialty_items = SpecialtyItem.objects.filter(id__in=specialty_item_ids, is_active=True)
            
            specialty_total = sum(item.price_cents for item in specialty_items)
            base_price_cents = specialty_total
            details['specialty_items'] = [
                {'name': item.name, 'price_dollars': item.price_dollars}
                for item in specialty_items
            ]
        
        # Calculate weekend surcharges
        is_same_day = serializer.validated_data.get('is_same_day_delivery', False)
        if pickup_date and base_price_cents > 0 and not is_same_day:
            active_surcharges = SurchargeRule.objects.filter(is_active=True)
            surcharge_details = []
            
            for surcharge in active_surcharges:
                surcharge_amount = surcharge.calculate_surcharge(base_price_cents, pickup_date, service_type)
                if surcharge_amount > 0:
                    surcharge_cents += surcharge_amount
                    surcharge_details.append({
                        'name': surcharge.name,
                        'amount_dollars': surcharge_amount / 100,
                        'reason': surcharge.description
                    })
            
            if surcharge_details:
                details['surcharges'] = surcharge_details
        
        total_price_cents = base_price_cents + surcharge_cents + coi_fee_cents + organizing_total_cents + organizing_tax_cents + geographic_surcharge_cents + time_window_surcharge_cents
        
        return Response({
            'service_type': service_type,
            'pricing': {
                'base_price_dollars': base_price_cents / 100,
                'surcharge_dollars': surcharge_cents / 100,
                'coi_fee_dollars': coi_fee_cents / 100,
                'organizing_total_dollars': organizing_total_cents / 100,
                'organizing_tax_dollars': organizing_tax_cents / 100,
                'geographic_surcharge_dollars': geographic_surcharge_cents / 100,
                'time_window_surcharge_dollars': time_window_surcharge_cents / 100,
                'total_price_dollars': total_price_cents / 100
            },
            'details': details,
            'pickup_date': pickup_date
        })
    
class CalendarAvailabilityView(APIView):
    """Calendar data with booking details - no capacity limits"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request):
        start_date = request.query_params.get('start_date', date.today())
        if isinstance(start_date, str):
            start_date = date.fromisoformat(start_date)
        
        end_date_param = request.query_params.get('end_date')
        if end_date_param:
            end_date = date.fromisoformat(end_date_param)
        else:
            end_date = start_date + timedelta(days=60)
        
        availability = []
        current_date = start_date
        
        while current_date <= end_date:
            # Get bookings for this date
            bookings_today = Booking.objects.filter(
                pickup_date=current_date,
                deleted_at__isnull=True
            ).select_related('customer', 'guest_checkout')
            
            # Get surcharges for this date
            surcharges = []
            for rule in SurchargeRule.objects.filter(is_active=True):
                if rule.applies_to_date(current_date):
                    surcharges.append({
                        'name': rule.name,
                        'type': rule.surcharge_type,
                        'description': rule.description
                    })
            
            # Serialize bookings for this date
            booking_list = []
            for booking in bookings_today:
                booking_list.append({
                    'id': str(booking.id),
                    'booking_number': booking.booking_number,
                    'customer_name': booking.get_customer_name(),
                    'service_type': booking.get_service_type_display(),
                    'pickup_time': booking.get_pickup_time_display(),
                    'status': booking.status,
                    'total_price_dollars': booking.total_price_dollars,
                    'coi_required': booking.coi_required
                })
            
            availability.append({
                'date': current_date.isoformat(),
                'available': True,  # Always available - no capacity limits
                'is_weekend': current_date.weekday() >= 5,
                'bookings': booking_list,
                'surcharges': surcharges
            })
            
            current_date += timedelta(days=1)
        
        return Response({
            'availability': availability,
            'start_date': start_date.isoformat(),
            'end_date': end_date.isoformat()
        })

class GuestBookingCreateView(generics.CreateAPIView):
    """Create booking for guest (non-authenticated) users with payment integration"""
    serializer_class = GuestBookingCreateSerializer
    permission_classes = [permissions.AllowAny]
    
    def create(self, request, *args, **kwargs):
        print("=" * 80)
        print("GUEST BOOKING CREATE REQUEST RECEIVED")
        print("=" * 80)
        print("Guest Email:", request.data.get('email'))
        print("Request Data:", request.data)
        print("Create Payment Intent:", request.data.get('create_payment_intent', True))
        
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        booking = serializer.save()
        
        print(f"Guest booking created: {booking.booking_number}")
        print(f"Total price: ${booking.total_price_dollars}")
        
        # Add payment intent creation for guests
        create_payment_intent = request.data.get('create_payment_intent', True)
        payment_data = None
        
        if create_payment_intent:
            print("Creating payment intent for guest...")
            try:
                # Use guest email from the booking
                guest_email = booking.guest_checkout.email if booking.guest_checkout else None
                
                payment_result = StripePaymentService.create_payment_intent(
                    booking=booking,
                    customer_email=guest_email
                )
                
                payment_data = {
                    'client_secret': payment_result['client_secret'],
                    'payment_intent_id': payment_result['payment_intent_id']
                }
                
                print(f"Payment intent created: {payment_result['payment_intent_id']}")
            except Exception as e:
                print(f"Payment intent failed: {str(e)}")
                # Don't fail the booking creation, but log the error
                payment_data = None
        
        # Return same format as authenticated endpoint
        response_data = {
            'message': 'Booking created successfully',
            'booking': {
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'total_price_dollars': booking.total_price_dollars
            }
        }
        
        # Include payment data if available
        if payment_data:
            response_data['payment'] = payment_data
        
        print("=" * 80)
        print("SUCCESS - Returning guest booking response")
        print("Response includes payment:", bool(payment_data))
        print("=" * 80)
        
        return Response(response_data, status=status.HTTP_201_CREATED)


class BookingStatusView(APIView):
    """Get booking status by booking number - no authentication required"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request, booking_number):
        try:
            booking = Booking.objects.get(booking_number=booking_number, deleted_at__isnull=True)
            serializer = BookingStatusSerializer(booking)
            return Response(serializer.data)
        except Booking.DoesNotExist:
            return Response(
                {'error': 'Booking not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )


class OrganizingServiceDetailView(APIView):
    """Get detailed info about a specific organizing service - no authentication required"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request, service_id):
        try:
            organizing_service = OrganizingService.objects.get(id=service_id, is_active=True)
            serializer = OrganizingServiceSerializer(organizing_service)
            return Response(serializer.data)
        except OrganizingService.DoesNotExist:
            return Response(
                {'error': 'Organizing service not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        
class FixOrganizingServicesView(APIView):
    """TEMPORARY: Create missing organizing services in production"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        from apps.services.models import OrganizingService
        
        organizing_services = [
            {'service_type': 'petite_packing', 'mini_move_tier': 'petite', 'name': 'Petite Packing', 'description': '1/2 day (up to 4 hours) with 2 organizers. Includes garment bags, moving bags + additional packing supplies upon request (up to $250).', 'price_cents': 140000, 'duration_hours': 4, 'organizer_count': 2, 'supplies_allowance_cents': 25000, 'is_packing_service': True, 'is_active': True},
            {'service_type': 'petite_unpacking', 'mini_move_tier': 'petite', 'name': 'Petite Unpacking', 'description': '1/2 day (up to 4 hours) with 2 organizers. Organizing light (no supplies).', 'price_cents': 113000, 'duration_hours': 4, 'organizer_count': 2, 'supplies_allowance_cents': 0, 'is_packing_service': False, 'is_active': True},
            {'service_type': 'standard_packing', 'mini_move_tier': 'standard', 'name': 'Standard Packing', 'description': '1 day (up to 8 hours) with 2 organizers. Includes garment bags, moving bags + additional packing supplies upon request (up to $250).', 'price_cents': 253500, 'duration_hours': 8, 'organizer_count': 2, 'supplies_allowance_cents': 25000, 'is_packing_service': True, 'is_active': True},
            {'service_type': 'standard_unpacking', 'mini_move_tier': 'standard', 'name': 'Standard Unpacking', 'description': '1 day (up to 8 hours) with 2 organizers. Organizing light (no supplies).', 'price_cents': 226500, 'duration_hours': 8, 'organizer_count': 2, 'supplies_allowance_cents': 0, 'is_packing_service': False, 'is_active': True},
            {'service_type': 'full_packing', 'mini_move_tier': 'full', 'name': 'Full Packing', 'description': '1 day (up to 8 hours) with 4 organizers. Includes garment bags, moving bags + additional packing supplies upon request (up to $500).', 'price_cents': 507000, 'duration_hours': 8, 'organizer_count': 4, 'supplies_allowance_cents': 50000, 'is_packing_service': True, 'is_active': True},
            {'service_type': 'full_unpacking', 'mini_move_tier': 'full', 'name': 'Full Unpacking', 'description': '1 day (up to 8 hours) with 4 organizers. Organizing light (no supplies).', 'price_cents': 452500, 'duration_hours': 8, 'organizer_count': 4, 'supplies_allowance_cents': 0, 'is_packing_service': False, 'is_active': True}
        ]
        
        created = 0
        for service_data in organizing_services:
            service, was_created = OrganizingService.objects.get_or_create(
                service_type=service_data['service_type'],
                defaults=service_data
            )
            if was_created:
                created += 1
        
        return Response({
            'message': f'Created {created} organizing services',
            'total_count': OrganizingService.objects.count()
        })
```

# ==== apps/crm/__init__.py ====

```python

```

# ==== apps/crm/admin.py ====

```python
from django.contrib import admin

# Register your models here.
```

# ==== apps/crm/apps.py ====

```python
from django.apps import AppConfig


class CrmConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.crm'
```

# ==== apps/crm/migrations/__init__.py ====

```python

```

# ==== apps/crm/models.py ====

```python
from django.db import models

# Create your models here.
```

# ==== apps/crm/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/crm/views.py ====

```python
from django.shortcuts import render

# Create your views here.
```

# ==== apps/customers/__init__.py ====

```python

```

# ==== apps/customers/admin.py ====

```python
from django.contrib import admin
from django.contrib.auth.models import User
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.core.exceptions import ValidationError
from django.contrib import messages
from .models import CustomerProfile, SavedAddress, CustomerPaymentMethod


class CustomerProfileInline(admin.StackedInline):
    model = CustomerProfile
    can_delete = False
    verbose_name_plural = 'Customer Profile'
    readonly_fields = ('total_bookings', 'total_spent_cents', 'last_booking_at', 'created_at', 'updated_at')
    
    def save_model(self, request, obj, form, change):
        try:
            super().save_model(request, obj, form, change)
        except ValidationError as e:
            messages.error(request, f"Cannot save customer profile: {e}")
            raise


class CustomUserAdmin(BaseUserAdmin):
    inlines = (CustomerProfileInline,)
    
    def get_inline_instances(self, request, obj=None):
        """Only show CustomerProfile inline for users without staff profiles"""
        if obj and hasattr(obj, 'staff_profile'):
            return []
        return super().get_inline_instances(request, obj)


# Re-register UserAdmin
admin.site.unregister(User)
admin.site.register(User, CustomUserAdmin)


@admin.register(CustomerProfile)
class CustomerProfileAdmin(admin.ModelAdmin):
    list_display = ('user', 'user_email', 'total_bookings', 'total_spent_dollars', 'is_vip', 'last_booking_at', 'created_at')
    list_filter = ('is_vip', 'preferred_pickup_time', 'email_notifications', 'created_at')
    search_fields = ('user__email', 'user__first_name', 'user__last_name', 'phone')
    readonly_fields = ('total_bookings', 'total_spent_cents', 'last_booking_at', 'created_at', 'updated_at')
    
    def user_email(self, obj):
        return obj.user.email
    user_email.short_description = 'Email'
    user_email.admin_order_field = 'user__email'
    
    def save_model(self, request, obj, form, change):
        try:
            super().save_model(request, obj, form, change)
        except ValidationError as e:
            messages.error(request, f"Cannot save: {e}")
            raise


@admin.register(SavedAddress)
class SavedAddressAdmin(admin.ModelAdmin):
    list_display = ('user', 'nickname', 'city', 'state', 'times_used', 'is_active', 'created_at')
    list_filter = ('state', 'is_active', 'city', 'created_at')
    search_fields = ('user__email', 'nickname', 'city', 'address_line_1')
    readonly_fields = ('times_used', 'last_used_at', 'created_at', 'updated_at')
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related('user')


@admin.register(CustomerPaymentMethod)
class CustomerPaymentMethodAdmin(admin.ModelAdmin):
    list_display = ('user', 'display_name', 'is_default', 'is_active', 'created_at')
    list_filter = ('card_brand', 'is_default', 'is_active', 'created_at')
    search_fields = ('user__email', 'card_last_four')
    readonly_fields = ('stripe_payment_method_id', 'created_at')
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related('user')
```

# ==== apps/customers/apps.py ====

```python
# apps/customers/apps.py
from django.apps import AppConfig

class CustomersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.customers'  # Change this from 'customers' to 'apps.customers'
```

# ==== apps/customers/authentication.py ====

```python
from rest_framework.authentication import SessionAuthentication
from django.contrib.auth.models import User
from django.contrib.sessions.backends.db import SessionStore
import logging

logger = logging.getLogger(__name__)

class HybridAuthentication(SessionAuthentication):
    """
    Hybrid authentication for mobile compatibility.
    Tries session cookie first (desktop), falls back to X-Session-Id header (mobile).
    """
    
    def authenticate(self, request):
        # Try standard cookie-based session authentication
        user = getattr(request._request, 'user', None)
        
        if user and user.is_authenticated:
            return (user, None)
        
        # Mobile fallback: check for session ID in custom header
        session_key = request.META.get('HTTP_X_SESSION_ID')
        
        if not session_key:
            return None
        
        logger.info(f"Mobile auth attempt with session: {session_key[:10]}...")
        
        try:
            # Validate session exists and get user
            session = SessionStore(session_key=session_key)
            
            if not session.exists(session_key):
                logger.warning(f"Session does not exist: {session_key[:10]}...")
                return None
            
            user_id = session.get('_auth_user_id')
            
            if not user_id:
                logger.warning(f"No user_id in session: {session_key[:10]}...")
                return None
            
            user = User.objects.get(pk=user_id)
            logger.info(f"Mobile auth successful for user: {user.email}")
            return (user, None)
            
        except User.DoesNotExist:
            logger.error(f"User not found for session: {session_key[:10]}...")
            return None
        except Exception as e:
            logger.error(f"Mobile auth error: {str(e)}")
            return None
```

# ==== apps/customers/booking_serializers.py ====

```python
from rest_framework import serializers
from django.contrib.auth.models import User
from apps.bookings.models import Booking, Address
from apps.services.models import MiniMovePackage, SpecialtyItem
from .models import SavedAddress
from .serializers import SavedAddressSerializer


class AuthenticatedBookingCreateSerializer(serializers.Serializer):
    """Enhanced booking creation for authenticated customers"""
    
    # Service selection
    service_type = serializers.ChoiceField(choices=[
        ('mini_move', 'Mini Move'),
        ('standard_delivery', 'Standard Delivery'),
        ('specialty_item', 'Specialty Item')
    ])
    
    # Service-specific fields
    mini_move_package_id = serializers.UUIDField(required=False, allow_null=True)
    include_packing = serializers.BooleanField(default=False)
    include_unpacking = serializers.BooleanField(default=False)
    standard_delivery_item_count = serializers.IntegerField(required=False, min_value=1)
    is_same_day_delivery = serializers.BooleanField(default=False)
    specialty_item_ids = serializers.ListField(
        child=serializers.UUIDField(),
        required=False,
        allow_empty=True
    )
    
    # Booking details
    pickup_date = serializers.DateField()
    pickup_time = serializers.ChoiceField(choices=[
        ('morning', '8 AM - 11 AM'),
        ('morning_specific', 'Specific 1-hour window'),
        ('no_time_preference', 'No time preference'),
    ], required=False)
    specific_pickup_hour = serializers.IntegerField(required=False, allow_null=True)
    
    # Address selection - can use saved addresses or create new ones
    pickup_address_id = serializers.UUIDField(required=False)
    delivery_address_id = serializers.UUIDField(required=False)
    new_pickup_address = serializers.DictField(required=False)
    new_delivery_address = serializers.DictField(required=False)
    
    # Save new addresses for future use
    save_pickup_address = serializers.BooleanField(default=False)
    save_delivery_address = serializers.BooleanField(default=False)
    pickup_address_nickname = serializers.CharField(required=False, max_length=50)
    delivery_address_nickname = serializers.CharField(required=False, max_length=50)
    
    # Additional options
    special_instructions = serializers.CharField(required=False, allow_blank=True)
    coi_required = serializers.BooleanField(default=False)
    create_payment_intent = serializers.BooleanField(default=True)
    
    def validate(self, attrs):
        user = self.context['user']
        service_type = attrs['service_type']
        
        # Validate service-specific requirements
        if service_type == 'mini_move':
            if not attrs.get('mini_move_package_id'):
                raise serializers.ValidationError("mini_move_package_id is required for mini move service")
        
        elif service_type == 'standard_delivery':
            if not attrs.get('standard_delivery_item_count'):
                raise serializers.ValidationError("standard_delivery_item_count is required for standard delivery")
        
        elif service_type == 'specialty_item':
            if not attrs.get('specialty_item_ids'):
                raise serializers.ValidationError("specialty_item_ids is required for specialty item service")
        
        # Validate address selection
        if not (attrs.get('pickup_address_id') or attrs.get('new_pickup_address')):
            raise serializers.ValidationError("Either pickup_address_id or new_pickup_address is required")
        
        if not (attrs.get('delivery_address_id') or attrs.get('new_delivery_address')):
            raise serializers.ValidationError("Either delivery_address_id or new_delivery_address is required")
        
        # Validate saved addresses belong to user
        if attrs.get('pickup_address_id'):
            if not user.saved_addresses.filter(id=attrs['pickup_address_id'], is_active=True).exists():
                raise serializers.ValidationError("Invalid pickup address")
        
        if attrs.get('delivery_address_id'):
            if not user.saved_addresses.filter(id=attrs['delivery_address_id'], is_active=True).exists():
                raise serializers.ValidationError("Invalid delivery address")
        
        # Use customer's preferred pickup time if not specified
        if not attrs.get('pickup_time'):
            attrs['pickup_time'] = user.customer_profile.preferred_pickup_time
        
        return attrs
    
    def create(self, validated_data):
        user = self.context['user']
        
        # Handle pickup address
        pickup_address = self._get_or_create_address(
            user,
            validated_data.get('pickup_address_id'),
            validated_data.get('new_pickup_address'),
            validated_data.get('save_pickup_address', False),
            validated_data.get('pickup_address_nickname')
        )
        
        # Handle delivery address
        delivery_address = self._get_or_create_address(
            user,
            validated_data.get('delivery_address_id'),
            validated_data.get('new_delivery_address'),
            validated_data.get('save_delivery_address', False),
            validated_data.get('delivery_address_nickname')
        )
        
        # Create booking
        booking = Booking.objects.create(
            customer=user,
            service_type=validated_data['service_type'],
            pickup_date=validated_data['pickup_date'],
            pickup_time=validated_data['pickup_time'],
            specific_pickup_hour=validated_data.get('specific_pickup_hour'),
            pickup_address=pickup_address,
            delivery_address=delivery_address,
            special_instructions=validated_data.get('special_instructions', ''),
            coi_required=validated_data.get('coi_required', False),
            include_packing=validated_data.get('include_packing', False),
            include_unpacking=validated_data.get('include_unpacking', False),
            standard_delivery_item_count=validated_data.get('standard_delivery_item_count'),
            is_same_day_delivery=validated_data.get('is_same_day_delivery', False)
        )
        
        # Handle service-specific relationships
        if validated_data['service_type'] == 'mini_move':
            try:
                package = MiniMovePackage.objects.get(id=validated_data['mini_move_package_id'])
                booking.mini_move_package = package
            except MiniMovePackage.DoesNotExist:
                raise serializers.ValidationError("Invalid mini move package")
        
        elif validated_data['service_type'] == 'specialty_item':
            specialty_items = SpecialtyItem.objects.filter(
                id__in=validated_data.get('specialty_item_ids', [])
            )
            booking.save()  # Save first to get ID for M2M relationship
            booking.specialty_items.set(specialty_items)
        
        booking.save()  # Trigger pricing calculation
        return booking
    
    def _get_or_create_address(self, user, address_id, new_address_data, save_address, nickname):
        """Get existing saved address or create new one"""
        if address_id:
            # Use existing saved address
            saved_address = user.saved_addresses.get(id=address_id, is_active=True)
            
            # Create Address record for booking
            address = Address.objects.create(
                customer=user,
                address_line_1=saved_address.address_line_1,
                address_line_2=saved_address.address_line_2,
                city=saved_address.city,
                state=saved_address.state,
                zip_code=saved_address.zip_code
            )
            
            # Update usage tracking
            saved_address.mark_used()
            return address
        
        elif new_address_data:
            # Create new Address
            address = Address.objects.create(
                customer=user,
                **new_address_data
            )
            
            # Save as SavedAddress if requested
            if save_address:
                SavedAddress.objects.create(
                    user=user,
                    nickname=nickname or f"Address {user.saved_addresses.count() + 1}",
                    address_line_1=new_address_data['address_line_1'],
                    address_line_2=new_address_data.get('address_line_2', ''),
                    city=new_address_data['city'],
                    state=new_address_data['state'],
                    zip_code=new_address_data['zip_code'],
                    delivery_instructions=new_address_data.get('delivery_instructions', ''),
                    times_used=1
                )
            
            return address


class CustomerBookingDetailSerializer(serializers.ModelSerializer):
    """Detailed booking information for authenticated customers"""
    
    customer_name = serializers.SerializerMethodField()
    pickup_address = serializers.SerializerMethodField()
    delivery_address = serializers.SerializerMethodField()
    total_price_dollars = serializers.ReadOnlyField()
    pricing_breakdown = serializers.SerializerMethodField()
    payment_status = serializers.SerializerMethodField()
    can_rebook = serializers.SerializerMethodField()
    
    class Meta:
        model = Booking
        fields = (
            'id', 'booking_number', 'customer_name', 
            'service_type', 'pickup_date', 'pickup_time', 'status',
            'pickup_address', 'delivery_address',
            'special_instructions', 'coi_required',
            'total_price_dollars', 'pricing_breakdown',
            'payment_status', 'can_rebook', 'created_at', 'updated_at'
        )
    
    def get_customer_name(self, obj):
        return obj.get_customer_name()
    
    def get_pickup_address(self, obj):
        return {
            'address_line_1': obj.pickup_address.address_line_1,
            'address_line_2': obj.pickup_address.address_line_2,
            'city': obj.pickup_address.city,
            'state': obj.pickup_address.state,
            'zip_code': obj.pickup_address.zip_code
        }
    
    def get_delivery_address(self, obj):
        return {
            'address_line_1': obj.delivery_address.address_line_1,
            'address_line_2': obj.delivery_address.address_line_2,
            'city': obj.delivery_address.city,
            'state': obj.delivery_address.state,
            'zip_code': obj.delivery_address.zip_code
        }
    
    def get_pricing_breakdown(self, obj):
        return obj.get_pricing_breakdown()
    
    def get_payment_status(self, obj):
        payment = obj.payments.first()
        return payment.status if payment else 'not_created'
    
    def get_can_rebook(self, obj):
        return obj.status in ['completed', 'paid']


class QuickBookingSerializer(serializers.Serializer):
    """Serializer for quickly rebooking with minimal changes"""
    pickup_date = serializers.DateField()
    pickup_time = serializers.ChoiceField(
        choices=[
            ('morning', '8 AM - 11 AM'),
            ('morning_specific', 'Specific 1-hour window'),
            ('no_time_preference', 'No time preference'),
        ],
        required=False
    )
    is_same_day_delivery = serializers.BooleanField(default=False)
    special_instructions = serializers.CharField(required=False, allow_blank=True)
    coi_required = serializers.BooleanField(required=False)
```

# ==== apps/customers/booking_views.py ====

```python
# backend/apps/customers/booking_views.py
from rest_framework import generics, status, permissions
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.shortcuts import get_object_or_404
from .models import CustomerProfile, SavedAddress, CustomerPaymentMethod
from apps.bookings.models import Booking, Address
from apps.payments.services import StripePaymentService
from .serializers import SavedAddressSerializer
from .booking_serializers import (
    AuthenticatedBookingCreateSerializer,
    CustomerBookingDetailSerializer,
    QuickBookingSerializer
)
import json


class CustomerBookingCreateView(APIView):
    """Create booking for authenticated customers with enhanced features"""
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        # CRITICAL DEBUG LOGGING
        print("=" * 80)
        print("🔍 BOOKING CREATE REQUEST RECEIVED")
        print("=" * 80)
        print(f"👤 User: {request.user}")
        print(f"📧 Email: {request.user.email}")
        print(f"🔐 Is Authenticated: {request.user.is_authenticated}")
        print(f"📦 Request Data: {json.dumps(request.data, indent=2, default=str)}")
        print("=" * 80)
        
        # Ensure user has customer profile
        if not hasattr(request.user, 'customer_profile'):
            print("❌ ERROR: User has no customer profile")
            return Response(
                {'error': 'This is not a customer account'}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        print(f"✅ Customer Profile Found: {request.user.customer_profile}")
        
        serializer = AuthenticatedBookingCreateSerializer(
            data=request.data,
            context={'user': request.user}
        )
        
        print("🔄 Validating serializer...")
        
        if not serializer.is_valid():
            print("=" * 80)
            print("❌ SERIALIZER VALIDATION FAILED")
            print("=" * 80)
            print(f"Errors: {json.dumps(serializer.errors, indent=2, default=str)}")
            print("=" * 80)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        print("✅ Serializer valid, creating booking...")
        
        try:
            booking = serializer.save()
            print(f"✅ Booking created: {booking.booking_number}")
        except Exception as e:
            print(f"❌ ERROR creating booking: {str(e)}")
            import traceback
            traceback.print_exc()
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
        # Create payment intent for this booking
        create_payment_intent = request.data.get('create_payment_intent', True)
        payment_data = None
        
        if create_payment_intent:
            print("💳 Creating payment intent...")
            try:
                payment_data = StripePaymentService.create_payment_intent(
                    booking=booking,
                    customer_email=request.user.email
                )
                print(f"✅ Payment intent created: {payment_data.get('payment_intent_id')}")
            except Exception as e:
                print(f"⚠️ Payment intent failed: {str(e)}")
                payment_data = {'error': str(e)}
        
        response_data = {
            'message': 'Booking created successfully',
            'booking': CustomerBookingDetailSerializer(booking).data
        }
        
        if payment_data and 'error' not in payment_data:
            response_data['payment'] = {
                'client_secret': payment_data['client_secret'],
                'payment_intent_id': payment_data['payment_intent_id']
            }
        
        print("=" * 80)
        print("✅ SUCCESS - Returning response")
        print("=" * 80)
        
        return Response(response_data, status=status.HTTP_201_CREATED)


class QuickRebookView(APIView):
    """Quickly rebook a previous booking with minimal changes"""
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request, booking_id):
        try:
            original_booking = Booking.objects.get(
                id=booking_id,
                customer=request.user,
                deleted_at__isnull=True
            )
        except Booking.DoesNotExist:
            return Response(
                {'error': 'Original booking not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        
        serializer = QuickBookingSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        new_booking = Booking.objects.create(
            customer=request.user,
            service_type=original_booking.service_type,
            mini_move_package=original_booking.mini_move_package,
            standard_delivery_item_count=original_booking.standard_delivery_item_count,
            is_same_day_delivery=serializer.validated_data.get('is_same_day_delivery', False),
            pickup_date=serializer.validated_data['pickup_date'],
            pickup_time=serializer.validated_data.get('pickup_time', original_booking.pickup_time),
            pickup_address=original_booking.pickup_address,
            delivery_address=original_booking.delivery_address,
            special_instructions=serializer.validated_data.get('special_instructions', original_booking.special_instructions),
            coi_required=serializer.validated_data.get('coi_required', original_booking.coi_required),
            status='pending'
        )
        
        if original_booking.specialty_items.exists():
            new_booking.specialty_items.set(original_booking.specialty_items.all())
        
        new_booking.save()
        
        payment_data = StripePaymentService.create_payment_intent(
            booking=new_booking,
            customer_email=request.user.email
        )
        
        return Response({
            'message': 'Booking recreated successfully',
            'booking': CustomerBookingDetailSerializer(new_booking).data,
            'payment': {
                'client_secret': payment_data['client_secret'],
                'payment_intent_id': payment_data['payment_intent_id']
            }
        }, status=status.HTTP_201_CREATED)


class CustomerBookingDetailView(generics.RetrieveAPIView):
    """Get detailed booking information for authenticated customer"""
    serializer_class = CustomerBookingDetailSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return self.request.user.bookings.filter(deleted_at__isnull=True)
    
    def get_object(self):
        booking_id = self.kwargs.get('booking_id')
        return get_object_or_404(self.get_queryset(), id=booking_id)


class CustomerDashboardView(APIView):
    """Enhanced customer dashboard with booking insights"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        if not hasattr(request.user, 'customer_profile'):
            return Response(
                {'error': 'This is not a customer account'}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        customer_profile = request.user.customer_profile
        
        all_bookings = request.user.bookings.filter(deleted_at__isnull=True).order_by('-created_at')
        recent_bookings = all_bookings[:5]
        
        pending_bookings = all_bookings.filter(status__in=['pending', 'confirmed']).count()
        completed_bookings = all_bookings.filter(status='completed').count()
        
        saved_addresses = request.user.saved_addresses.filter(is_active=True)
        payment_methods = request.user.payment_methods.filter(is_active=True)
        
        popular_addresses = saved_addresses.order_by('-times_used')[:3]
        
        return Response({
            'customer_profile': {
                'name': request.user.get_full_name(),
                'email': request.user.email,
                'phone': customer_profile.phone,
                'is_vip': customer_profile.is_vip,
                'total_bookings': customer_profile.total_bookings,
                'total_spent_dollars': customer_profile.total_spent_dollars,
                'last_booking_at': customer_profile.last_booking_at
            },
            'booking_summary': {
                'pending_bookings': pending_bookings,
                'completed_bookings': completed_bookings,
                'total_bookings': all_bookings.count()
            },
            'recent_bookings': CustomerBookingDetailSerializer(recent_bookings, many=True).data,
            'saved_addresses_count': saved_addresses.count(),
            'payment_methods_count': payment_methods.count(),
            'popular_addresses': SavedAddressSerializer(popular_addresses, many=True).data
        })


class BookingPreferencesView(APIView):
    """Manage customer booking preferences"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        customer_profile = request.user.customer_profile
        
        return Response({
            'preferred_pickup_time': customer_profile.preferred_pickup_time,
            'email_notifications': customer_profile.email_notifications,
            'sms_notifications': customer_profile.sms_notifications,
            'default_addresses': {
                'most_used_pickup': self._get_most_used_address('pickup'),
                'most_used_delivery': self._get_most_used_address('delivery')
            }
        })
    
    def _get_most_used_address(self, address_type):
        most_used = self.request.user.saved_addresses.filter(is_active=True).order_by('-times_used').first()
        return SavedAddressSerializer(most_used).data if most_used else None
```

# ==== apps/customers/management/__init__.py ====

```python

```

# ==== apps/customers/management/commands/__init__.py ====

```python

```

# ==== apps/customers/management/commands/clean_delete_user.py ====

```python
from django.core.management.base import BaseCommand
from django.contrib.auth.models import User
from apps.bookings.models import Booking, GuestCheckout
from apps.payments.models import Payment
from django.db import transaction


class Command(BaseCommand):
    help = 'Completely delete a user and all associated data for clean testing'
    
    def add_arguments(self, parser):
        parser.add_argument('email', type=str, help='Email of user to delete')
        parser.add_argument(
            '--dry-run', 
            action='store_true',
            help='Show what would be deleted without actually deleting'
        )
    
    def handle(self, *args, **options):
        email = options['email']
        dry_run = options['dry_run']
        
        if dry_run:
            self.stdout.write(self.style.WARNING(f"DRY RUN - No data will actually be deleted"))
        
        self.stdout.write(f"🔍 Searching for user: {email}")
        
        # Track what we'll delete
        deletion_summary = {
            'users': 0,
            'bookings': 0,
            'payments': 0,
            'guest_checkouts': 0,
            'saved_addresses': 0,
            'payment_methods': 0
        }
        
        with transaction.atomic():
            # Find authenticated user
            try:
                user = User.objects.get(email__iexact=email)
                self.stdout.write(f"✅ Found user: {user.get_full_name()} (ID: {user.id})")
                
                # Check profile type
                if hasattr(user, 'customer_profile'):
                    self.stdout.write("   👤 Customer Profile")
                    deletion_summary['saved_addresses'] = user.saved_addresses.count()
                    deletion_summary['payment_methods'] = user.payment_methods.count()
                
                if hasattr(user, 'staff_profile'):
                    self.stdout.write("   👮 Staff Profile")
                
                # Count bookings
                user_bookings = user.bookings.all()
                deletion_summary['bookings'] = user_bookings.count()
                
                # Count payments
                booking_ids = [str(b.id) for b in user_bookings]
                user_payments = Payment.objects.filter(booking_id__in=booking_ids)
                deletion_summary['payments'] = user_payments.count()
                
                if not dry_run:
                    # Delete user (cascades to profile, bookings, addresses, etc.)
                    user.delete()
                    deletion_summary['users'] = 1
                    self.stdout.write(self.style.SUCCESS(f"✅ Deleted authenticated user and cascaded data"))
                else:
                    self.stdout.write(f"   Would delete user and {deletion_summary['bookings']} bookings")
            
            except User.DoesNotExist:
                self.stdout.write("❌ No authenticated user found with that email")
            
            # Find guest checkout records
            guest_checkouts = GuestCheckout.objects.filter(email__iexact=email)
            deletion_summary['guest_checkouts'] = guest_checkouts.count()
            
            if guest_checkouts.exists():
                self.stdout.write(f"✅ Found {guest_checkouts.count()} guest checkout records")
                
                if not dry_run:
                    # Delete associated bookings first, then guest records
                    for guest in guest_checkouts:
                        if hasattr(guest, 'booking') and guest.booking:
                            guest.booking.delete()
                    guest_checkouts.delete()
                    self.stdout.write(self.style.SUCCESS("✅ Deleted guest checkout records"))
                else:
                    self.stdout.write(f"   Would delete {guest_checkouts.count()} guest records")
            
            # Raise exception to rollback if dry run
            if dry_run:
                self.stdout.write(self.style.WARNING("DRY RUN - Rolling back transaction"))
                raise transaction.TransactionManagementError("Dry run - rollback")
        
        # Print summary
        self.stdout.write("\n" + "="*50)
        if dry_run:
            self.stdout.write(self.style.WARNING("📋 WOULD DELETE:"))
        else:
            self.stdout.write(self.style.SUCCESS("📋 DELETED:"))
        
        self.stdout.write(f"   👤 Users: {deletion_summary['users']}")
        self.stdout.write(f"   📦 Bookings: {deletion_summary['bookings']}")  
        self.stdout.write(f"   💳 Payments: {deletion_summary['payments']}")
        self.stdout.write(f"   👻 Guest Checkouts: {deletion_summary['guest_checkouts']}")
        self.stdout.write(f"   📍 Saved Addresses: {deletion_summary['saved_addresses']}")
        self.stdout.write(f"   💰 Payment Methods: {deletion_summary['payment_methods']}")
        
        if not dry_run:
            self.stdout.write(self.style.SUCCESS(f"\n🧹 Email {email} completely cleaned from system"))
        else:
            self.stdout.write(self.style.WARNING(f"\n🔍 Run without --dry-run to actually delete"))
```

# ==== apps/customers/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.5 on 2025-09-02 20:54

import django.core.validators
import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='CustomerPaymentMethod',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('stripe_payment_method_id', models.CharField(max_length=100, unique=True)),
                ('card_brand', models.CharField(max_length=20)),
                ('card_last_four', models.CharField(max_length=4)),
                ('card_exp_month', models.PositiveSmallIntegerField()),
                ('card_exp_year', models.PositiveSmallIntegerField()),
                ('is_default', models.BooleanField(default=False)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='payment_methods', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'customers_payment_method',
            },
        ),
        migrations.CreateModel(
            name='CustomerProfile',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('phone', models.CharField(blank=True, max_length=20, validators=[django.core.validators.RegexValidator(regex='^\\+?1?\\d{9,15}$')])),
                ('stripe_customer_id', models.CharField(blank=True, max_length=100)),
                ('total_bookings', models.PositiveIntegerField(default=0)),
                ('total_spent_cents', models.PositiveBigIntegerField(default=0)),
                ('last_booking_at', models.DateTimeField(blank=True, null=True)),
                ('preferred_pickup_time', models.CharField(choices=[('morning', '8 AM - 11 AM'), ('afternoon', '12 PM - 3 PM'), ('evening', '4 PM - 7 PM')], default='morning', max_length=20)),
                ('email_notifications', models.BooleanField(default=True)),
                ('sms_notifications', models.BooleanField(default=False)),
                ('is_vip', models.BooleanField(default=False)),
                ('notes', models.TextField(blank=True, help_text='Internal notes for staff')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='customer_profile', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'customers_profile',
            },
        ),
        migrations.CreateModel(
            name='SavedAddress',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('nickname', models.CharField(max_length=50)),
                ('address_line_1', models.CharField(max_length=200)),
                ('address_line_2', models.CharField(blank=True, max_length=200)),
                ('city', models.CharField(max_length=100)),
                ('state', models.CharField(choices=[('NY', 'New York'), ('CT', 'Connecticut'), ('NJ', 'New Jersey')], max_length=2)),
                ('zip_code', models.CharField(max_length=10)),
                ('delivery_instructions', models.TextField(blank=True)),
                ('times_used', models.PositiveIntegerField(default=0)),
                ('last_used_at', models.DateTimeField(blank=True, null=True)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='saved_addresses', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'customers_saved_address',
                'constraints': [models.UniqueConstraint(fields=('user', 'nickname'), name='unique_customer_address_nickname')],
            },
        ),
    ]
```

# ==== apps/customers/migrations/0002_alter_customerprofile_preferred_pickup_time.py ====

```python
# Generated by Django 5.2.5 on 2025-09-19 23:12

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('customers', '0001_initial'),
    ]

    operations = [
        migrations.AlterField(
            model_name='customerprofile',
            name='preferred_pickup_time',
            field=models.CharField(choices=[('morning', '8 AM - 11 AM'), ('morning_specific', 'Specific 1-hour window'), ('no_time_preference', 'No time preference')], default='morning', max_length=30),
        ),
    ]
```

# ==== apps/customers/migrations/__init__.py ====

```python

```

# ==== apps/customers/models.py ====

```python
import uuid
from django.contrib.auth.models import User
from django.db import models
from django.core.validators import RegexValidator
from django.core.exceptions import ValidationError
from django.utils import timezone


class CustomerProfile(models.Model):
    """Customer profile linked to Django's User model"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='customer_profile')
    
    # Customer-specific fields
    phone = models.CharField(
        max_length=20, 
        validators=[RegexValidator(regex=r'^\+?1?\d{9,15}$')],
        blank=True
    )
    stripe_customer_id = models.CharField(max_length=100, blank=True)
    
    # Booking statistics
    total_bookings = models.PositiveIntegerField(default=0)
    total_spent_cents = models.PositiveBigIntegerField(default=0)
    last_booking_at = models.DateTimeField(null=True, blank=True)
    
    # Customer preferences - UPDATED: Only morning pickup time
    preferred_pickup_time = models.CharField(
        max_length=30,
        choices=[
            ('morning', '8 AM - 11 AM'),
            ('morning_specific', 'Specific 1-hour window'),
            ('no_time_preference', 'No time preference'),
        ],
        default='morning'
    )
    
    email_notifications = models.BooleanField(default=True)
    sms_notifications = models.BooleanField(default=False)
    is_vip = models.BooleanField(default=False)
    notes = models.TextField(blank=True, help_text="Internal notes for staff")
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'customers_profile'
    
    def clean(self):
        """Prevent hybrid accounts - users cannot have both staff and customer profiles"""
        if self.user and hasattr(self.user, 'staff_profile'):
            raise ValidationError(
                f"User {self.user.email} already has a staff profile. "
                "Users cannot have both staff and customer profiles."
            )
    
    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)
    
    def __str__(self):
        return f"Profile: {self.user.get_full_name()}"
    
    @property
    def total_spent_dollars(self):
        return self.total_spent_cents / 100
    
    def add_booking_stats(self, booking_total_cents):
        """Update customer statistics after booking completion"""
        self.total_bookings += 1
        self.total_spent_cents += booking_total_cents
        self.last_booking_at = timezone.now()
        self.save()

    @classmethod
    def ensure_single_profile_type(cls, user):
        """Ensure user only has one type of profile"""
        if hasattr(user, 'staff_profile') and hasattr(user, 'customer_profile'):
            raise ValidationError(
                f"User {user.email} cannot have both staff and customer profiles. "
                "Please remove one profile type."
            )


class SavedAddress(models.Model):
    """Customer's saved addresses"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='saved_addresses')
    
    nickname = models.CharField(max_length=50)
    address_line_1 = models.CharField(max_length=200)
    address_line_2 = models.CharField(max_length=200, blank=True)
    city = models.CharField(max_length=100)
    state = models.CharField(max_length=2, choices=[
        ('NY', 'New York'),
        ('CT', 'Connecticut'), 
        ('NJ', 'New Jersey'),
    ])
    zip_code = models.CharField(max_length=10)
    delivery_instructions = models.TextField(blank=True)
    
    times_used = models.PositiveIntegerField(default=0)
    last_used_at = models.DateTimeField(null=True, blank=True)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'customers_saved_address'
        constraints = [
            models.UniqueConstraint(
                fields=['user', 'nickname'], 
                name='unique_customer_address_nickname'
            )
        ]
    
    def __str__(self):
        return f"{self.user.get_full_name()} - {self.nickname}"
    
    @property
    def formatted_address(self):
        parts = [
            self.address_line_1,
            self.address_line_2,
            f"{self.city}, {self.state} {self.zip_code}"
        ]
        return ', '.join(filter(None, parts))
    
    def mark_used(self):
        self.times_used += 1
        self.last_used_at = timezone.now()
        self.save()


class CustomerPaymentMethod(models.Model):
    """Customer's saved payment methods"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='payment_methods')
    
    stripe_payment_method_id = models.CharField(max_length=100, unique=True)
    card_brand = models.CharField(max_length=20)
    card_last_four = models.CharField(max_length=4)
    card_exp_month = models.PositiveSmallIntegerField()
    card_exp_year = models.PositiveSmallIntegerField()
    is_default = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'customers_payment_method'
    
    def __str__(self):
        return f"{self.user.get_full_name()} - {self.card_brand} ****{self.card_last_four}"
    
    @property
    def display_name(self):
        return f"{self.card_brand.title()} ending in {self.card_last_four}"
    
    def save(self, *args, **kwargs):
        if self.is_default:
            CustomerPaymentMethod.objects.filter(
                user=self.user, 
                is_default=True
            ).exclude(id=self.id).update(is_default=False)
        super().save(*args, **kwargs)
```

# ==== apps/customers/serializers.py ====

```python
from rest_framework import serializers
from django.contrib.auth.models import User
from django.contrib.auth import authenticate
from django.core.exceptions import ValidationError
from .models import CustomerProfile, SavedAddress, CustomerPaymentMethod


class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ('id', 'username', 'email', 'first_name', 'last_name', 'date_joined')
        read_only_fields = ('id', 'username', 'date_joined')


class CustomerProfileSerializer(serializers.ModelSerializer):
    user = UserSerializer(read_only=True)
    total_spent_dollars = serializers.ReadOnlyField()
    
    class Meta:
        model = CustomerProfile
        fields = (
            'id', 'user', 'phone', 'total_bookings', 'total_spent_cents', 
            'total_spent_dollars', 'last_booking_at', 'preferred_pickup_time',
            'email_notifications', 'sms_notifications', 'is_vip'
        )
        read_only_fields = ('id', 'total_bookings', 'total_spent_cents', 'last_booking_at', 'is_vip')


class CustomerRegistrationSerializer(serializers.Serializer):
    email = serializers.EmailField()
    password = serializers.CharField(min_length=8, write_only=True)
    password_confirm = serializers.CharField(write_only=True)
    first_name = serializers.CharField(max_length=150)
    last_name = serializers.CharField(max_length=150)
    phone = serializers.CharField(max_length=20, required=False, allow_blank=True)
    
    def validate(self, attrs):
        if attrs['password'] != attrs['password_confirm']:
            raise serializers.ValidationError("Passwords don't match")
        
        # Check if email already exists
        if User.objects.filter(email__iexact=attrs['email']).exists():
            existing_user = User.objects.get(email__iexact=attrs['email'])
            if hasattr(existing_user, 'staff_profile'):
                raise serializers.ValidationError("This email is already registered as a staff account. Please use a different email.")
            else:
                raise serializers.ValidationError("User with this email already exists")
        
        return attrs
    
    def create(self, validated_data):
        # Remove password_confirm from validated_data
        validated_data.pop('password_confirm')
        phone = validated_data.pop('phone', '')
        
        try:
            # Create User (use email as username for customers)
            user = User.objects.create_user(
                username=validated_data['email'],
                email=validated_data['email'],
                password=validated_data['password'],
                first_name=validated_data['first_name'],
                last_name=validated_data['last_name']
            )
            
            # Create CustomerProfile with validation
            CustomerProfile.objects.create(
                user=user,
                phone=phone
            )
            
            return user
            
        except ValidationError as e:
            # Clean up user if profile creation fails
            if 'user' in locals():
                user.delete()
            raise serializers.ValidationError(str(e))


class CustomerLoginSerializer(serializers.Serializer):
    email = serializers.EmailField()
    password = serializers.CharField(write_only=True)
    
    def validate(self, attrs):
        email = attrs.get('email')
        password = attrs.get('password')
        
        if email and password:
            # Authenticate using email (stored as username for customers)
            user = authenticate(username=email, password=password)
            
            if user:
                if not user.is_active:
                    raise serializers.ValidationError("User account is disabled")
                
                # Ensure user has a customer profile (not staff)
                if not hasattr(user, 'customer_profile'):
                    if hasattr(user, 'staff_profile'):
                        raise serializers.ValidationError("This is a staff account. Please use the staff login.")
                    else:
                        raise serializers.ValidationError("This is not a customer account")
                
                # Additional hybrid account check
                try:
                    CustomerProfile.ensure_single_profile_type(user)
                except ValidationError as e:
                    raise serializers.ValidationError(str(e))
                
                attrs['user'] = user
                return attrs
            else:
                raise serializers.ValidationError("Invalid email or password")
        else:
            raise serializers.ValidationError("Must include email and password")


class SavedAddressSerializer(serializers.ModelSerializer):
    formatted_address = serializers.ReadOnlyField()
    
    class Meta:
        model = SavedAddress
        fields = (
            'id', 'nickname', 'address_line_1', 'address_line_2', 
            'city', 'state', 'zip_code', 'delivery_instructions',
            'formatted_address', 'times_used', 'last_used_at', 'is_active'
        )
        read_only_fields = ('id', 'times_used', 'last_used_at')


class CustomerPaymentMethodSerializer(serializers.ModelSerializer):
    display_name = serializers.ReadOnlyField()
    
    class Meta:
        model = CustomerPaymentMethod
        fields = (
            'id', 'stripe_payment_method_id', 'card_brand', 'card_last_four',
            'card_exp_month', 'card_exp_year', 'display_name', 'is_default', 'is_active'
        )
        read_only_fields = ('id', 'stripe_payment_method_id')
```

# ==== apps/customers/tests.py ====

```python

```

# ==== apps/customers/urls.py ====

```python
# backend/apps/customers/urls.py
from django.urls import path
from . import views, booking_views

# API patterns with both authentication and booking functionality
urlpatterns = [
    # CSRF token endpoint
    path('csrf-token/', views.CSRFTokenView.as_view(), name='csrf-token'),
    
    # DEBUG endpoint
    
    # Authentication endpoints
    path('auth/register/', views.CustomerRegistrationView.as_view(), name='customer-register'),
    path('auth/login/', views.CustomerLoginView.as_view(), name='customer-login'),
    path('auth/logout/', views.CustomerLogoutView.as_view(), name='customer-logout'),
    path('auth/user/', views.CurrentUserView.as_view(), name='current-user'),
    
    # Profile management
    path('profile/', views.CustomerProfileView.as_view(), name='customer-profile'),
    path('addresses/', views.SavedAddressListCreateView.as_view(), name='saved-addresses'),
    path('addresses/<uuid:pk>/', views.SavedAddressDetailView.as_view(), name='saved-address-detail'),
    
    # Enhanced customer dashboard and preferences
    path('dashboard/', views.CustomerDashboardView.as_view(), name='customer-dashboard'),
    path('preferences/', views.BookingPreferencesView.as_view(), name='booking-preferences'),
    
    # Authenticated booking management
    path('bookings/', views.CustomerBookingListView.as_view(), name='customer-bookings'),
    path('bookings/create/', booking_views.CustomerBookingCreateView.as_view(), name='customer-booking-create'),
    path('bookings/<uuid:booking_id>/', booking_views.CustomerBookingDetailView.as_view(), name='customer-booking-detail'),
    path('bookings/<uuid:booking_id>/rebook/', booking_views.QuickRebookView.as_view(), name='quick-rebook'),
    
    # Staff-only customer notes management
    path('<int:customer_id>/notes/', views.CustomerNotesUpdateView.as_view(), name='customer-notes-update'),
]
```

# ==== apps/customers/views.py ====

```python
# backend/apps/customers/views.py
from rest_framework import generics, status, permissions
from django.conf import settings
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.contrib.auth import login, logout
from django.contrib.auth.models import User
from django.middleware.csrf import get_token
from django.views.decorators.csrf import ensure_csrf_cookie, csrf_exempt
from django.utils.decorators import method_decorator
from django.core.exceptions import ValidationError
from django_ratelimit.decorators import ratelimit
from .models import CustomerProfile, SavedAddress
from .serializers import (
    CustomerRegistrationSerializer, 
    CustomerLoginSerializer,
    CustomerProfileSerializer,
    UserSerializer,
    SavedAddressSerializer
)


@method_decorator(ratelimit(key='ip', rate='5/m', method='POST', block=True), name='create')
@method_decorator(ratelimit(key='header:user-agent', rate='10/m', method='POST', block=True), name='create')
@method_decorator(ensure_csrf_cookie, name='dispatch')
class CustomerRegistrationView(generics.CreateAPIView):
    """Register new customer account with hybrid account prevention and rate limiting"""
    serializer_class = CustomerRegistrationSerializer
    permission_classes = [permissions.AllowAny]
    
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        # Check if user already exists with staff profile
        email = serializer.validated_data['email']
        try:
            existing_user = User.objects.get(email__iexact=email)
            if hasattr(existing_user, 'staff_profile'):
                return Response(
                    {'error': 'This email is already registered as a staff account. Please use a different email or contact support.'},
                    status=status.HTTP_400_BAD_REQUEST
                )
        except User.DoesNotExist:
            pass  # This is what we want - new email
        
        try:
            user = serializer.save()
            # Automatically log in the user after registration
            login(request, user)
        except ValidationError as e:
            return Response(
                {'error': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        return Response({
            'message': 'Account created successfully',
            'user': UserSerializer(user).data,
            'customer_profile': CustomerProfileSerializer(user.customer_profile).data,
            'csrf_token': get_token(request)
        }, status=status.HTTP_201_CREATED)

@method_decorator(ratelimit(key='ip', rate='10/m', method='POST', block=True), name='post')
@method_decorator(ratelimit(key='header:user-agent', rate='15/m', method='POST', block=True), name='post')
@method_decorator(ensure_csrf_cookie, name='dispatch')
class CustomerLoginView(APIView):
    """Customer login endpoint with profile type validation and rate limiting"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = CustomerLoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        user = serializer.validated_data['user']
        
        # Ensure user has customer profile (not staff)
        if not hasattr(user, 'customer_profile'):
            if hasattr(user, 'staff_profile'):
                return Response(
                    {'error': 'This is a staff account. Please use the staff login.'},
                    status=status.HTTP_403_FORBIDDEN
                )
            else:
                return Response(
                    {'error': 'Account does not have a customer profile.'},
                    status=status.HTTP_403_FORBIDDEN
                )
        
        # Additional security: Check for hybrid accounts
        try:
            CustomerProfile.ensure_single_profile_type(user)
        except ValidationError as e:
            return Response(
                {'error': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        login(request, user)
        
        return Response({
            'message': 'Login successful',
            'user': UserSerializer(user).data,
            'customer_profile': CustomerProfileSerializer(user.customer_profile).data,
            'session_id': request.session.session_key,
            'csrf_token': get_token(request)
        })

@method_decorator(ratelimit(key='user_or_ip', rate='20/m', method='POST', block=True), name='post')
@method_decorator(csrf_exempt, name='dispatch')
class CustomerLogoutView(APIView):
    """Enhanced customer logout endpoint with complete session cleanup and rate limiting"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        # Always logout, even if not authenticated (cleanup)
        logout(request)
        
        # Force session cleanup
        if hasattr(request, 'session'):
            request.session.flush()
        
        response = Response({'message': 'Logout successful'})
        
        # Clear all possible auth cookies
        auth_cookies = ['sessionid', 'csrftoken']
        for cookie_name in auth_cookies:
            response.delete_cookie(cookie_name)
            # Also try with domain
            response.delete_cookie(cookie_name, domain='.totetaxi.com')
        
        return response


@method_decorator(ratelimit(key='user', rate='60/m', method='GET', block=True), name='get')
class CurrentUserView(APIView):
    """Get current authenticated user info with profile validation and rate limiting"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        # Ensure profile integrity
        try:
            CustomerProfile.ensure_single_profile_type(request.user)
        except ValidationError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        
        if hasattr(request.user, 'customer_profile'):
            return Response({
                'user': UserSerializer(request.user).data,
                'customer_profile': CustomerProfileSerializer(request.user.customer_profile).data,
                'csrf_token': get_token(request)
            })
        else:
            return Response({'error': 'Not a customer account'}, status=status.HTTP_403_FORBIDDEN)


@method_decorator(ratelimit(key='ip', rate='100/m', method='GET', block=True), name='get')
class CSRFTokenView(APIView):
    """Get CSRF token for authenticated requests with rate limiting"""
    permission_classes = [permissions.AllowAny]
    
    @method_decorator(ensure_csrf_cookie)
    def get(self, request):
        return Response({
            'csrf_token': get_token(request)
        })


@method_decorator(ratelimit(key='user', rate='30/m', method=['GET', 'PATCH'], block=True), name='dispatch')
class CustomerProfileView(generics.RetrieveUpdateAPIView):
    """Customer profile management with validation and rate limiting"""
    serializer_class = CustomerProfileSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_object(self):
        # Ensure profile integrity
        try:
            CustomerProfile.ensure_single_profile_type(self.request.user)
        except ValidationError as e:
            from django.http import Http404
            raise Http404(str(e))
        
        return self.request.user.customer_profile


@method_decorator(ratelimit(key='user', rate='20/m', method=['GET', 'POST'], block=True), name='dispatch')
class SavedAddressListCreateView(generics.ListCreateAPIView):
    """List and create saved addresses with rate limiting"""
    serializer_class = SavedAddressSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return self.request.user.saved_addresses.filter(is_active=True)
    
    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


@method_decorator(ratelimit(key='user', rate='15/m', method=['GET', 'PATCH', 'DELETE'], block=True), name='dispatch')
class SavedAddressDetailView(generics.RetrieveUpdateDestroyAPIView):
    """Retrieve, update, delete saved address with rate limiting"""
    serializer_class = SavedAddressSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return self.request.user.saved_addresses.all()


@method_decorator(ratelimit(key='user', rate='30/m', method='GET', block=True), name='get')
class CustomerBookingListView(generics.ListAPIView):
    """Customer booking history with rate limiting"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return self.request.user.bookings.all().order_by('-created_at')
    
    def get(self, request, *args, **kwargs):
        bookings = self.get_queryset()
        booking_data = []
        
        for booking in bookings:
            booking_data.append({
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'service_type': booking.get_service_type_display(),
                'status': booking.get_status_display(),
                'pickup_date': booking.pickup_date,
                'total_price': booking.total_price_dollars,
                'created_at': booking.created_at
            })
        
        return Response({
            'bookings': booking_data,
            'total_count': len(booking_data)
        })


@method_decorator(ratelimit(key='user', rate='5/m', method='PATCH', block=True), name='patch')
class CustomerNotesUpdateView(APIView):
    """Update customer notes with rate limiting - staff only"""
    permission_classes = [permissions.IsAuthenticated]
    
    def patch(self, request, customer_id):
        # Check if user is staff
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Staff access required'}, status=status.HTTP_403_FORBIDDEN)
        
        try:
            customer_user = User.objects.get(id=customer_id)
            customer_profile = customer_user.customer_profile
        except (User.DoesNotExist, CustomerProfile.DoesNotExist):
            return Response({'error': 'Customer not found'}, status=status.HTTP_404_NOT_FOUND)
        
        notes = request.data.get('notes', '')
        customer_profile.notes = notes
        customer_profile.save()
        
        return Response({
            'message': 'Customer notes updated successfully',
            'notes': customer_profile.notes
        })


@method_decorator(ratelimit(key='user', rate='20/m', method='GET', block=True), name='get')
class CustomerDashboardView(APIView):
    """Enhanced customer dashboard with booking insights and rate limiting"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        if not hasattr(request.user, 'customer_profile'):
            return Response(
                {'error': 'This is not a customer account'}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        customer_profile = request.user.customer_profile
        
        all_bookings = request.user.bookings.filter(deleted_at__isnull=True).order_by('-created_at')
        recent_bookings = all_bookings[:5]
        
        pending_bookings = all_bookings.filter(status__in=['pending', 'confirmed']).count()
        completed_bookings = all_bookings.filter(status='completed').count()
        
        saved_addresses = request.user.saved_addresses.filter(is_active=True)
        payment_methods = request.user.payment_methods.filter(is_active=True)
        
        popular_addresses = saved_addresses.order_by('-times_used')[:3]
        
        return Response({
            'customer_profile': {
                'name': request.user.get_full_name(),
                'email': request.user.email,
                'phone': customer_profile.phone,
                'is_vip': customer_profile.is_vip,
                'total_bookings': customer_profile.total_bookings,
                'total_spent_dollars': customer_profile.total_spent_dollars,
                'last_booking_at': customer_profile.last_booking_at
            },
            'booking_summary': {
                'pending_bookings': pending_bookings,
                'completed_bookings': completed_bookings,
                'total_bookings': all_bookings.count()
            },
            'recent_bookings': [],
            'saved_addresses_count': saved_addresses.count(),
            'payment_methods_count': payment_methods.count(),
            'popular_addresses': SavedAddressSerializer(popular_addresses, many=True).data
        })


@method_decorator(ratelimit(key='user', rate='15/m', method='GET', block=True), name='get')
class BookingPreferencesView(APIView):
    """Manage customer booking preferences with rate limiting"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        customer_profile = request.user.customer_profile
        
        return Response({
            'preferred_pickup_time': customer_profile.preferred_pickup_time,
            'email_notifications': customer_profile.email_notifications,
            'sms_notifications': customer_profile.sms_notifications,
            'default_addresses': {
                'most_used_pickup': self._get_most_used_address('pickup'),
                'most_used_delivery': self._get_most_used_address('delivery')
            }
        })
    
    def _get_most_used_address(self, address_type):
        most_used = self.request.user.saved_addresses.filter(is_active=True).order_by('-times_used').first()
        return SavedAddressSerializer(most_used).data if most_used else None
    
    # Add this to the end of backend/apps/customers/views.py
```

# ==== apps/documents/__init__.py ====

```python

```

# ==== apps/documents/admin.py ====

```python
from django.contrib import admin

# Register your models here.
```

# ==== apps/documents/apps.py ====

```python
from django.apps import AppConfig


class DocumentsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.documents'
```

# ==== apps/documents/migrations/__init__.py ====

```python

```

# ==== apps/documents/models.py ====

```python
from django.db import models

# Create your models here.
```

# ==== apps/documents/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/documents/views.py ====

```python
from django.shortcuts import render

# Create your views here.
```

# ==== apps/logistics/__init__.py ====

```python

```

# ==== apps/logistics/admin.py ====

```python

```

# ==== apps/logistics/apps.py ====

```python
# apps/logistics/apps.py
from django.apps import AppConfig


class LogisticsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.logistics'
    verbose_name = 'Logistics'
```

# ==== apps/logistics/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.5 on 2025-09-13 23:37

import django.db.models.deletion
import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('bookings', '0002_booking_include_packing_booking_include_unpacking_and_more'),
    ]

    operations = [
        migrations.CreateModel(
            name='OnfleetTask',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('onfleet_task_id', models.CharField(max_length=100, unique=True)),
                ('onfleet_short_id', models.CharField(blank=True, max_length=20)),
                ('tracking_url', models.URLField(blank=True)),
                ('status', models.CharField(choices=[('created', 'Created'), ('assigned', 'Assigned'), ('active', 'Active'), ('completed', 'Completed'), ('failed', 'Failed')], default='created', max_length=20)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('last_synced', models.DateTimeField(blank=True, null=True)),
                ('booking', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='onfleet_task', to='bookings.booking')),
            ],
            options={
                'verbose_name': 'Onfleet Task',
                'verbose_name_plural': 'Onfleet Tasks',
                'db_table': 'logistics_onfleet_task',
                'indexes': [models.Index(fields=['onfleet_task_id'], name='logistics_o_onfleet_7020df_idx'), models.Index(fields=['status'], name='logistics_o_status_f0c32e_idx')],
            },
        ),
    ]
```

# ==== apps/logistics/migrations/__init__.py ====

```python

```

# ==== apps/logistics/models.py ====

```python
# apps/logistics/models.py
import uuid
from django.db import models
from django.utils import timezone
import logging

logger = logging.getLogger(__name__)


class OnfleetTask(models.Model):
    """Minimal bridge between ToteTaxi bookings and Onfleet tasks"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Core relationship - the only thing we really need to store
    booking = models.OneToOneField(
        'bookings.Booking', 
        on_delete=models.CASCADE, 
        related_name='onfleet_task'
    )
    
    # Onfleet identifiers - essential for API calls
    onfleet_task_id = models.CharField(max_length=100, unique=True)
    onfleet_short_id = models.CharField(max_length=20, blank=True)
    
    
    # Customer-facing tracking URL - this is what customers need
    tracking_url = models.URLField(blank=True)
    
    # Simple status for our internal use - maps from Onfleet state
    status = models.CharField(max_length=20, choices=[
        ('created', 'Created'),
        ('assigned', 'Assigned'), 
        ('active', 'Active'),
        ('completed', 'Completed'),
        ('failed', 'Failed')
    ], default='created')
    
    # Basic timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    last_synced = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        db_table = 'logistics_onfleet_task'
        verbose_name = 'Onfleet Task'
        verbose_name_plural = 'Onfleet Tasks'
        indexes = [
            models.Index(fields=['onfleet_task_id']),
            models.Index(fields=['status']),
        ]
    
    def __str__(self):
        return f"Onfleet Task for {self.booking.booking_number}"
    
    def sync_status_from_onfleet(self, onfleet_state):
        """Convert Onfleet state (0-3) to our status and update booking"""
        state_mapping = {
            0: 'created',    # unassigned
            1: 'assigned',   # assigned to driver
            2: 'active',     # driver started
            3: 'completed'   # delivery done
        }
        
        old_status = self.status
        self.status = state_mapping.get(onfleet_state, 'failed')
        self.last_synced = timezone.now()
        self.save()
        
        # Update ToteTaxi booking status when delivery completes
        if old_status != 'completed' and self.status == 'completed':
            self._mark_booking_completed()
    
    def _mark_booking_completed(self):
        """Update ToteTaxi booking when Onfleet delivery completes"""
        try:
            # Update booking status
            if self.booking.status in ['confirmed', 'in_progress']:
                self.booking.status = 'completed'
                self.booking.save()
            
            # Update customer stats if authenticated user
            if self.booking.customer and hasattr(self.booking.customer, 'customer_profile'):
                profile = self.booking.customer.customer_profile
                profile.total_bookings += 1
                profile.total_spent_cents += self.booking.total_price_cents
                profile.last_booking_at = timezone.now()
                
                # Check for VIP upgrade
                if not profile.is_vip and profile.total_spent_dollars >= 2000:
                    profile.is_vip = True
                    
                profile.save()
                
        except Exception as e:
            logger.error(f"Error updating booking completion for {self.booking.booking_number}: {e}")


# Signal to auto-create Onfleet tasks when bookings are confirmed
from django.db.models.signals import post_save
from django.dispatch import receiver

@receiver(post_save, sender='bookings.Booking')
def create_onfleet_task(sender, instance, created, **kwargs):
    """Auto-create Onfleet task when booking is confirmed"""
    if instance.status == 'confirmed' and not hasattr(instance, 'onfleet_task'):
        try:
            from .services import ToteTaxiOnfleetIntegration
            integration = ToteTaxiOnfleetIntegration()
            integration.create_delivery_task(instance)
        except Exception as e:
            logger.error(f"Failed to create Onfleet task for booking {instance.booking_number}: {e}")
```

# ==== apps/logistics/services.py ====

```python
# apps/logistics/services.py - FIXED VERSION
import requests
from django.conf import settings
from django.utils import timezone
from datetime import time
from typing import Dict, Optional
import logging

logger = logging.getLogger(__name__)


class OnfleetService:
    """Simple Onfleet API wrapper for ToteTaxi integration"""
    
    def __init__(self):
        self.api_key = getattr(settings, 'ONFLEET_API_KEY', '')
        self.base_url = 'https://onfleet.com/api/v2'
        self.mock_mode = getattr(settings, 'ONFLEET_MOCK_MODE', True)
    
    def _make_request(self, method: str, endpoint: str, data: dict = None) -> dict:
        """Make authenticated request to Onfleet API"""
        if self.mock_mode:
            return self._mock_response(method, endpoint, data)
        
        url = f"{self.base_url}/{endpoint}"
        auth = (self.api_key, '')
        headers = {'Content-Type': 'application/json'}
        
        try:
            if method == 'GET':
                response = requests.get(url, auth=auth, headers=headers)
            elif method == 'POST':
                response = requests.post(url, auth=auth, headers=headers, json=data)
            elif method == 'PUT':
                response = requests.put(url, auth=auth, headers=headers, json=data)
            
            response.raise_for_status()
            return response.json()
        
        except requests.RequestException as e:
            logger.error(f"Onfleet API error: {e}")
            raise
    
    def _mock_response(self, method: str, endpoint: str, data: dict = None) -> dict:
        """Mock responses for development"""
        if endpoint == 'tasks' and method == 'POST':
            booking_number = data.get('metadata', [{}])[0].get('value', 'unknown')
            return {
                'id': f'mock_task_{hash(booking_number) % 10000}',
                'shortId': f'mt{hash(booking_number) % 1000:03d}',
                'trackingURL': f'https://onf.lt/mock{hash(booking_number) % 10000}',
                'state': 0,
                'merchant': 'mock_org_id',
                'creator': 'mock_admin_id'
            }
        elif endpoint == 'organization':
            return {
                'id': 'mock_org_id',
                'name': 'ToteTaxi (Test Mode)',
                'activeTasks': 3,
                'workers': [
                    {'id': 'mock_worker_1', 'name': 'Test Driver 1', 'onDuty': True},
                    {'id': 'mock_worker_2', 'name': 'Test Driver 2', 'onDuty': True}
                ]
            }
        return {'success': True, 'mock': True}
    
    def _get_customer_phone(self, booking):
        """Get customer phone number - works for both authenticated and guest"""
        try:
            # Authenticated customer
            if booking.customer and hasattr(booking.customer, 'customer_profile'):
                phone = booking.customer.customer_profile.phone
                return phone if phone else ''
            
            # Guest checkout (when we have them)
            elif booking.guest_checkout:
                # Try common phone field names
                for field_name in ['phone', 'customer_phone', 'phone_number']:
                    if hasattr(booking.guest_checkout, field_name):
                        phone = getattr(booking.guest_checkout, field_name)
                        if phone:
                            return phone
            
            return ''
        except Exception as e:
            logger.warning(f"Could not get phone for booking {booking.booking_number}: {e}")
            return ''
    
    def _convert_pickup_time(self, pickup_time_str):
        """Convert string pickup time to time object"""
        time_mapping = {
            'morning': time(9, 0),      # 9:00 AM
            'afternoon': time(14, 0),   # 2:00 PM  
            'evening': time(18, 0)      # 6:00 PM
        }
        return time_mapping.get(pickup_time_str, time(9, 0))
    
    def create_task_from_booking(self, booking) -> dict:
        """Create Onfleet task from ToteTaxi booking"""
        customer_phone = self._get_customer_phone(booking)
        
        task_data = {
            'destination': {
                'address': {
                    'unparsed': f"{booking.delivery_address.address_line_1}, {booking.delivery_address.city}, {booking.delivery_address.state} {booking.delivery_address.zip_code}"
                }
            },
            'recipients': [{
                'name': booking.get_customer_name(),
                'phone': customer_phone,
                'notes': f"ToteTaxi customer - {booking.get_service_type_display()}"
            }],
            'notes': f"ToteTaxi Booking #{booking.booking_number}\nService: {booking.get_service_type_display()}\nInstructions: {booking.special_instructions or 'None'}",
            'metadata': [{
                'name': 'totetaxi_booking_number',
                'type': 'string',
                'value': booking.booking_number,
                'visibility': ['api']
            }, {
                'name': 'totetaxi_booking_id',
                'type': 'string', 
                'value': str(booking.id),
                'visibility': ['api']
            }]
        }
        
        # Handle timing - convert string pickup times
        if booking.pickup_date and booking.pickup_time:
            try:
                pickup_time = self._convert_pickup_time(booking.pickup_time)
                pickup_datetime = timezone.datetime.combine(
                    booking.pickup_date, 
                    pickup_time,
                    tzinfo=timezone.get_current_timezone()
                )
                task_data['completeAfter'] = int(pickup_datetime.timestamp() * 1000)
            except Exception as e:
                logger.warning(f"Could not set timing for booking {booking.booking_number}: {e}")
        
        return self._make_request('POST', 'tasks', task_data)
    
    def get_organization_info(self) -> dict:
        """Get basic organization info for dashboard"""
        return self._make_request('GET', 'organization')


class ToteTaxiOnfleetIntegration:
    """High-level integration manager for ToteTaxi + Onfleet"""
    
    def __init__(self):
        self.onfleet = OnfleetService()
    
    def create_delivery_task(self, booking) -> Optional['OnfleetTask']:
        """Create Onfleet task when ToteTaxi booking is confirmed"""
        from .models import OnfleetTask
        
        try:
            if hasattr(booking, 'onfleet_task'):
                logger.warning(f"Booking {booking.booking_number} already has Onfleet task")
                return booking.onfleet_task
            
            onfleet_response = self.onfleet.create_task_from_booking(booking)
            
            onfleet_task = OnfleetTask.objects.create(
                booking=booking,
                onfleet_task_id=onfleet_response['id'],
                onfleet_short_id=onfleet_response.get('shortId', ''),
                tracking_url=onfleet_response.get('trackingURL', ''),
                status='created'
            )
            
            logger.info(f"Created Onfleet task {onfleet_task.onfleet_task_id} for booking {booking.booking_number}")
            return onfleet_task
            
        except Exception as e:
            logger.error(f"Failed to create Onfleet task for booking {booking.booking_number}: {e}")
            return None
    
    def handle_webhook(self, webhook_data: dict) -> bool:
        """Process Onfleet webhook updates"""
        from .models import OnfleetTask
        
        try:
            task_data = webhook_data.get('data', {}).get('task', {})
            
            if not task_data.get('id'):
                return False
            
            onfleet_task = OnfleetTask.objects.get(onfleet_task_id=task_data['id'])
            onfleet_state = task_data.get('state')
            
            if onfleet_state is not None:
                onfleet_task.sync_status_from_onfleet(onfleet_state)
                return True
            
            return False
            
        except OnfleetTask.DoesNotExist:
            logger.warning(f"Onfleet task {task_data.get('id')} not found")
            return False
        except Exception as e:
            logger.error(f"Webhook processing error: {e}")
            return False
    
    def get_dashboard_summary(self) -> dict:
        """Get logistics summary for staff dashboard"""
        from .models import OnfleetTask
        from apps.bookings.models import Booking
        from datetime import date
        
        try:
            today = date.today()
            
            todays_bookings = Booking.objects.filter(
                pickup_date=today,
                deleted_at__isnull=True
            )
            
            onfleet_tasks = OnfleetTask.objects.filter(created_at__date=today)
            onfleet_org = self.onfleet.get_organization_info()
            
            return {
                'totetaxi_stats': {
                    'total_bookings': todays_bookings.count(),
                    'confirmed_bookings': todays_bookings.filter(status='confirmed').count(),
                    'completed_bookings': todays_bookings.filter(status='completed').count(),
                },
                'onfleet_stats': {
                    'active_tasks': onfleet_org.get('activeTasks', 0),
                    'available_workers': len([w for w in onfleet_org.get('workers', []) if w.get('onDuty')]),
                    'organization_name': onfleet_org.get('name', 'Unknown')
                },
                'integration_stats': {
                    'tasks_created_today': onfleet_tasks.count(),
                    'tasks_completed_today': onfleet_tasks.filter(status='completed').count(),
                    'tasks_active': onfleet_tasks.filter(status__in=['assigned', 'active']).count(),
                }
            }
            
        except Exception as e:
            logger.error(f"Error getting dashboard summary: {e}")
            return {
                'error': 'Failed to fetch logistics data',
                'totetaxi_stats': {'total_bookings': 0, 'confirmed_bookings': 0, 'completed_bookings': 0},
                'onfleet_stats': {'active_tasks': 0, 'available_workers': 0, 'organization_name': 'Error'},
                'integration_stats': {'tasks_created_today': 0, 'tasks_completed_today': 0, 'tasks_active': 0}
            }
```

# ==== apps/logistics/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/logistics/urls.py ====

```python
# apps/logistics/urls.py
from django.urls import path
from . import views

app_name = 'logistics'

urlpatterns = [
    # Staff dashboard endpoints
    path('summary/', views.LogisticsSummaryView.as_view(), name='logistics-summary'),
    path('sync/', views.sync_onfleet_status, name='sync-onfleet'),
    path('tasks/', views.TaskStatusView.as_view(), name='task-status'),
    path('create-task/', views.create_task_manually, name='create-task'),
    
    # Webhook endpoint (for Onfleet to call)
    path('webhook/', views.OnfleetWebhookView.as_view(), name='onfleet-webhook'),
]
```

# ==== apps/logistics/views.py ====

```python
# apps/logistics/views.py
from rest_framework import status, permissions
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.utils import timezone
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
import logging

from .services import ToteTaxiOnfleetIntegration
from .models import OnfleetTask

logger = logging.getLogger(__name__)


class LogisticsSummaryView(APIView):
    """Simple logistics overview for staff dashboard"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Staff access required'}, status=403)
        
        try:
            integration = ToteTaxiOnfleetIntegration()
            summary = integration.get_dashboard_summary()
            
            return Response({
                'success': True,
                'data': summary,
                'timestamp': timezone.now()
            })
            
        except Exception as e:
            logger.error(f"Error in logistics summary: {e}")
            return Response({
                'error': 'Failed to fetch logistics data',
                'details': str(e)
            }, status=500)


@api_view(['POST'])
@permission_classes([permissions.IsAuthenticated])
def sync_onfleet_status(request):
    """Manual sync button for staff dashboard"""
    if not hasattr(request.user, 'staff_profile'):
        return Response({'error': 'Staff access required'}, status=403)
    
    try:
        # Get recent incomplete tasks
        recent_tasks = OnfleetTask.objects.filter(
            status__in=['created', 'assigned', 'active'],
            created_at__gte=timezone.now() - timezone.timedelta(days=7)
        )
        
        synced_count = 0
        for task in recent_tasks:
            # In production, you'd fetch current status from Onfleet API
            # For now, just update the sync timestamp
            task.last_synced = timezone.now()
            task.save()
            synced_count += 1
        
        return Response({
            'success': True,
            'message': f'Synced {synced_count} tasks',
            'synced_count': synced_count,
            'timestamp': timezone.now()
        })
        
    except Exception as e:
        logger.error(f"Sync error: {e}")
        return Response({
            'error': f'Sync failed: {str(e)}'
        }, status=500)


@api_view(['POST'])
@permission_classes([permissions.IsAuthenticated])
def create_task_manually(request):
    """Manually create Onfleet task for a booking"""
    if not hasattr(request.user, 'staff_profile'):
        return Response({'error': 'Staff access required'}, status=403)
    
    booking_id = request.data.get('booking_id')
    if not booking_id:
        return Response({'error': 'booking_id required'}, status=400)
    
    try:
        from apps.bookings.models import Booking
        booking = Booking.objects.get(id=booking_id, deleted_at__isnull=True)
        
        integration = ToteTaxiOnfleetIntegration()
        task = integration.create_delivery_task(booking)
        
        if task:
            return Response({
                'success': True,
                'message': f'Created Onfleet task for {booking.booking_number}',
                'task': {
                    'id': str(task.id),
                    'onfleet_task_id': task.onfleet_task_id,
                    'tracking_url': task.tracking_url,
                    'status': task.status
                }
            })
        else:
            return Response({
                'error': 'Failed to create Onfleet task'
            }, status=500)
            
    except Booking.DoesNotExist:
        return Response({'error': 'Booking not found'}, status=404)
    except Exception as e:
        logger.error(f"Manual task creation error: {e}")
        return Response({
            'error': f'Task creation failed: {str(e)}'
        }, status=500)


@method_decorator(csrf_exempt, name='dispatch')
class OnfleetWebhookView(APIView):
    """Handle Onfleet webhook notifications"""
    permission_classes = []  # Webhooks don't use session auth
    
    def post(self, request):
        try:
            # TODO: In production, verify webhook signature here
            # webhook_secret = getattr(settings, 'ONFLEET_WEBHOOK_SECRET', None)
            
            webhook_data = request.data
            integration = ToteTaxiOnfleetIntegration()
            
            success = integration.handle_webhook(webhook_data)
            
            if success:
                return Response({
                    'success': True,
                    'message': 'Webhook processed successfully',
                    'timestamp': timezone.now()
                })
            else:
                return Response({
                    'success': False,
                    'message': 'Webhook processing failed'
                }, status=400)
                
        except Exception as e:
            logger.error(f"Webhook error: {e}")
            return Response({
                'error': 'Webhook processing failed',
                'details': str(e)
            }, status=500)


class TaskStatusView(APIView):
    """Get status of Onfleet tasks"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Staff access required'}, status=403)
        
        # Get query params
        booking_id = request.query_params.get('booking_id')
        date_filter = request.query_params.get('date')
        
        try:
            tasks = OnfleetTask.objects.all()
            
            if booking_id:
                tasks = tasks.filter(booking_id=booking_id)
            
            if date_filter:
                tasks = tasks.filter(created_at__date=date_filter)
            
            tasks = tasks.select_related('booking').order_by('-created_at')[:50]
            
            task_data = []
            for task in tasks:
                task_data.append({
                    'id': str(task.id),
                    'booking_number': task.booking.booking_number,
                    'customer_name': task.booking.get_customer_name(),
                    'onfleet_task_id': task.onfleet_task_id,
                    'onfleet_short_id': task.onfleet_short_id,
                    'tracking_url': task.tracking_url,
                    'status': task.status,
                    'created_at': task.created_at,
                    'last_synced': task.last_synced
                })
            
            return Response({
                'success': True,
                'tasks': task_data,
                'count': len(task_data)
            })
            
        except Exception as e:
            logger.error(f"Error fetching tasks: {e}")
            return Response({
                'error': 'Failed to fetch tasks',
                'details': str(e)
            }, status=500)
```

# ==== apps/notifications/__init__.py ====

```python

```

# ==== apps/notifications/admin.py ====

```python
from django.contrib import admin

# Register your models here.
```

# ==== apps/notifications/apps.py ====

```python
from django.apps import AppConfig


class NotificationsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.notifications'
```

# ==== apps/notifications/migrations/__init__.py ====

```python

```

# ==== apps/notifications/models.py ====

```python
from django.db import models

# Create your models here.
```

# ==== apps/notifications/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/notifications/views.py ====

```python
from django.shortcuts import render

# Create your views here.
```

# ==== apps/payments/__init__.py ====

```python

```

# ==== apps/payments/admin.py ====

```python
from django.contrib import admin
from django.utils.html import format_html
from .models import Payment, Refund, PaymentAudit

@admin.register(Payment)
class PaymentAdmin(admin.ModelAdmin):
    list_display = (
        'booking', 
        'get_customer_name', 
        'amount_dollars', 
        'status', 
        'get_status_badge',
        'created_at',
        'processed_at'
    )
    list_filter = ('status', 'created_at', 'processed_at')
    search_fields = (
        'booking__booking_number', 
        'customer__email', 
        'stripe_payment_intent_id',
        'stripe_charge_id'
    )
    readonly_fields = ('created_at', 'updated_at', 'processed_at')
    
    fieldsets = (
        ('Booking & Customer', {
            'fields': ('booking', 'customer')
        }),
        ('Payment Details', {
            'fields': ('amount_cents', 'status', 'failure_reason')
        }),
        ('Stripe Integration', {
            'fields': ('stripe_payment_intent_id', 'stripe_charge_id')
        }),
        ('Timestamps', {
            'fields': ('processed_at', 'created_at', 'updated_at'),
            'classes': ('collapse',)
        })
    )
    
    def get_customer_name(self, obj):
        if obj.customer:
            return obj.customer.full_name
        else:
            return obj.booking.get_customer_name()
    get_customer_name.short_description = 'Customer'
    
    def get_status_badge(self, obj):
        colors = {
            'pending': 'orange',
            'succeeded': 'green',
            'failed': 'red',
            'refunded': 'blue'
        }
        color = colors.get(obj.status, 'gray')
        return format_html(
            '<span style="color: {}; font-weight: bold;">{}</span>',
            color,
            obj.get_status_display()
        )
    get_status_badge.short_description = 'Status'

@admin.register(Refund)
class RefundAdmin(admin.ModelAdmin):
    list_display = (
        'payment',
        'get_booking_number',
        'amount_dollars',
        'status',
        'get_status_badge',
        'requested_by',
        'approved_by',
        'created_at'
    )
    list_filter = ('status', 'created_at', 'approved_at')
    search_fields = (
        'payment__booking__booking_number',
        'reason',
        'requested_by__email',
        'approved_by__email'
    )
    readonly_fields = ('created_at', 'approved_at', 'completed_at')
    
    fieldsets = (
        ('Refund Details', {
            'fields': ('payment', 'amount_cents', 'reason')
        }),
        ('Approval Workflow', {
            'fields': ('status', 'requested_by', 'approved_by')
        }),
        ('Stripe Integration', {
            'fields': ('stripe_refund_id',)
        }),
        ('Timestamps', {
            'fields': ('approved_at', 'completed_at', 'created_at'),
            'classes': ('collapse',)
        })
    )
    
    actions = ['approve_refunds', 'deny_refunds']
    
    def get_booking_number(self, obj):
        return obj.payment.booking.booking_number
    get_booking_number.short_description = 'Booking #'
    
    def get_status_badge(self, obj):
        colors = {
            'requested': 'orange',
            'approved': 'green',
            'denied': 'red',
            'completed': 'blue'
        }
        color = colors.get(obj.status, 'gray')
        return format_html(
            '<span style="color: {}; font-weight: bold;">{}</span>',
            color,
            obj.get_status_display()
        )
    get_status_badge.short_description = 'Status'
    
    def approve_refunds(self, request, queryset):
        """Bulk approve refunds (only if user is admin)"""
        if not request.user.can_approve_refunds:
            self.message_user(request, 'Only admin users can approve refunds.', level='ERROR')
            return
        
        approved_count = 0
        for refund in queryset.filter(status='requested'):
            try:
                refund.approve(request.user)
                approved_count += 1
            except ValueError as e:
                self.message_user(request, str(e), level='ERROR')
        
        if approved_count > 0:
            self.message_user(
                request, 
                f'Successfully approved {approved_count} refund(s).'
            )
    approve_refunds.short_description = "Approve selected refunds"
    
    def deny_refunds(self, request, queryset):
        """Bulk deny refunds"""
        if not request.user.can_approve_refunds:
            self.message_user(request, 'Only admin users can deny refunds.', level='ERROR')
            return
        
        denied_count = queryset.filter(status='requested').update(status='denied')
        self.message_user(
            request, 
            f'Successfully denied {denied_count} refund(s).'
        )
    deny_refunds.short_description = "Deny selected refunds"

@admin.register(PaymentAudit)
class PaymentAuditAdmin(admin.ModelAdmin):
    list_display = ('action', 'get_short_description', 'user', 'created_at')
    list_filter = ('action', 'created_at')
    search_fields = ('description', 'user__email')
    readonly_fields = ('created_at',)
    
    fieldsets = (
        ('Action Details', {
            'fields': ('action', 'description')
        }),
        ('Related Records', {
            'fields': ('payment', 'refund')
        }),
        ('User & Timestamp', {
            'fields': ('user', 'created_at')
        })
    )
    
    def get_short_description(self, obj):
        return obj.description[:50] + ('...' if len(obj.description) > 50 else '')
    get_short_description.short_description = 'Description'
    
    # Make it mostly read-only (audit logs shouldn't be edited)
    def has_add_permission(self, request):
        return False
    
    def has_change_permission(self, request, obj=None):
        return False
    
    def has_delete_permission(self, request, obj=None):
        return request.user.is_superuser  # Only superusers can delete audit logs
```

# ==== apps/payments/apps.py ====

```python
from django.apps import AppConfig


class PaymentsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.payments'
```

# ==== apps/payments/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.5 on 2025-09-02 20:54

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('bookings', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Payment',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('amount_cents', models.PositiveBigIntegerField()),
                ('stripe_payment_intent_id', models.CharField(blank=True, max_length=200)),
                ('stripe_charge_id', models.CharField(blank=True, max_length=200)),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('succeeded', 'Succeeded'), ('failed', 'Failed'), ('refunded', 'Refunded')], default='pending', max_length=20)),
                ('failure_reason', models.TextField(blank=True)),
                ('processed_at', models.DateTimeField(blank=True, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('booking', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='payments', to='bookings.booking')),
                ('customer', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='payments', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'payments_payment',
            },
        ),
        migrations.CreateModel(
            name='Refund',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('amount_cents', models.PositiveBigIntegerField()),
                ('reason', models.TextField()),
                ('status', models.CharField(choices=[('requested', 'Requested'), ('approved', 'Approved'), ('denied', 'Denied'), ('completed', 'Completed')], default='requested', max_length=20)),
                ('stripe_refund_id', models.CharField(blank=True, max_length=200)),
                ('approved_at', models.DateTimeField(blank=True, null=True)),
                ('completed_at', models.DateTimeField(blank=True, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('approved_by', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.PROTECT, related_name='approved_refunds', to=settings.AUTH_USER_MODEL)),
                ('payment', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='refunds', to='payments.payment')),
                ('requested_by', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='requested_refunds', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'payments_refund',
            },
        ),
        migrations.CreateModel(
            name='PaymentAudit',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('action', models.CharField(choices=[('payment_created', 'Payment Created'), ('payment_succeeded', 'Payment Succeeded'), ('payment_failed', 'Payment Failed'), ('refund_requested', 'Refund Requested'), ('refund_approved', 'Refund Approved'), ('refund_completed', 'Refund Completed')], max_length=30)),
                ('description', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('payment', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='payments.payment')),
                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL)),
                ('refund', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='payments.refund')),
            ],
            options={
                'db_table': 'payments_audit',
                'ordering': ['-created_at'],
            },
        ),
    ]
```

# ==== apps/payments/migrations/__init__.py ====

```python

```

# ==== apps/payments/models.py ====

```python
import uuid
from django.db import models
from django.utils import timezone
from django.contrib.auth.models import User


class Payment(models.Model):
    """Payment records for bookings - simple Stripe integration"""
    
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('succeeded', 'Succeeded'),
        ('failed', 'Failed'),
        ('refunded', 'Refunded'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Link to booking
    booking = models.ForeignKey(
        'bookings.Booking',
        on_delete=models.PROTECT,
        related_name='payments'
    )
    
    # Customer (if authenticated)
    customer = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='payments'
    )
    
    # Payment amount
    amount_cents = models.PositiveBigIntegerField()
    
    # Stripe integration
    stripe_payment_intent_id = models.CharField(max_length=200, blank=True)
    stripe_charge_id = models.CharField(max_length=200, blank=True)
    
    # Status
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    failure_reason = models.TextField(blank=True)
    
    # Timestamps
    processed_at = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'payments_payment'
    
    def __str__(self):
        return f"{self.booking.booking_number} - ${self.amount_dollars} ({self.status})"
    
    @property
    def amount_dollars(self):
        return self.amount_cents / 100


class Refund(models.Model):
    """Refund requests with simple approval workflow"""
    
    STATUS_CHOICES = [
        ('requested', 'Requested'),
        ('approved', 'Approved'),
        ('denied', 'Denied'),
        ('completed', 'Completed'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Original payment
    payment = models.ForeignKey(
        Payment,
        on_delete=models.PROTECT,
        related_name='refunds'
    )
    
    # Refund details
    amount_cents = models.PositiveBigIntegerField()
    reason = models.TextField()
    
    # Approval workflow
    requested_by = models.ForeignKey(
        User,
        on_delete=models.PROTECT,
        related_name='requested_refunds'
    )
    approved_by = models.ForeignKey(
        User,
        on_delete=models.PROTECT,
        null=True,
        blank=True,
        related_name='approved_refunds'
    )
    
    # Status and Stripe
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='requested')
    stripe_refund_id = models.CharField(max_length=200, blank=True)
    
    # Timestamps
    approved_at = models.DateTimeField(null=True, blank=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'payments_refund'
    
    def __str__(self):
        return f"Refund ${self.amount_dollars} for {self.payment.booking.booking_number}"
    
    @property
    def amount_dollars(self):
        return self.amount_cents / 100
    
    def approve(self, admin_user):
        """Admin approves refund"""
        self.status = 'approved'
        self.approved_by = admin_user
        self.approved_at = timezone.now()
        self.save()


class PaymentAudit(models.Model):
    """Basic audit log for financial compliance"""
    
    ACTION_CHOICES = [
        ('payment_created', 'Payment Created'),
        ('payment_succeeded', 'Payment Succeeded'),
        ('payment_failed', 'Payment Failed'),
        ('refund_requested', 'Refund Requested'),
        ('refund_approved', 'Refund Approved'),
        ('refund_completed', 'Refund Completed'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # What happened
    action = models.CharField(max_length=30, choices=ACTION_CHOICES)
    description = models.TextField()
    
    # Related records
    payment = models.ForeignKey(Payment, on_delete=models.CASCADE, null=True, blank=True)
    refund = models.ForeignKey(Refund, on_delete=models.CASCADE, null=True, blank=True)
    
    # Who did it (staff user)
    user = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'payments_audit'
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.action} - {self.created_at}"
    
    @classmethod
    def log(cls, action, description, payment=None, refund=None, user=None):
        """Simple audit logging"""
        return cls.objects.create(
            action=action,
            description=description,
            payment=payment,
            refund=refund,
            user=user
        )
```

# ==== apps/payments/serializers.py ====

```python
from rest_framework import serializers
from .models import Payment, Refund
from apps.bookings.models import Booking


class PaymentIntentCreateSerializer(serializers.Serializer):
    """Serializer for creating payment intent"""
    booking_id = serializers.UUIDField()
    customer_email = serializers.EmailField(required=False)
    
    def validate_booking_id(self, value):
        try:
            booking = Booking.objects.get(id=value, deleted_at__isnull=True)
            if booking.status in ['paid', 'completed']:
                raise serializers.ValidationError("Booking is already paid")
            return value
        except Booking.DoesNotExist:
            raise serializers.ValidationError("Booking not found")


class PaymentSerializer(serializers.ModelSerializer):
    amount_dollars = serializers.ReadOnlyField()
    booking_number = serializers.SerializerMethodField()
    customer_name = serializers.SerializerMethodField()
    
    class Meta:
        model = Payment
        fields = (
            'id', 'booking_number', 'customer_name', 'amount_cents', 
            'amount_dollars', 'status', 'stripe_payment_intent_id',
            'stripe_charge_id', 'failure_reason', 'processed_at', 'created_at'
        )
        read_only_fields = ('id', 'created_at')
    
    def get_booking_number(self, obj):
        return obj.booking.booking_number
    
    def get_customer_name(self, obj):
        return obj.booking.get_customer_name()


class PaymentConfirmSerializer(serializers.Serializer):
    """Serializer for payment confirmation webhook"""
    payment_intent_id = serializers.CharField()
    status = serializers.ChoiceField(choices=['succeeded', 'failed'])
    failure_reason = serializers.CharField(required=False, allow_blank=True)


class RefundCreateSerializer(serializers.Serializer):
    """Serializer for creating refunds"""
    payment_id = serializers.UUIDField()
    amount_cents = serializers.IntegerField(min_value=1)
    reason = serializers.CharField(max_length=500)
    
    def validate_payment_id(self, value):
        try:
            payment = Payment.objects.get(id=value, status='succeeded')
            return value
        except Payment.DoesNotExist:
            raise serializers.ValidationError("Payment not found or not succeeded")
    
    def validate(self, attrs):
        try:
            payment = Payment.objects.get(id=attrs['payment_id'])
            if attrs['amount_cents'] > payment.amount_cents:
                raise serializers.ValidationError("Refund amount cannot exceed payment amount")
        except Payment.DoesNotExist:
            pass  # Already handled in validate_payment_id
        return attrs


class RefundSerializer(serializers.ModelSerializer):
    amount_dollars = serializers.ReadOnlyField()
    payment_booking_number = serializers.SerializerMethodField()
    requested_by_name = serializers.SerializerMethodField()
    approved_by_name = serializers.SerializerMethodField()
    
    class Meta:
        model = Refund
        fields = (
            'id', 'payment_booking_number', 'amount_cents', 'amount_dollars',
            'reason', 'status', 'requested_by_name', 'approved_by_name',
            'approved_at', 'completed_at', 'created_at'
        )
        read_only_fields = ('id', 'created_at')
    
    def get_payment_booking_number(self, obj):
        return obj.payment.booking.booking_number
    
    def get_requested_by_name(self, obj):
        return obj.requested_by.get_full_name() if obj.requested_by else None
    
    def get_approved_by_name(self, obj):
        return obj.approved_by.get_full_name() if obj.approved_by else None
```

# ==== apps/payments/services.py ====

```python
import stripe
from django.conf import settings
from django.utils import timezone
from decimal import Decimal
from .models import Payment, PaymentAudit
from apps.bookings.models import Booking

stripe.api_key = settings.STRIPE_SECRET_KEY


class StripePaymentService:
    """Service layer for Stripe payment processing"""
    
    @staticmethod
    def create_payment_intent(booking, customer_email=None):
        """Create Stripe PaymentIntent for a booking"""
        try:
            intent = stripe.PaymentIntent.create(
                amount=int(booking.total_price_cents),
                currency='usd',
                metadata={
                    'booking_id': str(booking.id),
                    'booking_number': booking.booking_number,
                },
                receipt_email=customer_email or (booking.customer.email if hasattr(booking, 'customer') and booking.customer else None),
            )
            
            payment = Payment.objects.create(
                booking=booking,
                customer=booking.customer if hasattr(booking, 'customer') and booking.customer else None,
                amount_cents=booking.total_price_cents,
                stripe_payment_intent_id=intent.id,
                status='pending'
            )
            
            PaymentAudit.log(
                action='payment_created',
                description=f'PaymentIntent created for booking {booking.booking_number}',
                payment=payment,
                user=None
            )
            
            return {
                'payment': payment,
                'client_secret': intent.client_secret,
                'payment_intent_id': intent.id
            }
            
        except stripe.error.StripeError as e:
            raise Exception(f"Stripe error: {str(e)}")
        except Exception as e:
            raise Exception(f"Failed to create PaymentIntent: {str(e)}")
    
    @staticmethod
    def confirm_payment(payment_intent_id):
        """Verify payment with Stripe and update records - CRITICAL: Updates customer stats"""
        try:
            intent = stripe.PaymentIntent.retrieve(payment_intent_id)
            
            payment = Payment.objects.get(stripe_payment_intent_id=payment_intent_id)
            
            if intent.status == 'succeeded':
                payment.status = 'succeeded'
                payment.stripe_charge_id = intent.latest_charge if hasattr(intent, 'latest_charge') else ''
                payment.processed_at = timezone.now()
                payment.save()
                
                booking = payment.booking
                if booking.status == 'pending':
                    booking.status = 'paid'
                    booking.save()
                
                try:
                    if booking.customer and hasattr(booking.customer, 'customer_profile'):
                        booking.customer.customer_profile.add_booking_stats(
                            booking.total_price_cents
                        )
                        print(f"✅ Updated customer stats: {booking.customer.get_full_name()} - +${booking.total_price_dollars}")
                except Exception as stats_error:
                    print(f"⚠️ Failed to update customer stats: {stats_error}")
                
                PaymentAudit.log(
                    action='payment_succeeded',
                    description=f'Payment confirmed for booking {booking.booking_number}',
                    payment=payment,
                    user=None
                )
                
                return payment
            else:
                payment.status = 'failed'
                payment.failure_reason = f"Payment status: {intent.status}"
                payment.save()
                raise Exception(f"Payment not successful: {intent.status}")
            
        except Payment.DoesNotExist:
            raise Exception("Payment not found")
        except stripe.error.StripeError as e:
            raise Exception(f"Stripe error: {str(e)}")
    
    @staticmethod
    def create_refund(payment, amount_cents, reason, requested_by_user):
        """Create refund for a payment"""
        from .models import Refund
        
        try:
            refund = stripe.Refund.create(
                payment_intent=payment.stripe_payment_intent_id,
                amount=amount_cents,
                reason='requested_by_customer',
            )
            
            refund_record = Refund.objects.create(
                payment=payment,
                amount_cents=amount_cents,
                reason=reason,
                requested_by=requested_by_user,
                stripe_refund_id=refund.id,
                status='completed'
            )
            
            payment.status = 'refunded'
            payment.save()
            
            PaymentAudit.log(
                action='refund_completed',
                description=f'Refund completed for payment {payment.id}',
                payment=payment,
                refund=refund_record,
                user=requested_by_user
            )
            
            return refund_record
            
        except stripe.error.StripeError as e:
            raise Exception(f"Stripe refund error: {str(e)}")
```

# ==== apps/payments/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/payments/urls.py ====

```python
from django.urls import path
from . import views

urlpatterns = [
    # Public payment endpoints
    path('create-intent/', views.PaymentIntentCreateView.as_view(), name='payment-intent-create'),
    path('status/<str:booking_number>/', views.PaymentStatusView.as_view(), name='payment-status'),
    path('webhook/', views.StripeWebhookView.as_view(), name='stripe-webhook'),
    path('confirm/', views.PaymentConfirmView.as_view(), name='payment-confirm'),  # NEW
    
    # Mock endpoints (testing only)
    path('mock-confirm/', views.MockPaymentConfirmView.as_view(), name='mock-payment-confirm'),
    
    # Staff endpoints
    path('payments/', views.PaymentListView.as_view(), name='payment-list'),
    path('refunds/', views.RefundListView.as_view(), name='refund-list'),
    path('refunds/create/', views.RefundCreateView.as_view(), name='refund-create'),
]
```

# ==== apps/payments/views.py ====

```python
from rest_framework import generics, status, permissions
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.shortcuts import get_object_or_404
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from django.http import HttpResponse
from .models import Payment, Refund
from .serializers import (
    PaymentIntentCreateSerializer,
    PaymentSerializer,
    PaymentConfirmSerializer,
    RefundCreateSerializer,
    RefundSerializer
)
from .services import StripePaymentService
from apps.bookings.models import Booking


class PaymentIntentCreateView(APIView):
    """Create Stripe PaymentIntent for a booking - no authentication required for guest bookings"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = PaymentIntentCreateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        booking_id = serializer.validated_data['booking_id']
        customer_email = serializer.validated_data.get('customer_email')
        
        try:
            booking = Booking.objects.get(id=booking_id, deleted_at__isnull=True)
            
            # Check if payment already exists
            existing_payment = Payment.objects.filter(booking=booking).first()
            if existing_payment and existing_payment.status == 'succeeded':
                return Response(
                    {'error': 'Booking is already paid'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Create PaymentIntent
            payment_data = StripePaymentService.create_payment_intent(
                booking=booking,
                customer_email=customer_email
            )
            
            return Response({
                'payment_intent_id': payment_data['payment_intent_id'],
                'client_secret': payment_data['client_secret'],
                'amount_cents': booking.total_price_cents,
                'amount_dollars': booking.total_price_dollars,
                'booking_number': booking.booking_number
            })
            
        except Booking.DoesNotExist:
            return Response(
                {'error': 'Booking not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class PaymentStatusView(APIView):
    """Check payment status by booking number - no authentication required"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request, booking_number):
        try:
            booking = Booking.objects.get(booking_number=booking_number, deleted_at__isnull=True)
            payment = Payment.objects.filter(booking=booking).first()
            
            if not payment:
                return Response({
                    'booking_number': booking_number,
                    'payment_status': 'not_created',
                    'booking_status': booking.status
                })
            
            return Response({
                'booking_number': booking_number,
                'payment_status': payment.status,
                'booking_status': booking.status,
                'amount_dollars': payment.amount_dollars,
                'processed_at': payment.processed_at
            })
            
        except Booking.DoesNotExist:
            return Response(
                {'error': 'Booking not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )


@method_decorator(csrf_exempt, name='dispatch')
class StripeWebhookView(APIView):
    """Handle Stripe webhooks - FIXED to update booking status"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        # In production, you'd verify the webhook signature here
        # For development, we'll mock the webhook processing
        
        try:
            event_type = request.data.get('type', '')
            
            if event_type == 'payment_intent.succeeded':
                payment_intent = request.data.get('data', {}).get('object', {})
                payment_intent_id = payment_intent.get('id')
                
                if payment_intent_id:
                    # FIXED: Confirm payment AND update booking status
                    payment = StripePaymentService.confirm_payment(payment_intent_id)
                    
                    if payment and payment.booking:
                        # Update booking status from pending to paid
                        if payment.booking.status == 'pending':
                            payment.booking.status = 'paid'
                            payment.booking.save()
                            print(f"✅ Booking {payment.booking.booking_number} status updated to 'paid'")
                        
                        # AUTO-COMPLETE certain booking types (optional - you can remove this)
                        # For now, let's auto-complete all paid bookings to test the flow
                        if payment.booking.status == 'paid':
                            payment.booking.status = 'completed'
                            payment.booking.save()
                            
                            # Update customer stats when booking completed
                            if payment.booking.customer and hasattr(payment.booking.customer, 'customer_profile'):
                                payment.booking.customer.customer_profile.add_booking_stats(payment.booking.total_price_cents)
                                print(f"✅ Updated customer stats for {payment.booking.customer.get_full_name()}: +${payment.booking.total_price_dollars}")
                    
                    return Response({'status': 'success'})
            
            elif event_type == 'payment_intent.payment_failed':
                payment_intent = request.data.get('data', {}).get('object', {})
                payment_intent_id = payment_intent.get('id')
                
                if payment_intent_id:
                    try:
                        payment = Payment.objects.get(stripe_payment_intent_id=payment_intent_id)
                        payment.status = 'failed'
                        payment.failure_reason = payment_intent.get('last_payment_error', {}).get('message', 'Payment failed')
                        payment.save()
                        
                        # Update booking status back to pending
                        payment.booking.status = 'pending'
                        payment.booking.save()
                        
                    except Payment.DoesNotExist:
                        pass
            
            return Response({'status': 'received'})
            
        except Exception as e:
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_400_BAD_REQUEST
            )


class MockPaymentConfirmView(APIView):
    """FIXED Mock payment confirmation - now updates booking status and customer stats"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = PaymentConfirmSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        payment_intent_id = serializer.validated_data['payment_intent_id']
        status_value = serializer.validated_data['status']
        
        try:
            if status_value == 'succeeded':
                # Confirm payment (updates Payment record)
                payment = StripePaymentService.confirm_payment(payment_intent_id)
                
                if payment and payment.booking:
                    # FIXED: Update booking status from pending to paid
                    if payment.booking.status == 'pending':
                        payment.booking.status = 'paid'
                        payment.booking.save()
                        print(f"✅ Mock payment: Booking {payment.booking.booking_number} status updated to 'paid'")
                    
                    # AUTO-COMPLETE for testing (you can remove this later for manual staff completion)
                    if payment.booking.status == 'paid':
                        payment.booking.status = 'completed'
                        payment.booking.save()
                        print(f"✅ Mock payment: Booking {payment.booking.booking_number} auto-completed")
                        
                        # Update customer stats when booking completed
                        if payment.booking.customer and hasattr(payment.booking.customer, 'customer_profile'):
                            payment.booking.customer.customer_profile.add_booking_stats(payment.booking.total_price_cents)
                            print(f"✅ Mock payment: Updated customer stats for {payment.booking.customer.get_full_name()}: +${payment.booking.total_price_dollars}")
                
                return Response({
                    'message': 'Payment confirmed successfully',
                    'payment': PaymentSerializer(payment).data,
                    'booking_status': payment.booking.status if payment else 'unknown'
                })
            else:
                # Handle failed payment
                payment = Payment.objects.get(stripe_payment_intent_id=payment_intent_id)
                payment.status = 'failed'
                payment.failure_reason = serializer.validated_data.get('failure_reason', 'Payment failed')
                payment.save()
                
                # Keep booking as pending for failed payments
                payment.booking.status = 'pending'
                payment.booking.save()
                
                return Response({
                    'message': 'Payment marked as failed',
                    'payment': PaymentSerializer(payment).data,
                    'booking_status': payment.booking.status
                })
                
        except Payment.DoesNotExist:
            return Response(
                {'error': 'Payment not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


# Staff payment management views (existing functionality)
class PaymentListView(generics.ListAPIView):
    """List all payments - staff only"""
    serializer_class = PaymentSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        if not hasattr(self.request.user, 'staff_profile'):
            return Payment.objects.none()
        return Payment.objects.all().order_by('-created_at')


class RefundListView(generics.ListAPIView):
    """List all refunds - staff only"""
    serializer_class = RefundSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        if not hasattr(self.request.user, 'staff_profile'):
            return Refund.objects.none()
        return Refund.objects.all().order_by('-created_at')


class RefundCreateView(generics.CreateAPIView):
    """Create refund request - staff only"""
    serializer_class = RefundCreateSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def perform_create(self, serializer):
        if not hasattr(self.request.user, 'staff_profile'):
            raise permissions.PermissionDenied('Not a staff account')
        
        serializer.save(requested_by=self.request.user)


class PaymentConfirmView(APIView):
    """Confirm payment after Stripe processes it - called from frontend"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        payment_intent_id = request.data.get('payment_intent_id')
        
        if not payment_intent_id:
            return Response(
                {'error': 'payment_intent_id is required'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Service handles ALL logic: payment update, booking status, customer stats
            payment = StripePaymentService.confirm_payment(payment_intent_id)
            
            # Defensive check before accessing attributes
            if not payment:
                return Response(
                    {'error': 'Payment confirmation failed'}, 
                    status=status.HTTP_500_INTERNAL_SERVER_ERROR
                )
            
            return Response({
                'message': 'Payment confirmed successfully',
                'booking_status': payment.booking.status if payment.booking else None,
                'payment_status': payment.status
            })
            
        except Payment.DoesNotExist:
            return Response(
                {'error': 'Payment not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
```

# ==== apps/services/__init__.py ====

```python

```

# ==== apps/services/admin.py ====

```python
# backend/apps/services/admin.py
from django.contrib import admin
from django.utils.html import format_html
from .models import (
    MiniMovePackage, 
    OrganizingService,
    StandardDeliveryConfig, 
    SpecialtyItem, 
    SurchargeRule
)


@admin.register(MiniMovePackage)
class MiniMovePackageAdmin(admin.ModelAdmin):
    list_display = ('name', 'package_type', 'base_price_dollars', 'max_items', 'coi_included', 'is_most_popular', 'is_active', 'get_organizing_services')
    list_filter = ('package_type', 'coi_included', 'is_most_popular', 'is_active')
    search_fields = ('name', 'description')
    ordering = ('base_price_cents',)
    
    fieldsets = (
        ('Package Details', {
            'fields': ('package_type', 'name', 'description', 'is_most_popular', 'is_active')
        }),
        ('Pricing', {
            'fields': ('base_price_cents', 'coi_included', 'coi_fee_cents')
        }),
        ('Limits & Features', {
            'fields': ('max_items', 'max_weight_per_item_lbs', 'priority_scheduling', 'protective_wrapping')
        })
    )
    
    def get_organizing_services(self, obj):
        organizing_services = OrganizingService.objects.filter(
            mini_move_tier=obj.package_type,
            is_active=True
        )
        if organizing_services.exists():
            services = []
            for service in organizing_services:
                service_type = "📦 Packing" if service.is_packing_service else "📤 Unpacking"
                services.append(f"{service_type}: ${service.price_dollars}")
            return format_html("<br>".join(services))
        return "❌ No organizing services"
    get_organizing_services.short_description = 'Available Organizing Services'


@admin.register(OrganizingService)
class OrganizingServiceAdmin(admin.ModelAdmin):
    list_display = (
        'name', 
        'get_tier_badge', 
        'get_service_type_badge', 
        'price_dollars', 
        'duration_hours', 
        'organizer_count',
        'supplies_allowance_dollars',
        'is_active'
    )
    list_filter = ('mini_move_tier', 'is_packing_service', 'is_active')
    search_fields = ('name', 'description')
    ordering = ('mini_move_tier', 'is_packing_service', 'price_cents')
    
    fieldsets = (
        ('Service Details', {
            'fields': ('service_type', 'mini_move_tier', 'name', 'description', 'is_active')
        }),
        ('Pricing & Specs', {
            'fields': ('price_cents', 'duration_hours', 'organizer_count')
        }),
        ('Service Classification', {
            'fields': ('is_packing_service', 'supplies_allowance_cents')
        })
    )
    
    readonly_fields = ('service_type',)
    
    def get_tier_badge(self, obj):
        colors = {
            'petite': '#fbbf24',
            'standard': '#3b82f6',
            'full': '#10b981'
        }
        color = colors.get(obj.mini_move_tier, '#6b7280')
        return format_html(
            '<span style="background: {}; color: white; padding: 2px 8px; border-radius: 4px; font-weight: bold;">{}</span>',
            color,
            obj.mini_move_tier.title()
        )
    get_tier_badge.short_description = 'Move Tier'
    
    def get_service_type_badge(self, obj):
        if obj.is_packing_service:
            return format_html(
                '<span style="color: #059669;">📦 Packing</span>'
            )
        else:
            return format_html(
                '<span style="color: #0284c7;">📤 Unpacking</span>'
            )
    get_service_type_badge.short_description = 'Service Type'
    
    def save_model(self, request, obj, form, change):
        service_prefix = f"{obj.mini_move_tier}_"
        service_suffix = "packing" if obj.is_packing_service else "unpacking"
        obj.service_type = service_prefix + service_suffix
        super().save_model(request, obj, form, change)


@admin.register(StandardDeliveryConfig)
class StandardDeliveryConfigAdmin(admin.ModelAdmin):
    list_display = ('price_per_item_dollars', 'minimum_items', 'minimum_charge_dollars', 'same_day_flat_rate_dollars', 'is_active')
    fieldsets = (
        ('Per-Item Pricing', {
            'fields': ('price_per_item_cents', 'minimum_items', 'minimum_charge_cents')
        }),
        ('Same-Day Delivery', {
            'fields': ('same_day_flat_rate_cents',)
        }),
        ('Constraints', {
            'fields': ('max_weight_per_item_lbs', 'is_active')
        })
    )
    
    def same_day_flat_rate_dollars(self, obj):
        return f"${obj.same_day_flat_rate_cents / 100:.0f}"
    same_day_flat_rate_dollars.short_description = 'Same-Day Rate'


@admin.register(SpecialtyItem)
class SpecialtyItemAdmin(admin.ModelAdmin):
    list_display = ('name', 'item_type', 'price_dollars', 'special_handling', 'is_active')
    list_filter = ('item_type', 'special_handling', 'is_active')
    search_fields = ('name', 'description')
    
    fieldsets = (
        ('Item Details', {
            'fields': ('item_type', 'name', 'description', 'is_active')
        }),
        ('Pricing', {
            'fields': ('price_cents',)
        }),
        ('Requirements', {
            'fields': ('special_handling',)
        })
    )


@admin.register(SurchargeRule)
class SurchargeRuleAdmin(admin.ModelAdmin):
    list_display = ('name', 'surcharge_type', 'applies_to_service_type', 'calculation_type', 'get_surcharge_display', 'get_applies_to', 'is_active')
    list_filter = ('surcharge_type', 'applies_to_service_type', 'calculation_type', 'is_active', 'applies_saturday', 'applies_sunday')
    search_fields = ('name', 'description')
    
    fieldsets = (
        ('Rule Details', {
            'fields': ('surcharge_type', 'name', 'description', 'applies_to_service_type', 'is_active')
        }),
        ('Calculation', {
            'fields': ('calculation_type', 'percentage', 'fixed_amount_cents')
        }),
        ('Date Rules', {
            'fields': ('specific_date', 'applies_saturday', 'applies_sunday'),
            'description': 'Set specific date OR weekend days, not both'
        })
    )
    
    def get_surcharge_display(self, obj):
        if obj.calculation_type == 'percentage' and obj.percentage:
            return format_html('<span style="color: #059669; font-weight: bold;">{}%</span>', obj.percentage)
        elif obj.calculation_type == 'fixed_amount' and obj.fixed_amount_cents:
            return format_html('<span style="color: #dc2626; font-weight: bold;">${}</span>', obj.fixed_amount_cents / 100)
        return "❌ Not configured"
    get_surcharge_display.short_description = 'Surcharge Amount'
    
    def get_applies_to(self, obj):
        applies_to = []
        if obj.specific_date:
            applies_to.append(f"📅 {obj.specific_date}")
        if obj.applies_saturday:
            applies_to.append("🗓️ Saturdays")
        if obj.applies_sunday:
            applies_to.append("🗓️ Sundays")
        
        if applies_to:
            return format_html("<br>".join(applies_to))
        return "❓ No dates set"
    get_applies_to.short_description = 'Applies To'


admin.site.site_header = "ToteTaxi Admin"
admin.site.site_title = "ToteTaxi Admin Portal"
admin.site.index_title = "Welcome to ToteTaxi Administration"
```

# ==== apps/services/apps.py ====

```python
from django.apps import AppConfig


class ServicesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.services'
```

# ==== apps/services/management/__init__.py ====

```python

```

# ==== apps/services/management/commands/__init__.py ====

```python

```

# ==== apps/services/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.5 on 2025-09-02 20:54

import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='MiniMovePackage',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('package_type', models.CharField(choices=[('petite', 'Petite'), ('standard', 'Standard'), ('full', 'Full Move')], max_length=20, unique=True)),
                ('name', models.CharField(max_length=50)),
                ('description', models.TextField()),
                ('base_price_cents', models.PositiveBigIntegerField()),
                ('max_items', models.PositiveIntegerField(blank=True, help_text='Maximum items allowed (null = unlimited for Full Move)', null=True)),
                ('max_weight_per_item_lbs', models.PositiveIntegerField(default=50)),
                ('coi_included', models.BooleanField(default=False)),
                ('coi_fee_cents', models.PositiveBigIntegerField(default=5000, help_text='COI fee in cents if not included')),
                ('priority_scheduling', models.BooleanField(default=False)),
                ('protective_wrapping', models.BooleanField(default=False)),
                ('is_most_popular', models.BooleanField(default=False)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'services_mini_move_package',
                'ordering': ['base_price_cents'],
            },
        ),
        migrations.CreateModel(
            name='SpecialtyItem',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('item_type', models.CharField(choices=[('peloton', 'Peloton'), ('surfboard', 'Surfboard'), ('crib', 'Crib'), ('wardrobe_box', 'Wardrobe Box')], max_length=30, unique=True)),
                ('name', models.CharField(max_length=100)),
                ('description', models.TextField(blank=True)),
                ('price_cents', models.PositiveBigIntegerField()),
                ('requires_van_schedule', models.BooleanField(default=True, help_text='Can only be booked when van is already scheduled')),
                ('special_handling', models.BooleanField(default=True)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'services_specialty_item',
            },
        ),
        migrations.CreateModel(
            name='StandardDeliveryConfig',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('price_per_item_cents', models.PositiveBigIntegerField(default=9500, help_text='Price per item in cents')),
                ('minimum_items', models.PositiveIntegerField(default=3, help_text='Minimum number of items for delivery')),
                ('minimum_charge_cents', models.PositiveBigIntegerField(default=28500, help_text='Minimum delivery charge in cents')),
                ('same_day_flat_rate_cents', models.PositiveBigIntegerField(default=36000, help_text='Flat rate for same-day delivery')),
                ('max_weight_per_item_lbs', models.PositiveIntegerField(default=50, help_text='Maximum weight per item in pounds')),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'services_standard_delivery_config',
            },
        ),
        migrations.CreateModel(
            name='SurchargeRule',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('surcharge_type', models.CharField(choices=[('weekend', 'Weekend Surcharge'), ('holiday', 'Holiday Surcharge'), ('peak_date', 'Peak Date Surcharge')], max_length=20)),
                ('name', models.CharField(max_length=100)),
                ('description', models.TextField(blank=True)),
                ('calculation_type', models.CharField(choices=[('percentage', 'Percentage'), ('fixed_amount', 'Fixed Amount')], max_length=20)),
                ('percentage', models.DecimalField(blank=True, decimal_places=2, help_text='Percentage surcharge (e.g., 15.00 for 15%)', max_digits=5, null=True)),
                ('fixed_amount_cents', models.PositiveBigIntegerField(blank=True, help_text='Fixed surcharge amount in cents', null=True)),
                ('specific_date', models.DateField(blank=True, help_text='Specific date for peak date surcharges', null=True)),
                ('applies_saturday', models.BooleanField(default=False)),
                ('applies_sunday', models.BooleanField(default=False)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'services_surcharge_rule',
            },
        ),
        migrations.CreateModel(
            name='VanSchedule',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date', models.DateField(unique=True)),
                ('is_available', models.BooleanField(default=True, help_text='Van is available for pickups on this date')),
                ('mini_moves_booked', models.PositiveIntegerField(default=0)),
                ('specialty_items_booked', models.PositiveIntegerField(default=0)),
                ('max_capacity', models.PositiveIntegerField(default=10, help_text='Maximum bookings for this date')),
                ('notes', models.TextField(blank=True, help_text='Internal notes about availability or restrictions')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'services_van_schedule',
                'ordering': ['date'],
            },
        ),
    ]
```

# ==== apps/services/migrations/0002_organizingservice.py ====

```python
# Generated by Django 5.2.5 on 2025-09-08 21:42

import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('services', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='OrganizingService',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('service_type', models.CharField(choices=[('petite_packing', 'Petite Packing'), ('standard_packing', 'Standard Packing'), ('full_packing', 'Full Packing'), ('petite_unpacking', 'Petite Unpacking'), ('standard_unpacking', 'Standard Unpacking'), ('full_unpacking', 'Full Unpacking')], max_length=30, unique=True)),
                ('mini_move_tier', models.CharField(choices=[('petite', 'Petite'), ('standard', 'Standard'), ('full', 'Full')], max_length=20)),
                ('name', models.CharField(max_length=100)),
                ('description', models.TextField(blank=True)),
                ('price_cents', models.PositiveBigIntegerField()),
                ('duration_hours', models.PositiveIntegerField()),
                ('organizer_count', models.PositiveIntegerField()),
                ('supplies_allowance_cents', models.PositiveBigIntegerField(default=0, help_text='Supplies allowance in cents (packing services only)')),
                ('is_packing_service', models.BooleanField(help_text='True for packing services (with supplies), False for unpacking (organizing only)')),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'services_organizing_service',
                'ordering': ['mini_move_tier', 'is_packing_service', 'price_cents'],
            },
        ),
    ]
```

# ==== apps/services/migrations/0003_populate_organizing_services.py ====

```python
# Generated by Django 5.2.5 on 2025-09-08 21:42

from django.db import migrations


def populate_organizing_services(apps, schema_editor):
    """Populate organizing services with initial pricing data"""
    OrganizingService = apps.get_model('services', 'OrganizingService')
    
    # Create all 6 organizing services
    organizing_services = [
        # PETITE TIER
        {
            'service_type': 'petite_packing',
            'mini_move_tier': 'petite',
            'name': 'Petite Packing',
            'description': '1/2 day (up to 4 hours) with 2 organizers. Includes garment bags, moving bags + additional packing supplies upon request (up to $250).',
            'price_cents': 140000,  # $1,400
            'duration_hours': 4,
            'organizer_count': 2,
            'supplies_allowance_cents': 25000,  # $250
            'is_packing_service': True,
            'is_active': True,
        },
        {
            'service_type': 'petite_unpacking',
            'mini_move_tier': 'petite',
            'name': 'Petite Unpacking',
            'description': '1/2 day (up to 4 hours) with 2 organizers. Organizing light (no supplies).',
            'price_cents': 113000,  # $1,130
            'duration_hours': 4,
            'organizer_count': 2,
            'supplies_allowance_cents': 0,  # No supplies for unpacking
            'is_packing_service': False,
            'is_active': True,
        },
        
        # STANDARD TIER
        {
            'service_type': 'standard_packing',
            'mini_move_tier': 'standard',
            'name': 'Standard Packing',
            'description': '1 day (up to 8 hours) with 2 organizers. Includes garment bags, moving bags + additional packing supplies upon request (up to $250).',
            'price_cents': 253500,  # $2,535
            'duration_hours': 8,
            'organizer_count': 2,
            'supplies_allowance_cents': 25000,  # $250
            'is_packing_service': True,
            'is_active': True,
        },
        {
            'service_type': 'standard_unpacking',
            'mini_move_tier': 'standard',
            'name': 'Standard Unpacking',
            'description': '1 day (up to 8 hours) with 2 organizers. Organizing light (no supplies).',
            'price_cents': 226500,  # $2,265
            'duration_hours': 8,
            'organizer_count': 2,
            'supplies_allowance_cents': 0,  # No supplies for unpacking
            'is_packing_service': False,
            'is_active': True,
        },
        
        # FULL TIER
        {
            'service_type': 'full_packing',
            'mini_move_tier': 'full',
            'name': 'Full Packing',
            'description': '1 day (up to 8 hours) with 4 organizers. Includes garment bags, moving bags + additional packing supplies upon request (up to $500).',
            'price_cents': 507000,  # $5,070
            'duration_hours': 8,
            'organizer_count': 4,
            'supplies_allowance_cents': 50000,  # $500
            'is_packing_service': True,
            'is_active': True,
        },
        {
            'service_type': 'full_unpacking',
            'mini_move_tier': 'full',
            'name': 'Full Unpacking',
            'description': '1 day (up to 8 hours) with 4 organizers. Organizing light (no supplies).',
            'price_cents': 452500,  # $4,525
            'duration_hours': 8,
            'organizer_count': 4,
            'supplies_allowance_cents': 0,  # No supplies for unpacking
            'is_packing_service': False,
            'is_active': True,
        },
    ]
    
    # Create all organizing services
    for service_data in organizing_services:
        OrganizingService.objects.get_or_create(
            service_type=service_data['service_type'],
            defaults=service_data
        )


def reverse_populate_organizing_services(apps, schema_editor):
    """Remove organizing services data"""
    OrganizingService = apps.get_model('services', 'OrganizingService')
    OrganizingService.objects.all().delete()


class Migration(migrations.Migration):

    dependencies = [
        ('services', '0002_organizingservice'),
    ]

    operations = [
        migrations.RunPython(
            populate_organizing_services,
            reverse_populate_organizing_services
        ),
    ]
```

# ==== apps/services/migrations/0004_surchargerule_applies_to_service_type.py ====

```python
# Generated by Django 5.2.5 on 2025-09-20 16:20

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('services', '0003_populate_organizing_services'),
    ]

    operations = [
        migrations.AddField(
            model_name='surchargerule',
            name='applies_to_service_type',
            field=models.CharField(choices=[('all', 'All Services'), ('mini_move', 'Mini Moves Only'), ('standard_delivery', 'Standard Delivery Only'), ('specialty_item', 'Specialty Items Only')], default='all', help_text='Which service types this surcharge applies to', max_length=20),
        ),
    ]
```

# ==== apps/services/migrations/0005_remove_van_schedule.py ====

```python
# Generated by Django 5.2.5 on 2025-09-20 16:41

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('services', '0004_surchargerule_applies_to_service_type'),
    ]

    operations = [
        migrations.DeleteModel(
            name='VanSchedule',
        ),
    ]
```

# ==== apps/services/migrations/0006_remove_specialtyitem_requires_van_schedule.py ====

```python
# Generated by Django 5.2.5 on 2025-10-02 15:14

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('services', '0005_remove_van_schedule'),
    ]

    operations = [
        migrations.RemoveField(
            model_name='specialtyitem',
            name='requires_van_schedule',
        ),
    ]
```

# ==== apps/services/migrations/__init__.py ====

```python

```

# ==== apps/services/models.py ====

```python
# backend/apps/services/models.py
import uuid
from django.db import models
from django.utils import timezone
from decimal import Decimal


class MiniMovePackage(models.Model):
    """Mini Move service packages from homework: Petite, Standard, Full"""
    
    PACKAGE_TYPES = [
        ('petite', 'Petite'),
        ('standard', 'Standard'), 
        ('full', 'Full Move'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Package details
    package_type = models.CharField(max_length=20, choices=PACKAGE_TYPES, unique=True)
    name = models.CharField(max_length=50)
    description = models.TextField()
    
    # Pricing
    base_price_cents = models.PositiveBigIntegerField()
    
    # Item limits
    max_items = models.PositiveIntegerField(
        null=True, 
        blank=True,
        help_text="Maximum items allowed (null = unlimited for Full Move)"
    )
    max_weight_per_item_lbs = models.PositiveIntegerField(default=50)
    
    # COI handling
    coi_included = models.BooleanField(default=False)
    coi_fee_cents = models.PositiveBigIntegerField(
        default=5000,  # $50
        help_text="COI fee in cents if not included"
    )
    
    # Features
    priority_scheduling = models.BooleanField(default=False)
    protective_wrapping = models.BooleanField(default=False)
    
    # Marketing
    is_most_popular = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'services_mini_move_package'
        ordering = ['base_price_cents']
    
    def __str__(self):
        return f"{self.name} - ${self.base_price_dollars}"
    
    @property
    def base_price_dollars(self):
        return self.base_price_cents / 100
    
    @property
    def coi_fee_dollars(self):
        return self.coi_fee_cents / 100


class OrganizingService(models.Model):
    """Professional packing/unpacking services tied to Mini Move tiers"""
    
    ORGANIZING_TYPES = [
        ('petite_packing', 'Petite Packing'),
        ('standard_packing', 'Standard Packing'),
        ('full_packing', 'Full Packing'),
        ('petite_unpacking', 'Petite Unpacking'),
        ('standard_unpacking', 'Standard Unpacking'),
        ('full_unpacking', 'Full Unpacking'),
    ]
    
    MINI_MOVE_TIERS = [
        ('petite', 'Petite'),
        ('standard', 'Standard'),
        ('full', 'Full'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Service details
    service_type = models.CharField(max_length=30, choices=ORGANIZING_TYPES, unique=True)
    mini_move_tier = models.CharField(max_length=20, choices=MINI_MOVE_TIERS)
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    
    # Pricing
    price_cents = models.PositiveBigIntegerField()
    
    # Service specs
    duration_hours = models.PositiveIntegerField()
    organizer_count = models.PositiveIntegerField()
    supplies_allowance_cents = models.PositiveBigIntegerField(
        default=0,
        help_text="Supplies allowance in cents (packing services only)"
    )
    
    # Service type classification
    is_packing_service = models.BooleanField(
        help_text="True for packing services (with supplies), False for unpacking (organizing only)"
    )
    
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'services_organizing_service'
        ordering = ['mini_move_tier', 'is_packing_service', 'price_cents']
    
    def __str__(self):
        return f"{self.name} - ${self.price_dollars}"
    
    @property
    def price_dollars(self):
        return self.price_cents / 100
    
    @property
    def supplies_allowance_dollars(self):
        return self.supplies_allowance_cents / 100
    
    def can_be_added_to_mini_move(self, mini_move_package_type):
        """Check if this organizing service can be added to a specific mini move tier"""
        return self.mini_move_tier == mini_move_package_type


class StandardDeliveryConfig(models.Model):
    """Configuration for Standard Delivery pricing from homework"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Per-item pricing
    price_per_item_cents = models.PositiveBigIntegerField(
        default=9500,  # $95
        help_text="Price per item in cents"
    )
    
    # Minimums
    minimum_items = models.PositiveIntegerField(
        default=3,
        help_text="Minimum number of items for delivery"
    )
    minimum_charge_cents = models.PositiveBigIntegerField(
        default=28500,  # $285
        help_text="Minimum delivery charge in cents"
    )
    
    # Same-day delivery
    same_day_flat_rate_cents = models.PositiveBigIntegerField(
        default=36000,  # $360
        help_text="Flat rate for same-day delivery"
    )
    
    # Item constraints
    max_weight_per_item_lbs = models.PositiveIntegerField(
        default=50,
        help_text="Maximum weight per item in pounds"
    )
    
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'services_standard_delivery_config'
    
    def __str__(self):
        return f"Standard Delivery - ${self.price_per_item_dollars}/item"
    
    @property
    def price_per_item_dollars(self):
        return self.price_per_item_cents / 100
    
    @property
    def minimum_charge_dollars(self):
        return self.minimum_charge_cents / 100
    
    def calculate_total(self, item_count, is_same_day=False):
        """Calculate total for standard delivery"""
        # FIXED: Calculate base delivery cost first
        item_total = self.price_per_item_cents * item_count
        base_cost = max(item_total, self.minimum_charge_cents)
        
        # FIXED: ADD same-day surcharge on top of base cost
        if is_same_day:
            return base_cost + self.same_day_flat_rate_cents
        
        return base_cost

class SpecialtyItem(models.Model):
    """Specialty items from homework: Peloton, Surfboard, Crib, Wardrobe Box"""
    
    ITEM_TYPES = [
        ('peloton', 'Peloton'),
        ('surfboard', 'Surfboard'),
        ('crib', 'Crib'),
        ('wardrobe_box', 'Wardrobe Box'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Item details
    item_type = models.CharField(max_length=30, choices=ITEM_TYPES, unique=True)
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    
    # Pricing
    price_cents = models.PositiveBigIntegerField()
    
    # Requirements
    special_handling = models.BooleanField(default=True)
    
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'services_specialty_item'
    
    def __str__(self):
        return f"{self.name} - ${self.price_dollars}"
    
    @property
    def price_dollars(self):
        return self.price_cents / 100


class SurchargeRule(models.Model):
    """Weekend, holiday, and peak date surcharges from homework"""
    
    SURCHARGE_TYPES = [
        ('weekend', 'Weekend Surcharge'),
        ('holiday', 'Holiday Surcharge'),
        ('peak_date', 'Peak Date Surcharge'),
    ]
    
    CALCULATION_TYPES = [
        ('percentage', 'Percentage'),
        ('fixed_amount', 'Fixed Amount'),
    ]
    
    SERVICE_TYPE_CHOICES = [
        ('all', 'All Services'),
        ('mini_move', 'Mini Moves Only'),
        ('standard_delivery', 'Standard Delivery Only'),
        ('specialty_item', 'Specialty Items Only'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Surcharge details
    surcharge_type = models.CharField(max_length=20, choices=SURCHARGE_TYPES)
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    
    # Service type filter
    applies_to_service_type = models.CharField(
        max_length=20,
        choices=SERVICE_TYPE_CHOICES,
        default='all',
        help_text='Which service types this surcharge applies to'
    )
    
    # Calculation
    calculation_type = models.CharField(max_length=20, choices=CALCULATION_TYPES)
    percentage = models.DecimalField(
        max_digits=5, 
        decimal_places=2, 
        null=True, 
        blank=True,
        help_text="Percentage surcharge (e.g., 15.00 for 15%)"
    )
    fixed_amount_cents = models.PositiveBigIntegerField(
        null=True,
        blank=True,
        help_text="Fixed surcharge amount in cents"
    )
    
    # Date rules (for specific dates like Sept 1)
    specific_date = models.DateField(
        null=True,
        blank=True,
        help_text="Specific date for peak date surcharges"
    )
    
    # Day of week rules (for weekend surcharges)
    applies_saturday = models.BooleanField(default=False)
    applies_sunday = models.BooleanField(default=False)
    
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'services_surcharge_rule'
    
    def __str__(self):
        return self.name
    
    def calculate_surcharge(self, base_amount_cents, booking_date, service_type=None):
        """Calculate surcharge for given base amount, date, and service type"""
        if not self.is_active:
            return 0
        
        if not self.applies_to_date(booking_date):
            return 0
        
        if self.applies_to_service_type != 'all':
            if service_type != self.applies_to_service_type:
                return 0
        
        if self.calculation_type == 'percentage' and self.percentage:
            return int(base_amount_cents * (self.percentage / 100))
        elif self.calculation_type == 'fixed_amount' and self.fixed_amount_cents:
            return self.fixed_amount_cents
        
        return 0
    
    def applies_to_date(self, booking_date):
        """Check if surcharge rule applies to given date"""
        if self.specific_date and self.specific_date == booking_date:
            return True
        
        weekday = booking_date.weekday()
        if weekday == 5 and self.applies_saturday:
            return True
        if weekday == 6 and self.applies_sunday:
            return True
        
        return False
```

# ==== apps/services/serializers.py ====

```python
# backend/apps/services/serializers.py
from rest_framework import serializers
from .models import (
    MiniMovePackage, 
    OrganizingService, 
    StandardDeliveryConfig, 
    SpecialtyItem, 
    SurchargeRule
)


class MiniMovePackageSerializer(serializers.ModelSerializer):
    base_price_dollars = serializers.ReadOnlyField()
    coi_fee_dollars = serializers.ReadOnlyField()
    
    class Meta:
        model = MiniMovePackage
        fields = (
            'id', 'package_type', 'name', 'description',
            'base_price_dollars', 'max_items', 'coi_included', 'coi_fee_dollars',
            'is_most_popular', 'priority_scheduling', 'protective_wrapping'
        )


class OrganizingServiceSerializer(serializers.ModelSerializer):
    price_dollars = serializers.ReadOnlyField()
    supplies_allowance_dollars = serializers.ReadOnlyField()
    
    class Meta:
        model = OrganizingService
        fields = (
            'id', 'service_type', 'mini_move_tier', 'name', 'description',
            'price_dollars', 'duration_hours', 'organizer_count',
            'supplies_allowance_dollars', 'is_packing_service'
        )


class SpecialtyItemSerializer(serializers.ModelSerializer):
    price_dollars = serializers.ReadOnlyField()
    
    class Meta:
        model = SpecialtyItem
        fields = (
            'id', 'item_type', 'name', 'description', 'price_dollars',
            'special_handling'
        )


class StandardDeliveryConfigSerializer(serializers.ModelSerializer):
    price_per_item_dollars = serializers.ReadOnlyField()
    minimum_charge_dollars = serializers.ReadOnlyField()
    same_day_flat_rate_dollars = serializers.SerializerMethodField()
    
    class Meta:
        model = StandardDeliveryConfig
        fields = (
            'price_per_item_dollars', 'minimum_items', 'minimum_charge_dollars',
            'same_day_flat_rate_dollars', 'max_weight_per_item_lbs'
        )
    
    def get_same_day_flat_rate_dollars(self, obj):
        return obj.same_day_flat_rate_cents / 100


class SurchargeRuleSerializer(serializers.ModelSerializer):
    fixed_amount_dollars = serializers.SerializerMethodField()
    
    class Meta:
        model = SurchargeRule
        fields = (
            'id', 'surcharge_type', 'name', 'description',
            'calculation_type', 'percentage', 'fixed_amount_dollars',
            'specific_date', 'applies_saturday', 'applies_sunday'
        )
    
    def get_fixed_amount_dollars(self, obj):
        return obj.fixed_amount_cents / 100 if obj.fixed_amount_cents else None


class ServiceCatalogSerializer(serializers.Serializer):
    """Complete service catalog with all available services and organizing options"""
    
    mini_move_packages = MiniMovePackageSerializer(many=True, read_only=True)
    organizing_services = OrganizingServiceSerializer(many=True, read_only=True)
    standard_delivery = StandardDeliveryConfigSerializer(read_only=True)
    specialty_items = SpecialtyItemSerializer(many=True, read_only=True)
    
    surcharge_rules = SurchargeRuleSerializer(many=True, read_only=True, required=False)


class OrganizingServicesByTierSerializer(serializers.Serializer):
    """Organizing services grouped by Mini Move tier for easy frontend consumption"""
    
    def to_representation(self, instance):
        organizing_services = OrganizingService.objects.filter(is_active=True)
        
        result = {}
        for tier in ['petite', 'standard', 'full']:
            tier_services = organizing_services.filter(mini_move_tier=tier)
            packing_service = tier_services.filter(is_packing_service=True).first()
            unpacking_service = tier_services.filter(is_packing_service=False).first()
            
            result[tier] = {
                'packing': OrganizingServiceSerializer(packing_service).data if packing_service else None,
                'unpacking': OrganizingServiceSerializer(unpacking_service).data if unpacking_service else None
            }
        
        return result


class MiniMoveWithOrganizingSerializer(serializers.Serializer):
    """Mini Move packages with their available organizing services"""
    
    def to_representation(self, instance):
        packages = MiniMovePackage.objects.filter(is_active=True).order_by('base_price_cents')
        
        result = []
        for package in packages:
            organizing_services = OrganizingService.objects.filter(
                mini_move_tier=package.package_type,
                is_active=True
            )
            
            packing_service = organizing_services.filter(is_packing_service=True).first()
            unpacking_service = organizing_services.filter(is_packing_service=False).first()
            
            package_data = MiniMovePackageSerializer(package).data
            package_data['organizing_options'] = {
                'packing': OrganizingServiceSerializer(packing_service).data if packing_service else None,
                'unpacking': OrganizingServiceSerializer(unpacking_service).data if unpacking_service else None
            }
            
            result.append(package_data)
        
        return result
```

# ==== apps/services/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/services/views.py ====

```python
# services/views.py
from django.shortcuts import render

# Create your views here.
```

# ========================= SCRIPTS & UTILITIES =========================


# ==== scripts/back_export.py ====

```python
#!/usr/bin/env python3
"""
ToteTaxi Backend Export - Code Files Only
"""
import os
from pathlib import Path
from datetime import datetime

def get_file_content(file_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        return f"# Error reading file: {e}"

def should_include_file(file_path, base_dir):
    """Smart file inclusion rules for ToteTaxi Backend - Code Only"""
    rel_path = file_path.relative_to(base_dir)
    path_str = str(rel_path)
    
    # Skip patterns - SECURITY: Handle .env files separately
    skip_patterns = [
        '__pycache__', '.pyc', '.git/', '.pytest_cache/', 'htmlcov/',
        'staticfiles/', 'media/', 'logs/', '.coverage', 'db.sqlite3',
        'back_export.txt', 'totetaxi_backend_snapshot.txt',
        '.DS_Store', '*.swp', '*.swo',
        'README.md', 'CHANGELOG.md'  # Skip documentation files
    ]
    
    if any(pattern in path_str for pattern in skip_patterns):
        return False
    
    # SECURITY: Skip .env files (contain secrets)
    if file_path.name.startswith('.env'):
        return False
    
    # Include patterns - Code files only
    include_extensions = {'.py', '.txt', '.yml', '.yaml', '.toml', '.sh', '.ini', '.conf'}
    include_files = {
        'Dockerfile', 'Dockerfile.dev', '.dockerignore', '.gitignore', 
        'manage.py', 'docker-compose.yml', 'docker-compose.prod.yml',
        'gunicorn.conf.py', 'pytest.ini', 'requirements.txt'
    }
    
    return (
        file_path.suffix in include_extensions or 
        file_path.name in include_files
    )

def categorize_file(file_path, base_dir):
    """Auto-categorize files for ToteTaxi structure"""
    rel_path = file_path.relative_to(base_dir)
    path_str = str(rel_path)
    
    # Configuration files (root level)
    if (rel_path.parent == Path('.') or 
        file_path.name in ['manage.py', 'requirements.txt', 'gunicorn.conf.py', 'pytest.ini']):
        return 'config'
    
    # ToteTaxi Django apps
    totetaxi_apps = [
        'accounts/', 'bookings/', 'crm/', 'customers/', 'documents/', 
        'logistics/', 'notifications/', 'payments/', 'services/'
    ]
    if any(f'apps/{app}' in path_str for app in totetaxi_apps):
        return 'apps'
    
    # Django project settings (config/ directory)
    if 'config/' in path_str:
        return 'project'
    
    # Scripts directory
    if 'scripts/' in path_str:
        return 'scripts'
    
    # Everything else
    return 'other'

def main():
    backend_dir = Path(__file__).parent.parent
    output_file = backend_dir / 'scripts' / 'back_export.txt'
    
    print(f"🔍 Auto-discovering ToteTaxi backend files in: {backend_dir}")
    
    # Auto-discover all relevant files
    all_files = []
    for file_path in backend_dir.rglob('*'):
        if file_path.is_file() and should_include_file(file_path, backend_dir):
            all_files.append(file_path)
    
    # Categorize files
    categories = {
        'config': [],
        'project': [],
        'apps': [],
        'scripts': [],
        'other': []
    }
    
    for file_path in all_files:
        category = categorize_file(file_path, backend_dir)
        categories[category].append(file_path)
    
    # Sort within categories
    for category in categories:
        categories[category].sort()
    
    print(f"📊 Found {len(all_files)} files:")
    for cat, files in categories.items():
        if files:
            print(f"  - {cat}: {len(files)} files")
    
    # Generate snapshot
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# TOTETAXI - BACKEND CODE SNAPSHOT\n")
        f.write("# AUTO-GENERATED - CODE FILES ONLY\n")
        f.write(f"# Created: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"# Total files: {len(all_files)}\n")
        f.write("# 🔒 SECURITY: .env files excluded (contain secrets)\n")
        f.write("# 📋 INCLUDES: All Django apps, migrations, configuration\n")
        f.write("# Apps: accounts (STAFF), bookings, crm, customers, documents, logistics, notifications, payments, services\n")
        f.write("# Tech Stack: Django 5.2.5, DRF 3.16.1, PostgreSQL, Redis, Celery\n")
        f.write("# Integration: S3 storage, SES email, mocked Stripe/Onfleet\n\n\n")
        
        # Output by category
        section_names = {
            'config': 'CONFIGURATION & ROOT FILES',
            'project': 'DJANGO PROJECT SETTINGS (config/)',
            'apps': 'DJANGO APPLICATIONS (apps/)',
            'scripts': 'SCRIPTS & UTILITIES',
            'other': 'OTHER FILES'
        }
        
        for category, section_name in section_names.items():
            if categories[category]:
                f.write("# " + "="*25 + f" {section_name} " + "="*25 + "\n\n\n")
                
                for file_path in categories[category]:
                    rel_path = file_path.relative_to(backend_dir)
                    f.write(f"# ==== {rel_path} ====\n\n")
                    
                    # Smart syntax highlighting
                    if file_path.suffix == '.py':
                        f.write("```python\n")
                    elif file_path.suffix in ['.yml', '.yaml']:
                        f.write("```yaml\n")
                    elif file_path.suffix == '.toml':
                        f.write("```toml\n")
                    elif file_path.suffix == '.sh':
                        f.write("```bash\n")
                    elif file_path.name in ['Dockerfile', 'Dockerfile.dev']:
                        f.write("```dockerfile\n")
                    elif file_path.suffix == '.ini':
                        f.write("```ini\n")
                    else:
                        f.write("```\n")
                    
                    content = get_file_content(file_path)
                    f.write(content)
                    if not content.endswith('\n'):
                        f.write('\n')
                    f.write("```\n\n")
    
    print(f"✅ Auto-generated ToteTaxi backend snapshot: {output_file}")
    print("🔒 SECURITY: .env files excluded (contain secrets)")
    print("📋 INCLUDES: All 9 Django apps with migrations")
    print("🏗️  STRUCTURE: accounts (staff), bookings, crm, customers, documents, logistics, notifications, payments, services")
    print("🐳 DOCKER: Configuration and compose files included")
    print("📁 CODE ONLY: Documentation files excluded")

if __name__ == "__main__":
    main()
```

# ==== scripts/entrypoint.sh ====

```bash
#!/bin/bash
set -e

echo "Starting ToteTaxi Backend..."

# CRITICAL FIX: Unset docker-compose DB variables on Fly.io
unset DB_HOST
unset DB_NAME
unset DB_USER
unset DB_PASSWORD
unset DB_PORT

# Wait for database if DB_HOST is set (won't happen after unset)
if [ -n "$DB_HOST" ]; then
    echo "Waiting for postgres at $DB_HOST:${DB_PORT:-5432}..."
    while ! pg_isready -h "$DB_HOST" -p "${DB_PORT:-5432}" -U "${DB_USER:-postgres}"; do
      sleep 1
    done
    echo "PostgreSQL is ready!"
fi

# Run migrations
echo "Running database migrations..."
python manage.py migrate --no-input

# Collect static files (in case not done in Dockerfile)
echo "Collecting static files..."
python manage.py collectstatic --no-input --clear || true

# Create cache table if needed
python manage.py createcachetable || true

# Create superuser if specified (optional)
if [ -n "$DJANGO_SUPERUSER_EMAIL" ] && [ -n "$DJANGO_SUPERUSER_PASSWORD" ]; then
    echo "Creating superuser..."
    python manage.py shell -c "
from django.contrib.auth import get_user_model
User = get_user_model()
if not User.objects.filter(email='$DJANGO_SUPERUSER_EMAIL').exists():
    User.objects.create_superuser('$DJANGO_SUPERUSER_EMAIL', '$DJANGO_SUPERUSER_EMAIL', '$DJANGO_SUPERUSER_PASSWORD')
    print('Superuser created')
else:
    print('Superuser already exists')
" || true
fi

echo "Starting application..."
exec "$@"
```

# ========================= OTHER FILES =========================


# ==== apps/__init__.py ====

```python

```

