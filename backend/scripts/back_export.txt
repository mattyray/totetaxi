# TOTETAXI - BACKEND CODE SNAPSHOT
# AUTO-GENERATED - SECURE VERSION
# Created: 2025-09-02 19:46:23
# Total files: 99
# ðŸ”’ SECURITY: .env files excluded (contain secrets)
# ðŸ“‹ INCLUDES: All Django apps, migrations, configuration
# Apps: accounts (STAFF), bookings, crm, customers (NEW), documents, logistics, notifications, payments, services
# NEW FEATURES: Customer authentication, guest checkout, customer dashboard
# Tech Stack: Django 5.2.5, DRF 3.16.1, PostgreSQL, Redis, Celery
# Integration: S3 storage, SES email, mocked Stripe/Onfleet


# ========================= CONFIGURATION & ROOT FILES =========================


# ==== .dockerignore ====

```
# Git
.git
.gitignore

# Docker
.docker
Dockerfile
docker-compose*

# Python
__pycache__
*.pyc
*.pyo
*.pyd
.Python
venv/
.venv/
pip-log.txt
pip-delete-this-directory.txt
.tox
.coverage
.coverage.*
.pytest_cache
.cache
htmlcov
.mypy_cache
.dmypy.json
dmypy.json

# IDEs
.vscode
.idea
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs
*.log
npm-debug.log*

# Environment
.env
.env.local
.env.development
.env.production

# Media files
media/

# Node (if any)
node_modules
npm-debug.log
```

# ==== Dockerfile ====

```dockerfile
FROM python:3.11-slim

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1
ENV PYTHONPATH /app

# Set work directory
WORKDIR /app

# Install system dependencies
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
        postgresql-client \
        build-essential \
        libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt /app/
RUN pip install --no-cache-dir -r requirements.txt

# Copy project
COPY . /app/

# Create directories for logs and static files
RUN mkdir -p /app/logs /app/staticfiles /app/media

# Make entrypoint executable
COPY scripts/entrypoint.sh /app/scripts/entrypoint.sh
RUN chmod +x /app/scripts/entrypoint.sh

# Expose port
EXPOSE 8000

# Run entrypoint
ENTRYPOINT ["/app/scripts/entrypoint.sh"]
```

# ==== README.md ====

```markdown

---


# ==== docker-compose.yml ====

```yaml
services:
  # PostgreSQL Database - PORT 5435
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: totetaxi
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5435:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis for Celery - PORT 6382
  redis:
    image: redis:7-alpine
    ports:
      - "6382:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Django Backend - PORT 8005
  web:
    build: .
    command: python manage.py runserver 0.0.0.0:8000
    volumes:
      - .:/app
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    ports:
      - "8005:8000"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/totetaxi
      - REDIS_URL=redis://redis:6379/0

  # Celery Worker
  celery:
    build: .
    command: celery -A config worker -l info
    volumes:
      - .:/app
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/totetaxi
      - REDIS_URL=redis://redis:6379/0

  # Celery Beat Scheduler
  celery-beat:
    build: .
    command: celery -A config beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler
    volumes:
      - .:/app
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/totetaxi
      - REDIS_URL=redis://redis:6379/0

volumes:
  postgres_data:
  static_volume:
  media_volume:
  redis_data:
```

# ==== gunicorn.conf.py ====

```python
import multiprocessing

# Server socket
bind = "0.0.0.0:8000"
backlog = 2048

# Worker processes
workers = multiprocessing.cpu_count() * 2 + 1
worker_class = "sync"
worker_connections = 1000
timeout = 30
keepalive = 2
max_requests = 1000
max_requests_jitter = 100

# Logging
accesslog = "-"
errorlog = "-"
loglevel = "info"

# Process naming
proc_name = "totetaxi"

# Server mechanics
preload_app = True
pidfile = "/tmp/gunicorn.pid"
```

# ==== manage.py ====

```python
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
```

# ==== pyproject.toml ====

```toml
[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "totetaxi-backend"
version = "0.1.0"
description = "ToteTaxi luxury delivery service backend API"
requires-python = ">=3.11"

[tool.black]
line-length = 88
target-version = ['py311']
include = '\.pyi?$'
extend-exclude = '''
/(
  migrations
)/
'''

[tool.isort]
profile = "black"
multi_line_output = 3
line_length = 88
skip_glob = ["**/migrations/*.py"]

[tool.coverage.run]
source = "."
omit = [
    "*/migrations/*",
    "*/venv/*",
    "*/tests/*",
    "manage.py",
    "config/wsgi.py",
    "config/asgi.py",
]
```

# ==== pytest.ini ====

```ini
[tool:pytest]
DJANGO_SETTINGS_MODULE = config.settings.testing
python_files = tests.py test_*.py *_tests.py
python_classes = Test*
python_functions = test_*
addopts = --tb=short --strict-markers --disable-warnings
markers =
    slow: marks tests as slow (deselect with '-m "not slow"')
    integration: marks tests as integration tests
```

# ==== requirements.txt ====

```
# Django Core - Latest LTS with full compatibility
Django==5.2.5
djangorestframework==3.16.1
django-cors-headers==4.6.0
django-environ==0.11.2

# Database
psycopg2-binary==2.9.9
dj-database-url==2.1.0

# Authentication & Security
djangorestframework-simplejwt==5.3.0
django-allauth==0.63.6

# API Documentation
drf-yasg==1.21.7

# Background Jobs - Latest stable versions
celery==5.5.3
redis==5.1.1
django-celery-beat==2.8.1

# File Storage
boto3==1.35.19
django-storages==1.14.4
Pillow==10.4.0

# Integrations - Latest versions
stripe==12.4.0
requests==2.32.3

# Monitoring & Logging
sentry-sdk==2.13.0

# Development
django-debug-toolbar==4.4.6
django-extensions==3.2.3

# Testing
pytest==8.3.2
pytest-django==4.9.0
pytest-cov==5.0.0
factory-boy==3.3.0

# Production Server
gunicorn==23.0.0
whitenoise==6.7.0
```

# ==== staff_cookies.txt ====

```
# Netscape HTTP Cookie File
# https://curl.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

#HttpOnly_localhost	FALSE	/	FALSE	1758066188	sessionid	fwh9hh6geqv27ua54oalc21vmmdbzz6a
localhost	FALSE	/	FALSE	1788306188	csrftoken	9q6dfu6t1kUNO5j926PupDyEP2bSl9gP
```

# ========================= DJANGO PROJECT SETTINGS (config/) =========================


# ==== config/__init__.py ====

```python
# This will make sure the app is always imported when
# Django starts so that shared_task will use this app.
from .celery import app as celery_app

__all__ = ('celery_app',)
```

# ==== config/asgi.py ====

```python
"""
ASGI config for config project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_asgi_application()
```

# ==== config/celery.py ====

```python
import os
from celery import Celery

# Set the default Django settings module for the 'celery' program.
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

app = Celery('totetaxi')

# Using a string here means the worker doesn't have to serialize
# the configuration object to child processes.
app.config_from_object('django.conf:settings', namespace='CELERY')

# Load task modules from all registered Django apps.
app.autodiscover_tasks()

@app.task(bind=True, ignore_result=True)
def debug_task(self):
    print(f'Request: {self.request!r}')
```

# ==== config/settings.py ====

```python
import os
import environ
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Environment variables
env = environ.Env(
    DEBUG=(bool, True),
)

# Take environment variables from .env file
environ.Env.read_env(BASE_DIR / '.env')

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = env('SECRET_KEY', default='django-insecure-change-me-in-production')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = env('DEBUG', default=True)

ALLOWED_HOSTS = env.list('ALLOWED_HOSTS', default=['localhost', '127.0.0.1', '0.0.0.0'])

# Application definition
DJANGO_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

THIRD_PARTY_APPS = [
    'rest_framework',
    'corsheaders',
    'django_celery_beat',
    'drf_yasg',
]

# LOCAL_APPS - All ToteTaxi apps
LOCAL_APPS = [
    'apps.accounts',
    'apps.bookings',
    'apps.services', 
    'apps.payments',
    'apps.logistics',
    'apps.documents',
    'apps.notifications',
    'apps.crm',
    'apps.customers',
]

INSTALLED_APPS = DJANGO_APPS + THIRD_PARTY_APPS + LOCAL_APPS

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'

# Database
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': env('DB_NAME', default='totetaxi'),
        'USER': env('DB_USER', default='postgres'),
        'PASSWORD': env('DB_PASSWORD', default='postgres'),
        'HOST': env('DB_HOST', default='db'),
        'PORT': env('DB_PORT', default='5432'),
    }
}

# Alternative: use DATABASE_URL if provided
database_url = env('DATABASE_URL', default=None)
if database_url:
    import dj_database_url
    DATABASES['default'] = dj_database_url.parse(database_url)

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'America/New_York'
USE_I18N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
STATIC_URL = '/static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'

# Create static directory if it doesn't exist
STATICFILES_DIRS = []
if (BASE_DIR / 'static').exists():
    STATICFILES_DIRS.append(BASE_DIR / 'static')

# Media files
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Django REST Framework
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.BrowsableAPIRenderer',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 20,
}

# CSRF Settings - Enhanced Security
CSRF_COOKIE_SECURE = not DEBUG
CSRF_COOKIE_HTTPONLY = False  # Allow JavaScript access for API calls
CSRF_COOKIE_SAMESITE = 'Lax'
CSRF_TRUSTED_ORIGINS = env.list('CSRF_TRUSTED_ORIGINS', default=[
    'http://localhost:3000',
    'http://127.0.0.1:3000',
])

# Session Settings
SESSION_COOKIE_SECURE = not DEBUG
SESSION_COOKIE_SAMESITE = 'Lax'

# CORS settings
CORS_ALLOWED_ORIGINS = env.list('CORS_ALLOWED_ORIGINS', default=[
    'http://localhost:3000',
    'http://127.0.0.1:3000',
])

CORS_ALLOW_CREDENTIALS = True
CORS_ALLOW_HEADERS = [
    'accept',
    'accept-encoding',
    'authorization',
    'content-type',
    'dnt',
    'origin',
    'user-agent',
    'x-csrftoken',
    'x-requested-with',
]

# Celery Configuration
CELERY_BROKER_URL = env('REDIS_URL', default='redis://redis:6379/0')
CELERY_RESULT_BACKEND = env('REDIS_URL', default='redis://redis:6379/0')
CELERY_ACCEPT_CONTENT = ['application/json']
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TIMEZONE = TIME_ZONE

# Security Settings
if not DEBUG:
    SECURE_BROWSER_XSS_FILTER = True
    SECURE_CONTENT_TYPE_NOSNIFF = True
    SECURE_HSTS_INCLUDE_SUBDOMAINS = True
    SECURE_HSTS_SECONDS = 31536000
    SECURE_REDIRECT_EXEMPT = []
    SECURE_SSL_REDIRECT = True
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True

# Logging
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'INFO',
    },
}
```

# ==== config/urls.py ====

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/customer/', include('apps.customers.urls')),
    path('api/public/', include('apps.bookings.urls')),
    path('api/payments/', include('apps.payments.urls')),
    path('api/staff/', include('apps.accounts.urls')),  # Add this line
]
```

# ==== config/wsgi.py ====

```python
"""
WSGI config for config project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_wsgi_application()
```

# ========================= DJANGO APPLICATIONS (apps/) - Including NEW customers/ app =========================


# ==== apps/accounts/__init__.py ====

```python

```

# ==== apps/accounts/admin.py ====

```python
from django.contrib import admin

# Register your models here.
```

# ==== apps/accounts/apps.py ====

```python
from django.apps import AppConfig

class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.accounts'  # Changed from 'accounts' to 'apps.accounts'
```

# ==== apps/accounts/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.5 on 2025-09-02 20:54

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='StaffProfile',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('role', models.CharField(choices=[('staff', 'Staff'), ('admin', 'Admin')], default='staff', max_length=20)),
                ('department', models.CharField(blank=True, max_length=50)),
                ('hire_date', models.DateField(blank=True, null=True)),
                ('phone', models.CharField(blank=True, max_length=20)),
                ('last_login_ip', models.GenericIPAddressField(blank=True, null=True)),
                ('login_attempts', models.PositiveIntegerField(default=0)),
                ('account_locked_until', models.DateTimeField(blank=True, null=True)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='staff_profile', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Staff Profile',
                'verbose_name_plural': 'Staff Profiles',
                'db_table': 'accounts_staff_profile',
            },
        ),
        migrations.CreateModel(
            name='StaffAction',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('action_type', models.CharField(choices=[('login', 'Login'), ('logout', 'Logout'), ('view_customer', 'View Customer'), ('modify_booking', 'Modify Booking'), ('process_refund', 'Process Refund'), ('approve_refund', 'Approve Refund'), ('upload_document', 'Upload Document'), ('send_notification', 'Send Notification'), ('export_data', 'Export Data')], max_length=30)),
                ('description', models.TextField()),
                ('ip_address', models.GenericIPAddressField()),
                ('user_agent', models.TextField(blank=True)),
                ('customer_id', models.UUIDField(blank=True, help_text='Customer affected by action', null=True)),
                ('booking_id', models.UUIDField(blank=True, help_text='Booking affected by action', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('staff_user', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='staff_actions', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'accounts_staff_action',
                'ordering': ['-created_at'],
                'indexes': [models.Index(fields=['staff_user', '-created_at'], name='accounts_st_staff_u_7518f9_idx'), models.Index(fields=['action_type', '-created_at'], name='accounts_st_action__992fd0_idx'), models.Index(fields=['customer_id'], name='accounts_st_custome_407eb4_idx'), models.Index(fields=['booking_id'], name='accounts_st_booking_824dc4_idx')],
            },
        ),
    ]
```

# ==== apps/accounts/migrations/__init__.py ====

```python

```

# ==== apps/accounts/models.py ====

```python
import uuid
from django.contrib.auth.models import User
from django.db import models
from django.utils import timezone


class StaffProfile(models.Model):
    """Extended profile for staff users (Django User model + additional fields)"""
    
    ROLE_CHOICES = [
        ('staff', 'Staff'),
        ('admin', 'Admin'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='staff_profile')
    
    # Staff role within the staff system
    role = models.CharField(max_length=20, choices=ROLE_CHOICES, default='staff')
    
    # Staff-specific information
    department = models.CharField(max_length=50, blank=True)
    hire_date = models.DateField(null=True, blank=True)
    phone = models.CharField(max_length=20, blank=True)
    
    # Permissions tracking
    last_login_ip = models.GenericIPAddressField(null=True, blank=True)
    login_attempts = models.PositiveIntegerField(default=0)
    account_locked_until = models.DateTimeField(null=True, blank=True)
    
    # Management
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'accounts_staff_profile'
        verbose_name = 'Staff Profile'
        verbose_name_plural = 'Staff Profiles'
    
    def __str__(self):
        return f"{self.user.get_full_name()} ({self.role})"
    
    @property
    def can_approve_refunds(self):
        """Only admin role can approve refunds"""
        return self.role == 'admin'
    
    @property
    def can_manage_staff(self):
        """Only admin role can manage other staff accounts"""
        return self.role == 'admin'
    
    @property
    def can_view_financial_reports(self):
        """Both staff and admin can view financial reports"""
        return self.role in ['staff', 'admin']
    
    @property
    def full_name(self):
        """Get full name from associated User model"""
        return self.user.get_full_name()
    
    @property
    def email(self):
        """Get email from associated User model"""
        return self.user.email
    
    def lock_account(self, minutes=30):
        """Lock account for specified minutes after failed login attempts"""
        self.account_locked_until = timezone.now() + timezone.timedelta(minutes=minutes)
        self.save()
    
    def unlock_account(self):
        """Unlock account and reset login attempts"""
        self.account_locked_until = None
        self.login_attempts = 0
        self.save()
    
    @property
    def is_account_locked(self):
        """Check if account is currently locked"""
        if self.account_locked_until:
            return timezone.now() < self.account_locked_until
        return False


class StaffAction(models.Model):
    """Audit log for staff actions - required for compliance"""
    
    ACTION_TYPES = [
        ('login', 'Login'),
        ('logout', 'Logout'),
        ('view_customer', 'View Customer'),
        ('modify_booking', 'Modify Booking'),
        ('process_refund', 'Process Refund'),
        ('approve_refund', 'Approve Refund'),
        ('upload_document', 'Upload Document'),
        ('send_notification', 'Send Notification'),
        ('export_data', 'Export Data'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Who performed the action
    staff_user = models.ForeignKey(User, on_delete=models.PROTECT, related_name='staff_actions')
    
    # What action was performed
    action_type = models.CharField(max_length=30, choices=ACTION_TYPES)
    description = models.TextField()
    
    # Context information
    ip_address = models.GenericIPAddressField()
    user_agent = models.TextField(blank=True)
    
    # Related objects (for tracking what was accessed/modified)
    customer_id = models.UUIDField(null=True, blank=True, help_text="Customer affected by action")
    booking_id = models.UUIDField(null=True, blank=True, help_text="Booking affected by action")
    
    # Timing
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'accounts_staff_action'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['staff_user', '-created_at']),
            models.Index(fields=['action_type', '-created_at']),
            models.Index(fields=['customer_id']),
            models.Index(fields=['booking_id']),
        ]
    
    def __str__(self):
        return f"{self.staff_user.username} - {self.action_type} - {self.created_at}"
    
    @classmethod
    def log_action(cls, staff_user, action_type, description, request=None, customer_id=None, booking_id=None):
        """Helper method to log staff actions"""
        ip_address = '127.0.0.1'  # default
        user_agent = ''
        
        if request:
            ip_address = request.META.get('HTTP_X_FORWARDED_FOR', 
                                        request.META.get('REMOTE_ADDR', '127.0.0.1'))
            user_agent = request.META.get('HTTP_USER_AGENT', '')
        
        return cls.objects.create(
            staff_user=staff_user,
            action_type=action_type,
            description=description,
            ip_address=ip_address,
            user_agent=user_agent,
            customer_id=customer_id,
            booking_id=booking_id
        )
```

# ==== apps/accounts/serializers.py ====

```python
from rest_framework import serializers
from django.contrib.auth.models import User
from .models import StaffProfile, StaffAction


class StaffUserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ('id', 'username', 'email', 'first_name', 'last_name', 'is_active', 'date_joined')
        read_only_fields = ('id', 'date_joined')


class StaffProfileSerializer(serializers.ModelSerializer):
    user = StaffUserSerializer(read_only=True)
    full_name = serializers.ReadOnlyField()
    email = serializers.ReadOnlyField()
    
    class Meta:
        model = StaffProfile
        fields = (
            'id', 'user', 'role', 'department', 'hire_date', 'phone',
            'full_name', 'email', 'is_active', 'created_at'
        )
        read_only_fields = ('id', 'created_at')


class StaffLoginSerializer(serializers.Serializer):
    username = serializers.CharField()
    password = serializers.CharField(write_only=True)
    
    def validate(self, attrs):
        username = attrs.get('username')
        password = attrs.get('password')
        
        if not username or not password:
            raise serializers.ValidationError("Must include username and password")
        
        return attrs


class StaffActionSerializer(serializers.ModelSerializer):
    staff_user_name = serializers.SerializerMethodField()
    
    class Meta:
        model = StaffAction
        fields = (
            'id', 'action_type', 'description', 'staff_user_name',
            'ip_address', 'customer_id', 'booking_id', 'created_at'
        )
        read_only_fields = ('id', 'created_at')
    
    def get_staff_user_name(self, obj):
        return obj.staff_user.get_full_name() if obj.staff_user else None
```

# ==== apps/accounts/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/accounts/urls.py ====

```python
from django.urls import path
from . import views

# Staff API patterns
urlpatterns = [
    # Authentication
    path('auth/login/', views.StaffLoginView.as_view(), name='staff-login'),
    path('auth/logout/', views.StaffLogoutView.as_view(), name='staff-logout'),
    
    # Dashboard and operations
    path('dashboard/', views.StaffDashboardView.as_view(), name='staff-dashboard'),
    path('bookings/', views.BookingManagementView.as_view(), name='staff-bookings'),
    path('bookings/<uuid:booking_id>/', views.BookingDetailView.as_view(), name='staff-booking-detail'),
]
```

# ==== apps/accounts/views.py ====

```python
from rest_framework import generics, status, permissions
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.contrib.auth import login, logout, authenticate
from django.contrib.auth.models import User
from django.middleware.csrf import get_token
from django.views.decorators.csrf import ensure_csrf_cookie
from django.utils.decorators import method_decorator
from django.shortcuts import get_object_or_404
from django.db.models import Q, Count
from .models import StaffProfile, StaffAction
from .serializers import (
    StaffLoginSerializer,
    StaffProfileSerializer,
    StaffUserSerializer,
    StaffActionSerializer
)
from apps.bookings.models import Booking
from apps.customers.models import CustomerProfile
from apps.payments.models import Payment, Refund


class StaffLoginView(APIView):
    """Staff authentication endpoint"""
    permission_classes = [permissions.AllowAny]
    
    @method_decorator(ensure_csrf_cookie)
    def post(self, request):
        serializer = StaffLoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        username = serializer.validated_data['username']
        password = serializer.validated_data['password']
        
        user = authenticate(username=username, password=password)
        
        if user and user.is_active:
            # Check if user has staff profile
            if not hasattr(user, 'staff_profile'):
                return Response(
                    {'error': 'This is not a staff account'}, 
                    status=status.HTTP_403_FORBIDDEN
                )
            
            # Check if account is locked
            if user.staff_profile.is_account_locked:
                return Response(
                    {'error': 'Account is temporarily locked. Contact administrator.'}, 
                    status=status.HTTP_403_FORBIDDEN
                )
            
            login(request, user)
            
            # Log successful login
            StaffAction.log_action(
                staff_user=user,
                action_type='login',
                description=f'Staff user {user.username} logged in successfully',
                request=request
            )
            
            # Reset failed login attempts
            user.staff_profile.login_attempts = 0
            user.staff_profile.save()
            
            return Response({
                'message': 'Login successful',
                'user': StaffUserSerializer(user).data,
                'staff_profile': StaffProfileSerializer(user.staff_profile).data,
                'csrf_token': get_token(request)
            })
        else:
            # Handle failed login attempt
            if user:
                staff_profile = getattr(user, 'staff_profile', None)
                if staff_profile:
                    staff_profile.login_attempts += 1
                    if staff_profile.login_attempts >= 5:
                        staff_profile.lock_account(minutes=30)
                    staff_profile.save()
            
            return Response(
                {'error': 'Invalid username or password'}, 
                status=status.HTTP_401_UNAUTHORIZED
            )


class StaffLogoutView(APIView):
    """Staff logout endpoint"""
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        # Log logout action
        StaffAction.log_action(
            staff_user=request.user,
            action_type='logout',
            description=f'Staff user {request.user.username} logged out',
            request=request
        )
        
        logout(request)
        return Response({'message': 'Logout successful'})


class StaffDashboardView(APIView):
    """Staff operations dashboard with KPIs"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        if not hasattr(request.user, 'staff_profile'):
            return Response(
                {'error': 'Not a staff account'}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        # Log dashboard access
        StaffAction.log_action(
            staff_user=request.user,
            action_type='view_dashboard',
            description='Accessed staff dashboard',
            request=request
        )
        
        # Get booking statistics
        total_bookings = Booking.objects.filter(deleted_at__isnull=True).count()
        pending_bookings = Booking.objects.filter(status='pending', deleted_at__isnull=True).count()
        confirmed_bookings = Booking.objects.filter(status='confirmed', deleted_at__isnull=True).count()
        paid_bookings = Booking.objects.filter(status='paid', deleted_at__isnull=True).count()
        completed_bookings = Booking.objects.filter(status='completed', deleted_at__isnull=True).count()
        
        # Get payment statistics
        total_payments = Payment.objects.filter(status='succeeded').count()
        pending_payments = Payment.objects.filter(status='pending').count()
        failed_payments = Payment.objects.filter(status='failed').count()
        
        # Calculate revenue
        from django.db.models import Sum
        total_revenue_cents = Payment.objects.filter(status='succeeded').aggregate(
            total=Sum('amount_cents')
        )['total'] or 0
        
        # Get recent bookings needing attention
        urgent_bookings = Booking.objects.filter(
            status__in=['pending', 'confirmed'],
            deleted_at__isnull=True
        ).order_by('pickup_date', 'created_at')[:10]
        
        # Get customer statistics
        total_customers = CustomerProfile.objects.count()
        vip_customers = CustomerProfile.objects.filter(is_vip=True).count()
        
        return Response({
            'staff_info': {
                'name': request.user.get_full_name(),
                'role': request.user.staff_profile.role,
                'permissions': {
                    'can_approve_refunds': request.user.staff_profile.can_approve_refunds,
                    'can_manage_staff': request.user.staff_profile.can_manage_staff,
                    'can_view_financial_reports': request.user.staff_profile.can_view_financial_reports
                }
            },
            'booking_stats': {
                'total_bookings': total_bookings,
                'pending_bookings': pending_bookings,
                'confirmed_bookings': confirmed_bookings,
                'paid_bookings': paid_bookings,
                'completed_bookings': completed_bookings
            },
            'payment_stats': {
                'total_payments': total_payments,
                'pending_payments': pending_payments,
                'failed_payments': failed_payments,
                'total_revenue_dollars': total_revenue_cents / 100
            },
            'customer_stats': {
                'total_customers': total_customers,
                'vip_customers': vip_customers
            },
            'urgent_bookings': self._serialize_urgent_bookings(urgent_bookings)
        })
    
    def _serialize_urgent_bookings(self, bookings):
        """Serialize urgent bookings for dashboard"""
        urgent_data = []
        for booking in bookings:
            urgent_data.append({
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'customer_name': booking.get_customer_name(),
                'customer_email': booking.get_customer_email(),
                'service_type': booking.get_service_type_display(),
                'pickup_date': booking.pickup_date,
                'status': booking.get_status_display(),
                'total_price_dollars': booking.total_price_dollars,
                'created_at': booking.created_at
            })
        return urgent_data


class BookingManagementView(APIView):
    """Staff booking management operations"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        """List all bookings with filters"""
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Not a staff account'}, status=status.HTTP_403_FORBIDDEN)
        
        # Get query parameters
        status_filter = request.query_params.get('status', None)
        date_filter = request.query_params.get('date', None)
        search = request.query_params.get('search', None)
        
        # Build queryset
        bookings = Booking.objects.filter(deleted_at__isnull=True).order_by('-created_at')
        
        if status_filter:
            bookings = bookings.filter(status=status_filter)
        
        if date_filter:
            bookings = bookings.filter(pickup_date=date_filter)
        
        if search:
            bookings = bookings.filter(
                Q(booking_number__icontains=search) |
                Q(customer__email__icontains=search) |
                Q(guest_checkout__email__icontains=search) |
                Q(customer__first_name__icontains=search) |
                Q(customer__last_name__icontains=search) |
                Q(guest_checkout__first_name__icontains=search) |
                Q(guest_checkout__last_name__icontains=search)
            )
        
        # Serialize bookings
        booking_data = []
        for booking in bookings[:50]:  # Limit to 50 results
            booking_data.append({
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'customer_name': booking.get_customer_name(),
                'customer_email': booking.get_customer_email(),
                'service_type': booking.get_service_type_display(),
                'pickup_date': booking.pickup_date,
                'pickup_time': booking.get_pickup_time_display(),
                'status': booking.get_status_display(),
                'total_price_dollars': booking.total_price_dollars,
                'payment_status': self._get_payment_status(booking),
                'created_at': booking.created_at,
                'coi_required': booking.coi_required
            })
        
        return Response({
            'bookings': booking_data,
            'total_count': bookings.count(),
            'filters': {
                'status': status_filter,
                'date': date_filter,
                'search': search
            }
        })
    
    def _get_payment_status(self, booking):
        """Get payment status for booking"""
        payment = booking.payments.first()
        return payment.status if payment else 'not_created'


class BookingDetailView(APIView):
    """Staff view for individual booking details and management"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request, booking_id):
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Not a staff account'}, status=status.HTTP_403_FORBIDDEN)
        
        try:
            booking = Booking.objects.get(id=booking_id, deleted_at__isnull=True)
        except Booking.DoesNotExist:
            return Response({'error': 'Booking not found'}, status=status.HTTP_404_NOT_FOUND)
        
        # Log viewing customer data
        StaffAction.log_action(
            staff_user=request.user,
            action_type='view_booking',
            description=f'Viewed booking {booking.booking_number}',
            request=request,
            booking_id=booking.id
        )
        
        # Get payment information
        payment = booking.payments.first()
        payment_data = None
        if payment:
            payment_data = {
                'id': str(payment.id),
                'status': payment.status,
                'amount_dollars': payment.amount_dollars,
                'stripe_payment_intent_id': payment.stripe_payment_intent_id,
                'processed_at': payment.processed_at,
                'failure_reason': payment.failure_reason
            }
        
        # Get customer information
        customer_data = None
        if booking.customer:
            customer_data = {
                'id': booking.customer.id,
                'name': booking.customer.get_full_name(),
                'email': booking.customer.email,
                'phone': getattr(booking.customer.customer_profile, 'phone', ''),
                'is_vip': getattr(booking.customer.customer_profile, 'is_vip', False),
                'total_bookings': getattr(booking.customer.customer_profile, 'total_bookings', 0),
                'total_spent_dollars': getattr(booking.customer.customer_profile, 'total_spent_dollars', 0)
            }
        
        return Response({
            'booking': {
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'service_type': booking.get_service_type_display(),
                'status': booking.status,
                'pickup_date': booking.pickup_date,
                'pickup_time': booking.get_pickup_time_display(),
                'pickup_address': {
                    'address_line_1': booking.pickup_address.address_line_1,
                    'address_line_2': booking.pickup_address.address_line_2,
                    'city': booking.pickup_address.city,
                    'state': booking.pickup_address.state,
                    'zip_code': booking.pickup_address.zip_code
                },
                'delivery_address': {
                    'address_line_1': booking.delivery_address.address_line_1,
                    'address_line_2': booking.delivery_address.address_line_2,
                    'city': booking.delivery_address.city,
                    'state': booking.delivery_address.state,
                    'zip_code': booking.delivery_address.zip_code
                },
                'special_instructions': booking.special_instructions,
                'coi_required': booking.coi_required,
                'total_price_dollars': booking.total_price_dollars,
                'pricing_breakdown': booking.get_pricing_breakdown(),
                'created_at': booking.created_at,
                'updated_at': booking.updated_at
            },
            'customer': customer_data,
            'guest_checkout': {
                'first_name': booking.guest_checkout.first_name if booking.guest_checkout else None,
                'last_name': booking.guest_checkout.last_name if booking.guest_checkout else None,
                'email': booking.guest_checkout.email if booking.guest_checkout else None,
                'phone': booking.guest_checkout.phone if booking.guest_checkout else None
            } if booking.guest_checkout else None,
            'payment': payment_data
        })
    
    def patch(self, request, booking_id):
        """Update booking status and details"""
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Not a staff account'}, status=status.HTTP_403_FORBIDDEN)
        
        try:
            booking = Booking.objects.get(id=booking_id, deleted_at__isnull=True)
        except Booking.DoesNotExist:
            return Response({'error': 'Booking not found'}, status=status.HTTP_404_NOT_FOUND)
        
        # Get update data
        new_status = request.data.get('status')
        staff_notes = request.data.get('staff_notes', '')
        
        old_status = booking.status
        
        # Update booking
        if new_status and new_status != old_status:
            booking.status = new_status
            booking.save()
            
            # Log status change
            StaffAction.log_action(
                staff_user=request.user,
                action_type='modify_booking',
                description=f'Changed booking {booking.booking_number} status from {old_status} to {new_status}. Notes: {staff_notes}',
                request=request,
                booking_id=booking.id
            )
        
        return Response({
            'message': 'Booking updated successfully',
            'booking': {
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'status': booking.status,
                'updated_at': booking.updated_at
            }
        })
```

# ==== apps/bookings/__init__.py ====

```python

```

# ==== apps/bookings/admin.py ====

```python
from django.contrib import admin
from .models import Booking, Address, GuestCheckout

@admin.register(Booking)
class BookingAdmin(admin.ModelAdmin):
    list_display = (
        'booking_number', 
        'get_customer_name', 
        'service_type', 
        'get_service_details',
        'status', 
        'pickup_date', 
        'total_price_dollars'
    )
    list_filter = ('service_type', 'status', 'pickup_date', 'coi_required')
    search_fields = ('booking_number', 'customer__email', 'guest_checkout__email')
    readonly_fields = ('booking_number', 'base_price_cents', 'surcharge_cents', 'coi_fee_cents', 'total_price_cents', 'created_at', 'updated_at')
    
    fieldsets = (
        ('Customer Info', {
            'fields': ('customer', 'guest_checkout')
        }),
        ('Service Selection', {
            'fields': (
                'service_type', 
                'mini_move_package', 
                'standard_delivery_item_count',
                'is_same_day_delivery',
                'specialty_items'
            )
        }),
        ('Booking Details', {
            'fields': ('pickup_date', 'pickup_time', 'pickup_address', 'delivery_address')
        }),
        ('Requirements', {
            'fields': ('special_instructions', 'coi_required')
        }),
        ('Calculated Pricing', {
            'fields': ('base_price_cents', 'surcharge_cents', 'coi_fee_cents', 'total_price_cents'),
            'classes': ('collapse',)
        }),
        ('Status', {
            'fields': ('status',)
        }),
        ('System Info', {
            'fields': ('booking_number', 'created_at', 'updated_at'),
            'classes': ('collapse',)
        })
    )
    
    filter_horizontal = ('specialty_items',)  # Nice interface for many-to-many
    
    def get_customer_name(self, obj):
        return obj.get_customer_name()
    get_customer_name.short_description = 'Customer'
    
    def get_service_details(self, obj):
        if obj.service_type == 'mini_move' and obj.mini_move_package:
            return obj.mini_move_package.name
        elif obj.service_type == 'standard_delivery' and obj.standard_delivery_item_count:
            return f"{obj.standard_delivery_item_count} items"
        elif obj.service_type == 'specialty_item':
            items = list(obj.specialty_items.all())
            return ", ".join([item.name for item in items[:2]]) + ("..." if len(items) > 2 else "")
        return "Not configured"
    get_service_details.short_description = 'Service Details'

@admin.register(Address)
class AddressAdmin(admin.ModelAdmin):
    list_display = ('address_line_1', 'city', 'state', 'customer', 'created_at')
    list_filter = ('state', 'city')
    search_fields = ('address_line_1', 'city', 'customer__email')

@admin.register(GuestCheckout)
class GuestCheckoutAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', 'email', 'phone', 'created_at')
    search_fields = ('first_name', 'last_name', 'email')
    readonly_fields = ('created_at',)
```

# ==== apps/bookings/apps.py ====

```python
from django.apps import AppConfig

class BookingsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.bookings'  # Changed from 'bookings' to 'apps.bookings'
```

# ==== apps/bookings/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.5 on 2025-09-02 20:54

import django.core.validators
import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('services', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='GuestCheckout',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('first_name', models.CharField(max_length=100)),
                ('last_name', models.CharField(max_length=100)),
                ('email', models.EmailField(max_length=254)),
                ('phone', models.CharField(max_length=20, validators=[django.core.validators.RegexValidator(regex='^\\+?1?\\d{9,15}$')])),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'db_table': 'bookings_guest_checkout',
            },
        ),
        migrations.CreateModel(
            name='Address',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('address_line_1', models.CharField(max_length=200)),
                ('address_line_2', models.CharField(blank=True, max_length=200)),
                ('city', models.CharField(max_length=100)),
                ('state', models.CharField(choices=[('NY', 'New York'), ('CT', 'Connecticut'), ('NJ', 'New Jersey')], max_length=2)),
                ('zip_code', models.CharField(max_length=10)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('customer', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='booking_addresses', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'bookings_address',
            },
        ),
        migrations.CreateModel(
            name='Booking',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('booking_number', models.CharField(blank=True, max_length=20, unique=True)),
                ('service_type', models.CharField(choices=[('mini_move', 'Mini Move'), ('standard_delivery', 'Standard Delivery'), ('specialty_item', 'Specialty Item')], max_length=20)),
                ('standard_delivery_item_count', models.PositiveIntegerField(blank=True, help_text='Number of items for standard delivery', null=True)),
                ('is_same_day_delivery', models.BooleanField(default=False, help_text='Same-day delivery (flat $360 rate)')),
                ('pickup_date', models.DateField()),
                ('pickup_time', models.CharField(choices=[('morning', '8 AM - 11 AM'), ('afternoon', '12 PM - 3 PM'), ('evening', '4 PM - 7 PM')], default='morning', max_length=20)),
                ('special_instructions', models.TextField(blank=True)),
                ('coi_required', models.BooleanField(default=False)),
                ('base_price_cents', models.PositiveBigIntegerField(default=0)),
                ('surcharge_cents', models.PositiveBigIntegerField(default=0)),
                ('coi_fee_cents', models.PositiveBigIntegerField(default=0)),
                ('total_price_cents', models.PositiveBigIntegerField(default=0)),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('confirmed', 'Confirmed'), ('paid', 'Paid'), ('completed', 'Completed'), ('cancelled', 'Cancelled')], default='pending', max_length=20)),
                ('deleted_at', models.DateTimeField(blank=True, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('customer', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='bookings', to=settings.AUTH_USER_MODEL)),
                ('delivery_address', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='delivery_bookings', to='bookings.address')),
                ('mini_move_package', models.ForeignKey(blank=True, help_text='Selected mini move package (Petite/Standard/Full)', null=True, on_delete=django.db.models.deletion.PROTECT, to='services.minimovepackage')),
                ('pickup_address', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='pickup_bookings', to='bookings.address')),
                ('specialty_items', models.ManyToManyField(blank=True, help_text='Selected specialty items (Peloton, Surfboard, etc.)', to='services.specialtyitem')),
                ('guest_checkout', models.OneToOneField(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='booking', to='bookings.guestcheckout')),
            ],
            options={
                'db_table': 'bookings_booking',
                'constraints': [models.CheckConstraint(condition=models.Q(models.Q(('customer__isnull', False), ('guest_checkout__isnull', True)), models.Q(('customer__isnull', True), ('guest_checkout__isnull', False)), _connector='OR'), name='booking_exactly_one_customer_type')],
            },
        ),
    ]
```

# ==== apps/bookings/migrations/__init__.py ====

```python

```

# ==== apps/bookings/models.py ====

```python
import uuid
from django.db import models
from django.utils import timezone
from django.contrib.auth.models import User
from django.core.validators import RegexValidator


class Address(models.Model):
    """Address for pickup/delivery - can be saved by customer or one-time"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Optional customer link (for saved addresses)
    customer = models.ForeignKey(
        User, 
        on_delete=models.CASCADE, 
        null=True, 
        blank=True,
        related_name='booking_addresses'
    )
    
    # Address fields
    address_line_1 = models.CharField(max_length=200)
    address_line_2 = models.CharField(max_length=200, blank=True)
    city = models.CharField(max_length=100)
    state = models.CharField(max_length=2, choices=[
        ('NY', 'New York'),
        ('CT', 'Connecticut'), 
        ('NJ', 'New Jersey'),
    ])
    zip_code = models.CharField(max_length=10)
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'bookings_address'
    
    def __str__(self):
        return f"{self.address_line_1}, {self.city}, {self.state} {self.zip_code}"


class GuestCheckout(models.Model):
    """Guest customer info for non-authenticated bookings"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    email = models.EmailField()
    phone = models.CharField(
        max_length=20, 
        validators=[RegexValidator(regex=r'^\+?1?\d{9,15}$')]
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'bookings_guest_checkout'
    
    def __str__(self):
        return f"{self.first_name} {self.last_name} ({self.email})"


class Booking(models.Model):
    """Core booking - works with customer OR guest checkout - WITH SERVICES INTEGRATION"""
    
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('confirmed', 'Confirmed'),
        ('paid', 'Paid'),
        ('completed', 'Completed'),
        ('cancelled', 'Cancelled'),
    ]
    
    SERVICE_TYPE_CHOICES = [
        ('mini_move', 'Mini Move'),
        ('standard_delivery', 'Standard Delivery'),
        ('specialty_item', 'Specialty Item'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    booking_number = models.CharField(max_length=20, unique=True, blank=True)
    
    # Customer - EITHER customer OR guest_checkout
    customer = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name='bookings'
    )
    guest_checkout = models.OneToOneField(
        GuestCheckout,
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name='booking'
    )
    
    # Service details
    service_type = models.CharField(max_length=20, choices=SERVICE_TYPE_CHOICES)
    
    # SERVICE CONNECTIONS
    # For Mini Move bookings
    mini_move_package = models.ForeignKey(
        'services.MiniMovePackage',
        on_delete=models.PROTECT,
        null=True,
        blank=True,
        help_text="Selected mini move package (Petite/Standard/Full)"
    )
    
    # For Standard Delivery bookings  
    standard_delivery_item_count = models.PositiveIntegerField(
        null=True,
        blank=True,
        help_text="Number of items for standard delivery"
    )
    is_same_day_delivery = models.BooleanField(
        default=False,
        help_text="Same-day delivery (flat $360 rate)"
    )
    
    # For Specialty Item bookings
    specialty_items = models.ManyToManyField(
        'services.SpecialtyItem',
        blank=True,
        help_text="Selected specialty items (Peloton, Surfboard, etc.)"
    )
    
    # Addresses
    pickup_address = models.ForeignKey(
        Address, 
        on_delete=models.PROTECT, 
        related_name='pickup_bookings'
    )
    delivery_address = models.ForeignKey(
        Address, 
        on_delete=models.PROTECT, 
        related_name='delivery_bookings'
    )
    
    # Date and preferences
    pickup_date = models.DateField()
    pickup_time = models.CharField(
        max_length=20,
        choices=[
            ('morning', '8 AM - 11 AM'),
            ('afternoon', '12 PM - 3 PM'),
            ('evening', '4 PM - 7 PM'),
        ],
        default='morning'
    )
    
    # Special requirements
    special_instructions = models.TextField(blank=True)
    coi_required = models.BooleanField(default=False)
    
    # CALCULATED PRICING
    base_price_cents = models.PositiveBigIntegerField(default=0)
    surcharge_cents = models.PositiveBigIntegerField(default=0)
    coi_fee_cents = models.PositiveBigIntegerField(default=0)
    total_price_cents = models.PositiveBigIntegerField(default=0)
    
    # Status
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    
    # Soft delete
    deleted_at = models.DateTimeField(null=True, blank=True)
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'bookings_booking'
        constraints = [
            models.CheckConstraint(
                check=(
                    models.Q(customer__isnull=False, guest_checkout__isnull=True) |
                    models.Q(customer__isnull=True, guest_checkout__isnull=False)
                ),
                name='booking_exactly_one_customer_type'
            )
        ]
    
    def save(self, *args, **kwargs):
        if not self.booking_number:
            # Simple booking number generation
            last_booking = Booking.objects.order_by('created_at').last()
            if last_booking and last_booking.booking_number:
                last_num = int(last_booking.booking_number.split('-')[1])
                next_num = last_num + 1
            else:
                next_num = 1
            self.booking_number = f"TT-{next_num:06d}"
        
        # Calculate pricing before saving
        self.calculate_pricing()
        super().save(*args, **kwargs)
    
    def __str__(self):
        customer_name = self.get_customer_name()
        return f"{self.booking_number} - {customer_name} - ${self.total_price_dollars}"
    
    def get_customer_name(self):
        if self.customer:
            return self.customer.get_full_name()
        elif self.guest_checkout:
            return f"{self.guest_checkout.first_name} {self.guest_checkout.last_name}"
        return "Unknown"
    
    def get_customer_email(self):
        if self.customer:
            return self.customer.email
        elif self.guest_checkout:
            return self.guest_checkout.email
        return None
    
    @property
    def total_price_dollars(self):
        return self.total_price_cents / 100
    
    @property
    def base_price_dollars(self):
        return self.base_price_cents / 100
    
    @property
    def surcharge_dollars(self):
        return self.surcharge_cents / 100
    
    @property
    def coi_fee_dollars(self):
        return self.coi_fee_cents / 100
    
    def calculate_pricing(self):
        """Calculate total pricing using services pricing engine"""
        from apps.services.models import StandardDeliveryConfig, SurchargeRule
        
        # Reset pricing
        self.base_price_cents = 0
        self.surcharge_cents = 0
        self.coi_fee_cents = 0
        
        # Calculate base price by service type
        if self.service_type == 'mini_move' and self.mini_move_package:
            self.base_price_cents = self.mini_move_package.base_price_cents
            
            # COI handling for Mini Moves
            if self.coi_required and not self.mini_move_package.coi_included:
                self.coi_fee_cents = self.mini_move_package.coi_fee_cents
            
        elif self.service_type == 'standard_delivery' and self.standard_delivery_item_count:
            try:
                config = StandardDeliveryConfig.objects.filter(is_active=True).first()
                if config:
                    self.base_price_cents = config.calculate_total(
                        self.standard_delivery_item_count,
                        is_same_day=self.is_same_day_delivery
                    )
            except StandardDeliveryConfig.DoesNotExist:
                pass
        
        elif self.service_type == 'specialty_item':
            # Calculate total for all selected specialty items
            specialty_total = 0
            for item in self.specialty_items.all():
                specialty_total += item.price_cents
            self.base_price_cents = specialty_total
        
        # Calculate surcharges (but not for same-day delivery which has flat rate)
        if self.pickup_date and not self.is_same_day_delivery:
            active_surcharges = SurchargeRule.objects.filter(is_active=True)
            for surcharge in active_surcharges:
                surcharge_amount = surcharge.calculate_surcharge(
                    self.base_price_cents, 
                    self.pickup_date
                )
                self.surcharge_cents += surcharge_amount
        
        # Calculate total
        self.total_price_cents = self.base_price_cents + self.surcharge_cents + self.coi_fee_cents
    
    def get_pricing_breakdown(self):
        """Return detailed pricing breakdown for display"""
        return {
            'base_price': self.base_price_dollars,
            'surcharges': self.surcharge_dollars,
            'coi_fee': self.coi_fee_dollars,
            'total': self.total_price_dollars,
            'service_type': self.get_service_type_display(),
        }
```

# ==== apps/bookings/serializers.py ====

```python
from rest_framework import serializers
from django.contrib.auth.models import User
from .models import Booking, Address, GuestCheckout
from apps.services.models import MiniMovePackage, SpecialtyItem


class AddressSerializer(serializers.ModelSerializer):
    class Meta:
        model = Address
        fields = (
            'id', 'address_line_1', 'address_line_2', 
            'city', 'state', 'zip_code'
        )


class GuestCheckoutSerializer(serializers.ModelSerializer):
    class Meta:
        model = GuestCheckout
        fields = ('first_name', 'last_name', 'email', 'phone')


class BookingSerializer(serializers.ModelSerializer):
    customer_name = serializers.SerializerMethodField()
    customer_email = serializers.SerializerMethodField()
    pickup_address = AddressSerializer(read_only=True)
    delivery_address = AddressSerializer(read_only=True)
    guest_checkout = GuestCheckoutSerializer(read_only=True)
    total_price_dollars = serializers.ReadOnlyField()
    pricing_breakdown = serializers.SerializerMethodField()
    
    class Meta:
        model = Booking
        fields = (
            'id', 'booking_number', 'customer_name', 'customer_email',
            'service_type', 'pickup_date', 'pickup_time', 'status',
            'pickup_address', 'delivery_address', 'guest_checkout',
            'special_instructions', 'coi_required',
            'total_price_dollars', 'pricing_breakdown', 'created_at'
        )
    
    def get_customer_name(self, obj):
        return obj.get_customer_name()
    
    def get_customer_email(self, obj):
        return obj.get_customer_email()
    
    def get_pricing_breakdown(self, obj):
        return obj.get_pricing_breakdown()


class BookingStatusSerializer(serializers.ModelSerializer):
    customer_name = serializers.SerializerMethodField()
    pickup_address = AddressSerializer(read_only=True)
    delivery_address = AddressSerializer(read_only=True)
    total_price_dollars = serializers.ReadOnlyField()
    
    class Meta:
        model = Booking
        fields = (
            'booking_number', 'customer_name', 'service_type', 
            'pickup_date', 'pickup_time', 'status',
            'pickup_address', 'delivery_address',
            'total_price_dollars', 'created_at'
        )
    
    def get_customer_name(self, obj):
        return obj.get_customer_name()


class PricingPreviewSerializer(serializers.Serializer):
    service_type = serializers.ChoiceField(choices=[
        ('mini_move', 'Mini Move'),
        ('standard_delivery', 'Standard Delivery'),
        ('specialty_item', 'Specialty Item')
    ])
    pickup_date = serializers.DateField()
    
    # Mini Move fields
    mini_move_package_id = serializers.UUIDField(required=False)
    coi_required = serializers.BooleanField(required=False, default=False)
    
    # Standard Delivery fields
    standard_delivery_item_count = serializers.IntegerField(required=False, min_value=1)
    is_same_day_delivery = serializers.BooleanField(required=False, default=False)
    
    # Specialty Items fields
    specialty_item_ids = serializers.ListField(
        child=serializers.UUIDField(),
        required=False,
        allow_empty=True
    )


class GuestBookingCreateSerializer(serializers.Serializer):
    # Guest customer info
    first_name = serializers.CharField(max_length=100)
    last_name = serializers.CharField(max_length=100)
    email = serializers.EmailField()
    phone = serializers.CharField(max_length=20)
    
    # Service selection
    service_type = serializers.ChoiceField(choices=[
        ('mini_move', 'Mini Move'),
        ('standard_delivery', 'Standard Delivery'),
        ('specialty_item', 'Specialty Item')
    ])
    
    # Service-specific fields
    mini_move_package_id = serializers.UUIDField(required=False)
    standard_delivery_item_count = serializers.IntegerField(required=False, min_value=1)
    is_same_day_delivery = serializers.BooleanField(default=False)
    specialty_item_ids = serializers.ListField(
        child=serializers.UUIDField(),
        required=False,
        allow_empty=True
    )
    
    # Booking details
    pickup_date = serializers.DateField()
    pickup_time = serializers.ChoiceField(choices=[
        ('morning', '8 AM - 11 AM'),
        ('afternoon', '12 PM - 3 PM'),
        ('evening', '4 PM - 7 PM'),
    ], default='morning')
    
    # Addresses
    pickup_address = serializers.DictField()
    delivery_address = serializers.DictField()
    
    # Additional info
    special_instructions = serializers.CharField(required=False, allow_blank=True)
    coi_required = serializers.BooleanField(default=False)
    
    def validate_pickup_address(self, value):
        required_fields = ['address_line_1', 'city', 'state', 'zip_code']
        for field in required_fields:
            if field not in value:
                raise serializers.ValidationError(f"Missing required field: {field}")
        return value
    
    def validate_delivery_address(self, value):
        required_fields = ['address_line_1', 'city', 'state', 'zip_code']
        for field in required_fields:
            if field not in value:
                raise serializers.ValidationError(f"Missing required field: {field}")
        return value
    
    def validate(self, attrs):
        service_type = attrs['service_type']
        
        # Validate service-specific requirements
        if service_type == 'mini_move':
            if not attrs.get('mini_move_package_id'):
                raise serializers.ValidationError("mini_move_package_id is required for mini move service")
        
        elif service_type == 'standard_delivery':
            if not attrs.get('standard_delivery_item_count'):
                raise serializers.ValidationError("standard_delivery_item_count is required for standard delivery")
        
        elif service_type == 'specialty_item':
            if not attrs.get('specialty_item_ids'):
                raise serializers.ValidationError("specialty_item_ids is required for specialty item service")
        
        return attrs
    
    def create(self, validated_data):
        # Create guest checkout
        guest_checkout = GuestCheckout.objects.create(
            first_name=validated_data['first_name'],
            last_name=validated_data['last_name'],
            email=validated_data['email'],
            phone=validated_data['phone']
        )
        
        # Create addresses
        pickup_address_data = validated_data.pop('pickup_address')
        pickup_address = Address.objects.create(**pickup_address_data)
        
        delivery_address_data = validated_data.pop('delivery_address')
        delivery_address = Address.objects.create(**delivery_address_data)
        
        # Create booking
        booking = Booking.objects.create(
            guest_checkout=guest_checkout,
            service_type=validated_data['service_type'],
            pickup_date=validated_data['pickup_date'],
            pickup_time=validated_data['pickup_time'],
            pickup_address=pickup_address,
            delivery_address=delivery_address,
            special_instructions=validated_data.get('special_instructions', ''),
            coi_required=validated_data.get('coi_required', False),
            standard_delivery_item_count=validated_data.get('standard_delivery_item_count'),
            is_same_day_delivery=validated_data.get('is_same_day_delivery', False)
        )
        
        # Handle service-specific relationships
        if validated_data['service_type'] == 'mini_move':
            try:
                package = MiniMovePackage.objects.get(id=validated_data['mini_move_package_id'])
                booking.mini_move_package = package
            except MiniMovePackage.DoesNotExist:
                raise serializers.ValidationError("Invalid mini move package")
        
        elif validated_data['service_type'] == 'specialty_item':
            specialty_items = SpecialtyItem.objects.filter(
                id__in=validated_data.get('specialty_item_ids', [])
            )
            booking.save()  # Save first to get ID for M2M relationship
            booking.specialty_items.set(specialty_items)
        
        booking.save()  # This will trigger pricing calculation
        return booking
```

# ==== apps/bookings/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/bookings/urls.py ====

```python
from django.urls import path
from . import views

# Public booking API patterns - no authentication required
urlpatterns = [
    # Service information
    path('services/', views.ServiceCatalogView.as_view(), name='service-catalog'),
    path('pricing-preview/', views.PricingPreviewView.as_view(), name='pricing-preview'),
    path('availability/', views.CalendarAvailabilityView.as_view(), name='calendar-availability'),
    
    # Guest booking
    path('guest-booking/', views.GuestBookingCreateView.as_view(), name='guest-booking-create'),
    
    # Booking status lookup
    path('booking-status/<str:booking_number>/', views.BookingStatusView.as_view(), name='booking-status'),
]
```

# ==== apps/bookings/views.py ====

```python
from rest_framework import generics, status, permissions
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.shortcuts import get_object_or_404
from django.utils import timezone
from datetime import date, timedelta
from .models import Booking, Address, GuestCheckout
from .serializers import (
    BookingSerializer,
    GuestBookingCreateSerializer,
    BookingStatusSerializer,
    PricingPreviewSerializer,
    AddressSerializer
)
from apps.services.models import (
    MiniMovePackage, 
    StandardDeliveryConfig, 
    SpecialtyItem, 
    SurchargeRule,
    VanSchedule
)


class ServiceCatalogView(APIView):
    """Get all available services - no authentication required"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request):
        # Mini Move Packages
        mini_move_packages = []
        for package in MiniMovePackage.objects.filter(is_active=True).order_by('base_price_cents'):
            mini_move_packages.append({
                'id': str(package.id),
                'package_type': package.package_type,
                'name': package.name,
                'description': package.description,
                'base_price_dollars': package.base_price_dollars,
                'max_items': package.max_items,
                'coi_included': package.coi_included,
                'coi_fee_dollars': package.coi_fee_dollars,
                'is_most_popular': package.is_most_popular,
                'features': {
                    'priority_scheduling': package.priority_scheduling,
                    'protective_wrapping': package.protective_wrapping
                }
            })
        
        # Standard Delivery Config
        standard_config = StandardDeliveryConfig.objects.filter(is_active=True).first()
        standard_delivery = None
        if standard_config:
            standard_delivery = {
                'price_per_item_dollars': standard_config.price_per_item_dollars,
                'minimum_items': standard_config.minimum_items,
                'minimum_charge_dollars': standard_config.minimum_charge_dollars,
                'same_day_flat_rate_dollars': standard_config.same_day_flat_rate_cents / 100,
                'max_weight_per_item_lbs': standard_config.max_weight_per_item_lbs
            }
        
        # Specialty Items
        specialty_items = []
        for item in SpecialtyItem.objects.filter(is_active=True):
            specialty_items.append({
                'id': str(item.id),
                'item_type': item.item_type,
                'name': item.name,
                'description': item.description,
                'price_dollars': item.price_dollars,
                'requires_van_schedule': item.requires_van_schedule,
                'special_handling': item.special_handling
            })
        
        return Response({
            'mini_move_packages': mini_move_packages,
            'standard_delivery': standard_delivery,
            'specialty_items': specialty_items
        })


class PricingPreviewView(APIView):
    """Calculate pricing for booking selection - no authentication required"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = PricingPreviewSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        service_type = serializer.validated_data['service_type']
        pickup_date = serializer.validated_data['pickup_date']
        
        base_price_cents = 0
        surcharge_cents = 0
        coi_fee_cents = 0
        details = {}
        
        # Calculate base price by service type
        if service_type == 'mini_move':
            package_id = serializer.validated_data.get('mini_move_package_id')
            if package_id:
                try:
                    package = MiniMovePackage.objects.get(id=package_id, is_active=True)
                    base_price_cents = package.base_price_cents
                    details['package_name'] = package.name
                    
                    # COI handling
                    coi_required = serializer.validated_data.get('coi_required', False)
                    if coi_required and not package.coi_included:
                        coi_fee_cents = package.coi_fee_cents
                        details['coi_required'] = True
                    
                except MiniMovePackage.DoesNotExist:
                    return Response({'error': 'Invalid mini move package'}, status=status.HTTP_400_BAD_REQUEST)
        
        elif service_type == 'standard_delivery':
            item_count = serializer.validated_data.get('standard_delivery_item_count', 0)
            is_same_day = serializer.validated_data.get('is_same_day_delivery', False)
            
            try:
                config = StandardDeliveryConfig.objects.filter(is_active=True).first()
                if config:
                    base_price_cents = config.calculate_total(item_count, is_same_day)
                    details['item_count'] = item_count
                    details['is_same_day'] = is_same_day
                    
                    if is_same_day:
                        details['same_day_rate'] = config.same_day_flat_rate_cents / 100
                    else:
                        details['per_item_rate'] = config.price_per_item_cents / 100
                        details['minimum_charge'] = config.minimum_charge_cents / 100
                        
            except StandardDeliveryConfig.DoesNotExist:
                return Response({'error': 'Standard delivery not configured'}, status=status.HTTP_400_BAD_REQUEST)
        
        elif service_type == 'specialty_item':
            specialty_item_ids = serializer.validated_data.get('specialty_item_ids', [])
            specialty_items = SpecialtyItem.objects.filter(id__in=specialty_item_ids, is_active=True)
            
            specialty_total = sum(item.price_cents for item in specialty_items)
            base_price_cents = specialty_total
            details['specialty_items'] = [
                {'name': item.name, 'price_dollars': item.price_dollars}
                for item in specialty_items
            ]
        
        # Calculate surcharges (skip for same-day delivery)
        is_same_day = serializer.validated_data.get('is_same_day_delivery', False)
        if pickup_date and base_price_cents > 0 and not is_same_day:
            active_surcharges = SurchargeRule.objects.filter(is_active=True)
            surcharge_details = []
            
            for surcharge in active_surcharges:
                surcharge_amount = surcharge.calculate_surcharge(base_price_cents, pickup_date)
                if surcharge_amount > 0:
                    surcharge_cents += surcharge_amount
                    surcharge_details.append({
                        'name': surcharge.name,
                        'amount_dollars': surcharge_amount / 100,
                        'reason': surcharge.description
                    })
            
            if surcharge_details:
                details['surcharges'] = surcharge_details
        
        # Calculate total
        total_price_cents = base_price_cents + surcharge_cents + coi_fee_cents
        
        return Response({
            'service_type': service_type,
            'pricing': {
                'base_price_dollars': base_price_cents / 100,
                'surcharge_dollars': surcharge_cents / 100,
                'coi_fee_dollars': coi_fee_cents / 100,
                'total_price_dollars': total_price_cents / 100
            },
            'details': details,
            'pickup_date': pickup_date
        })


class CalendarAvailabilityView(APIView):
    """Get available dates for booking - no authentication required"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request):
        # Get date range (next 60 days by default)
        start_date = request.query_params.get('start_date', date.today())
        if isinstance(start_date, str):
            start_date = date.fromisoformat(start_date)
        
        end_date = start_date + timedelta(days=60)
        
        availability = []
        current_date = start_date
        
        while current_date <= end_date:
            # Check if it's a weekend (for surcharge indication)
            is_weekend = current_date.weekday() >= 5
            
            # Check van schedule availability
            van_schedule = VanSchedule.objects.filter(date=current_date).first()
            if van_schedule:
                available = van_schedule.has_capacity
                specialty_items_allowed = van_schedule.allows_specialty_items
                capacity_used = van_schedule.total_bookings
                max_capacity = van_schedule.max_capacity
            else:
                # Default availability if no specific schedule
                available = True
                specialty_items_allowed = False
                capacity_used = 0
                max_capacity = 10
            
            # Check for specific surcharges on this date
            surcharges = []
            for rule in SurchargeRule.objects.filter(is_active=True):
                if rule.applies_to_date(current_date):
                    surcharges.append({
                        'name': rule.name,
                        'type': rule.surcharge_type,
                        'description': rule.description
                    })
            
            availability.append({
                'date': current_date.isoformat(),
                'available': available,
                'is_weekend': is_weekend,
                'specialty_items_allowed': specialty_items_allowed,
                'capacity_used': capacity_used,
                'max_capacity': max_capacity,
                'surcharges': surcharges
            })
            
            current_date += timedelta(days=1)
        
        return Response({
            'availability': availability,
            'start_date': start_date.isoformat(),
            'end_date': end_date.isoformat()
        })


class GuestBookingCreateView(generics.CreateAPIView):
    """Create booking for guest (non-authenticated) users"""
    serializer_class = GuestBookingCreateSerializer
    permission_classes = [permissions.AllowAny]
    
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        booking = serializer.save()
        
        return Response({
            'message': 'Booking created successfully',
            'booking': BookingSerializer(booking).data
        }, status=status.HTTP_201_CREATED)


class BookingStatusView(APIView):
    """Get booking status by booking number - no authentication required"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request, booking_number):
        try:
            booking = Booking.objects.get(booking_number=booking_number, deleted_at__isnull=True)
            serializer = BookingStatusSerializer(booking)
            return Response(serializer.data)
        except Booking.DoesNotExist:
            return Response(
                {'error': 'Booking not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
```

# ==== apps/crm/__init__.py ====

```python

```

# ==== apps/crm/admin.py ====

```python
from django.contrib import admin

# Register your models here.
```

# ==== apps/crm/apps.py ====

```python
from django.apps import AppConfig


class CrmConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.crm'
```

# ==== apps/crm/migrations/__init__.py ====

```python

```

# ==== apps/crm/models.py ====

```python
from django.db import models

# Create your models here.
```

# ==== apps/crm/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/crm/views.py ====

```python
from django.shortcuts import render

# Create your views here.
```

# ==== apps/customers/__init__.py ====

```python

```

# ==== apps/customers/admin.py ====

```python
from django.contrib import admin
from django.contrib.auth.models import User
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from .models import CustomerProfile, SavedAddress, CustomerPaymentMethod


class CustomerProfileInline(admin.StackedInline):
    model = CustomerProfile
    can_delete = False
    verbose_name_plural = 'Customer Profile'


class CustomUserAdmin(BaseUserAdmin):
    inlines = (CustomerProfileInline,)


# Re-register UserAdmin
admin.site.unregister(User)
admin.site.register(User, CustomUserAdmin)


@admin.register(CustomerProfile)
class CustomerProfileAdmin(admin.ModelAdmin):
    list_display = ('user', 'total_bookings', 'total_spent_dollars', 'is_vip', 'last_booking_at')
    list_filter = ('is_vip', 'preferred_pickup_time', 'email_notifications')
    search_fields = ('user__email', 'user__first_name', 'user__last_name')
    readonly_fields = ('total_bookings', 'total_spent_cents', 'last_booking_at', 'created_at', 'updated_at')


@admin.register(SavedAddress)
class SavedAddressAdmin(admin.ModelAdmin):
    list_display = ('user', 'nickname', 'city', 'state', 'times_used', 'is_active')
    list_filter = ('state', 'is_active', 'city')
    search_fields = ('user__email', 'nickname', 'city', 'address_line_1')
    readonly_fields = ('times_used', 'last_used_at', 'created_at', 'updated_at')


@admin.register(CustomerPaymentMethod)
class CustomerPaymentMethodAdmin(admin.ModelAdmin):
    list_display = ('user', 'display_name', 'is_default', 'is_active', 'created_at')
    list_filter = ('card_brand', 'is_default', 'is_active')
    search_fields = ('user__email', 'card_last_four')
    readonly_fields = ('stripe_payment_method_id', 'created_at')
```

# ==== apps/customers/apps.py ====

```python
# apps/customers/apps.py
from django.apps import AppConfig

class CustomersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.customers'  # Change this from 'customers' to 'apps.customers'
```

# ==== apps/customers/booking_serializers.py ====

```python
from rest_framework import serializers
from django.contrib.auth.models import User
from apps.bookings.models import Booking, Address
from apps.services.models import MiniMovePackage, SpecialtyItem
from .models import SavedAddress
from .serializers import SavedAddressSerializer


class AuthenticatedBookingCreateSerializer(serializers.Serializer):
    """Enhanced booking creation for authenticated customers"""
    
    # Service selection
    service_type = serializers.ChoiceField(choices=[
        ('mini_move', 'Mini Move'),
        ('standard_delivery', 'Standard Delivery'),
        ('specialty_item', 'Specialty Item')
    ])
    
    # Service-specific fields
    mini_move_package_id = serializers.UUIDField(required=False)
    standard_delivery_item_count = serializers.IntegerField(required=False, min_value=1)
    is_same_day_delivery = serializers.BooleanField(default=False)
    specialty_item_ids = serializers.ListField(
        child=serializers.UUIDField(),
        required=False,
        allow_empty=True
    )
    
    # Booking details
    pickup_date = serializers.DateField()
    pickup_time = serializers.ChoiceField(choices=[
        ('morning', '8 AM - 11 AM'),
        ('afternoon', '12 PM - 3 PM'),
        ('evening', '4 PM - 7 PM'),
    ], required=False)
    
    # Address selection - can use saved addresses or create new ones
    pickup_address_id = serializers.UUIDField(required=False)
    delivery_address_id = serializers.UUIDField(required=False)
    new_pickup_address = serializers.DictField(required=False)
    new_delivery_address = serializers.DictField(required=False)
    
    # Save new addresses for future use
    save_pickup_address = serializers.BooleanField(default=False)
    save_delivery_address = serializers.BooleanField(default=False)
    pickup_address_nickname = serializers.CharField(required=False, max_length=50)
    delivery_address_nickname = serializers.CharField(required=False, max_length=50)
    
    # Additional options
    special_instructions = serializers.CharField(required=False, allow_blank=True)
    coi_required = serializers.BooleanField(default=False)
    create_payment_intent = serializers.BooleanField(default=True)
    
    def validate(self, attrs):
        user = self.context['user']
        service_type = attrs['service_type']
        
        # Validate service-specific requirements
        if service_type == 'mini_move':
            if not attrs.get('mini_move_package_id'):
                raise serializers.ValidationError("mini_move_package_id is required for mini move service")
        
        elif service_type == 'standard_delivery':
            if not attrs.get('standard_delivery_item_count'):
                raise serializers.ValidationError("standard_delivery_item_count is required for standard delivery")
        
        elif service_type == 'specialty_item':
            if not attrs.get('specialty_item_ids'):
                raise serializers.ValidationError("specialty_item_ids is required for specialty item service")
        
        # Validate address selection
        if not (attrs.get('pickup_address_id') or attrs.get('new_pickup_address')):
            raise serializers.ValidationError("Either pickup_address_id or new_pickup_address is required")
        
        if not (attrs.get('delivery_address_id') or attrs.get('new_delivery_address')):
            raise serializers.ValidationError("Either delivery_address_id or new_delivery_address is required")
        
        # Validate saved addresses belong to user
        if attrs.get('pickup_address_id'):
            if not user.saved_addresses.filter(id=attrs['pickup_address_id'], is_active=True).exists():
                raise serializers.ValidationError("Invalid pickup address")
        
        if attrs.get('delivery_address_id'):
            if not user.saved_addresses.filter(id=attrs['delivery_address_id'], is_active=True).exists():
                raise serializers.ValidationError("Invalid delivery address")
        
        # Use customer's preferred pickup time if not specified
        if not attrs.get('pickup_time'):
            attrs['pickup_time'] = user.customer_profile.preferred_pickup_time
        
        return attrs
    
    def create(self, validated_data):
        user = self.context['user']
        
        # Handle pickup address
        pickup_address = self._get_or_create_address(
            user,
            validated_data.get('pickup_address_id'),
            validated_data.get('new_pickup_address'),
            validated_data.get('save_pickup_address', False),
            validated_data.get('pickup_address_nickname')
        )
        
        # Handle delivery address
        delivery_address = self._get_or_create_address(
            user,
            validated_data.get('delivery_address_id'),
            validated_data.get('new_delivery_address'),
            validated_data.get('save_delivery_address', False),
            validated_data.get('delivery_address_nickname')
        )
        
        # Create booking
        booking = Booking.objects.create(
            customer=user,
            service_type=validated_data['service_type'],
            pickup_date=validated_data['pickup_date'],
            pickup_time=validated_data['pickup_time'],
            pickup_address=pickup_address,
            delivery_address=delivery_address,
            special_instructions=validated_data.get('special_instructions', ''),
            coi_required=validated_data.get('coi_required', False),
            standard_delivery_item_count=validated_data.get('standard_delivery_item_count'),
            is_same_day_delivery=validated_data.get('is_same_day_delivery', False)
        )
        
        # Handle service-specific relationships
        if validated_data['service_type'] == 'mini_move':
            try:
                package = MiniMovePackage.objects.get(id=validated_data['mini_move_package_id'])
                booking.mini_move_package = package
            except MiniMovePackage.DoesNotExist:
                raise serializers.ValidationError("Invalid mini move package")
        
        elif validated_data['service_type'] == 'specialty_item':
            specialty_items = SpecialtyItem.objects.filter(
                id__in=validated_data.get('specialty_item_ids', [])
            )
            booking.save()  # Save first to get ID for M2M relationship
            booking.specialty_items.set(specialty_items)
        
        booking.save()  # Trigger pricing calculation
        return booking
    
    def _get_or_create_address(self, user, address_id, new_address_data, save_address, nickname):
        """Get existing saved address or create new one"""
        if address_id:
            # Use existing saved address
            saved_address = user.saved_addresses.get(id=address_id, is_active=True)
            
            # Create Address record for booking
            address = Address.objects.create(
                customer=user,
                address_line_1=saved_address.address_line_1,
                address_line_2=saved_address.address_line_2,
                city=saved_address.city,
                state=saved_address.state,
                zip_code=saved_address.zip_code
            )
            
            # Update usage tracking
            saved_address.mark_used()
            return address
        
        elif new_address_data:
            # Create new Address
            address = Address.objects.create(
                customer=user,
                **new_address_data
            )
            
            # Save as SavedAddress if requested
            if save_address:
                SavedAddress.objects.create(
                    user=user,
                    nickname=nickname or f"Address {user.saved_addresses.count() + 1}",
                    address_line_1=new_address_data['address_line_1'],
                    address_line_2=new_address_data.get('address_line_2', ''),
                    city=new_address_data['city'],
                    state=new_address_data['state'],
                    zip_code=new_address_data['zip_code'],
                    delivery_instructions=new_address_data.get('delivery_instructions', ''),
                    times_used=1
                )
            
            return address


class CustomerBookingDetailSerializer(serializers.ModelSerializer):
    """Detailed booking information for authenticated customers"""
    
    customer_name = serializers.SerializerMethodField()
    pickup_address = serializers.SerializerMethodField()
    delivery_address = serializers.SerializerMethodField()
    total_price_dollars = serializers.ReadOnlyField()
    pricing_breakdown = serializers.SerializerMethodField()
    payment_status = serializers.SerializerMethodField()
    can_rebook = serializers.SerializerMethodField()
    
    class Meta:
        model = Booking
        fields = (
            'id', 'booking_number', 'customer_name', 
            'service_type', 'pickup_date', 'pickup_time', 'status',
            'pickup_address', 'delivery_address',
            'special_instructions', 'coi_required',
            'total_price_dollars', 'pricing_breakdown',
            'payment_status', 'can_rebook', 'created_at', 'updated_at'
        )
    
    def get_customer_name(self, obj):
        return obj.get_customer_name()
    
    def get_pickup_address(self, obj):
        return {
            'address_line_1': obj.pickup_address.address_line_1,
            'address_line_2': obj.pickup_address.address_line_2,
            'city': obj.pickup_address.city,
            'state': obj.pickup_address.state,
            'zip_code': obj.pickup_address.zip_code
        }
    
    def get_delivery_address(self, obj):
        return {
            'address_line_1': obj.delivery_address.address_line_1,
            'address_line_2': obj.delivery_address.address_line_2,
            'city': obj.delivery_address.city,
            'state': obj.delivery_address.state,
            'zip_code': obj.delivery_address.zip_code
        }
    
    def get_pricing_breakdown(self, obj):
        return obj.get_pricing_breakdown()
    
    def get_payment_status(self, obj):
        payment = obj.payments.first()
        return payment.status if payment else 'not_created'
    
    def get_can_rebook(self, obj):
        return obj.status in ['completed', 'paid']


class QuickBookingSerializer(serializers.Serializer):
    """Serializer for quickly rebooking with minimal changes"""
    pickup_date = serializers.DateField()
    pickup_time = serializers.ChoiceField(
        choices=[
            ('morning', '8 AM - 11 AM'),
            ('afternoon', '12 PM - 3 PM'),
            ('evening', '4 PM - 7 PM'),
        ],
        required=False
    )
    is_same_day_delivery = serializers.BooleanField(default=False)
    special_instructions = serializers.CharField(required=False, allow_blank=True)
    coi_required = serializers.BooleanField(required=False)
```

# ==== apps/customers/booking_views.py ====

```python
from rest_framework import generics, status, permissions
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.shortcuts import get_object_or_404
from .models import CustomerProfile, SavedAddress, CustomerPaymentMethod
from apps.bookings.models import Booking, Address
from apps.payments.services import StripePaymentService
from .serializers import SavedAddressSerializer
from .booking_serializers import (
    AuthenticatedBookingCreateSerializer,
    CustomerBookingDetailSerializer,
    QuickBookingSerializer
)


class CustomerBookingCreateView(APIView):
    """Create booking for authenticated customers with enhanced features"""
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        # Ensure user has customer profile
        if not hasattr(request.user, 'customer_profile'):
            return Response(
                {'error': 'This is not a customer account'}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        serializer = AuthenticatedBookingCreateSerializer(
            data=request.data,
            context={'user': request.user}
        )
        serializer.is_valid(raise_exception=True)
        booking = serializer.save()
        
        # Automatically create payment intent for seamless experience
        create_payment_intent = request.data.get('create_payment_intent', True)
        payment_data = None
        
        if create_payment_intent:
            try:
                payment_data = StripePaymentService.create_payment_intent(
                    booking=booking,
                    customer_email=request.user.email
                )
            except Exception as e:
                # Don't fail booking creation if payment intent fails
                payment_data = {'error': str(e)}
        
        response_data = {
            'message': 'Booking created successfully',
            'booking': CustomerBookingDetailSerializer(booking).data
        }
        
        if payment_data and 'error' not in payment_data:
            response_data['payment'] = {
                'client_secret': payment_data['client_secret'],
                'payment_intent_id': payment_data['payment_intent_id']
            }
        
        return Response(response_data, status=status.HTTP_201_CREATED)


class QuickRebookView(APIView):
    """Quickly rebook a previous booking with minimal changes"""
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request, booking_id):
        try:
            # Get original booking - must belong to this customer
            original_booking = Booking.objects.get(
                id=booking_id,
                customer=request.user,
                deleted_at__isnull=True
            )
        except Booking.DoesNotExist:
            return Response(
                {'error': 'Original booking not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        
        serializer = QuickBookingSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        # Create new booking based on original
        new_booking = Booking.objects.create(
            customer=request.user,
            service_type=original_booking.service_type,
            mini_move_package=original_booking.mini_move_package,
            standard_delivery_item_count=original_booking.standard_delivery_item_count,
            is_same_day_delivery=serializer.validated_data.get('is_same_day_delivery', False),
            pickup_date=serializer.validated_data['pickup_date'],
            pickup_time=serializer.validated_data.get('pickup_time', original_booking.pickup_time),
            pickup_address=original_booking.pickup_address,
            delivery_address=original_booking.delivery_address,
            special_instructions=serializer.validated_data.get('special_instructions', original_booking.special_instructions),
            coi_required=serializer.validated_data.get('coi_required', original_booking.coi_required)
        )
        
        # Copy specialty items if any
        if original_booking.specialty_items.exists():
            new_booking.specialty_items.set(original_booking.specialty_items.all())
        
        new_booking.save()  # Trigger pricing calculation
        
        # Create payment intent
        payment_data = StripePaymentService.create_payment_intent(
            booking=new_booking,
            customer_email=request.user.email
        )
        
        return Response({
            'message': 'Booking recreated successfully',
            'booking': CustomerBookingDetailSerializer(new_booking).data,
            'payment': {
                'client_secret': payment_data['client_secret'],
                'payment_intent_id': payment_data['payment_intent_id']
            }
        }, status=status.HTTP_201_CREATED)


class CustomerBookingDetailView(generics.RetrieveAPIView):
    """Get detailed booking information for authenticated customer"""
    serializer_class = CustomerBookingDetailSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return self.request.user.bookings.filter(deleted_at__isnull=True)
    
    def get_object(self):
        booking_id = self.kwargs.get('booking_id')
        return get_object_or_404(self.get_queryset(), id=booking_id)


class CustomerDashboardView(APIView):
    """Enhanced customer dashboard with booking insights"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        if not hasattr(request.user, 'customer_profile'):
            return Response(
                {'error': 'This is not a customer account'}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        customer_profile = request.user.customer_profile
        
        # Get bookings
        all_bookings = request.user.bookings.filter(deleted_at__isnull=True).order_by('-created_at')
        recent_bookings = all_bookings[:5]
        
        # Get booking statistics
        pending_bookings = all_bookings.filter(status__in=['pending', 'confirmed']).count()
        completed_bookings = all_bookings.filter(status='completed').count()
        
        # Get saved data
        saved_addresses = request.user.saved_addresses.filter(is_active=True)
        payment_methods = request.user.payment_methods.filter(is_active=True)
        
        # Get most used addresses
        popular_addresses = saved_addresses.order_by('-times_used')[:3]
        
        return Response({
            'customer_profile': {
                'name': request.user.get_full_name(),
                'email': request.user.email,
                'phone': customer_profile.phone,
                'is_vip': customer_profile.is_vip,
                'total_bookings': customer_profile.total_bookings,
                'total_spent_dollars': customer_profile.total_spent_dollars,
                'last_booking_at': customer_profile.last_booking_at
            },
            'booking_summary': {
                'pending_bookings': pending_bookings,
                'completed_bookings': completed_bookings,
                'total_bookings': all_bookings.count()
            },
            'recent_bookings': CustomerBookingDetailSerializer(recent_bookings, many=True).data,
            'saved_addresses_count': saved_addresses.count(),
            'payment_methods_count': payment_methods.count(),
            'popular_addresses': SavedAddressSerializer(popular_addresses, many=True).data
        })


class BookingPreferencesView(APIView):
    """Manage customer booking preferences"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        customer_profile = request.user.customer_profile
        
        return Response({
            'preferred_pickup_time': customer_profile.preferred_pickup_time,
            'email_notifications': customer_profile.email_notifications,
            'sms_notifications': customer_profile.sms_notifications,
            'default_addresses': {
                'most_used_pickup': self._get_most_used_address('pickup'),
                'most_used_delivery': self._get_most_used_address('delivery')
            }
        })
    
    def _get_most_used_address(self, address_type):
        # This is a simplified version - in production you'd track pickup vs delivery usage
        most_used = self.request.user.saved_addresses.filter(is_active=True).order_by('-times_used').first()
        return SavedAddressSerializer(most_used).data if most_used else None
```

# ==== apps/customers/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.5 on 2025-09-02 20:54

import django.core.validators
import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='CustomerPaymentMethod',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('stripe_payment_method_id', models.CharField(max_length=100, unique=True)),
                ('card_brand', models.CharField(max_length=20)),
                ('card_last_four', models.CharField(max_length=4)),
                ('card_exp_month', models.PositiveSmallIntegerField()),
                ('card_exp_year', models.PositiveSmallIntegerField()),
                ('is_default', models.BooleanField(default=False)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='payment_methods', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'customers_payment_method',
            },
        ),
        migrations.CreateModel(
            name='CustomerProfile',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('phone', models.CharField(blank=True, max_length=20, validators=[django.core.validators.RegexValidator(regex='^\\+?1?\\d{9,15}$')])),
                ('stripe_customer_id', models.CharField(blank=True, max_length=100)),
                ('total_bookings', models.PositiveIntegerField(default=0)),
                ('total_spent_cents', models.PositiveBigIntegerField(default=0)),
                ('last_booking_at', models.DateTimeField(blank=True, null=True)),
                ('preferred_pickup_time', models.CharField(choices=[('morning', '8 AM - 11 AM'), ('afternoon', '12 PM - 3 PM'), ('evening', '4 PM - 7 PM')], default='morning', max_length=20)),
                ('email_notifications', models.BooleanField(default=True)),
                ('sms_notifications', models.BooleanField(default=False)),
                ('is_vip', models.BooleanField(default=False)),
                ('notes', models.TextField(blank=True, help_text='Internal notes for staff')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='customer_profile', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'customers_profile',
            },
        ),
        migrations.CreateModel(
            name='SavedAddress',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('nickname', models.CharField(max_length=50)),
                ('address_line_1', models.CharField(max_length=200)),
                ('address_line_2', models.CharField(blank=True, max_length=200)),
                ('city', models.CharField(max_length=100)),
                ('state', models.CharField(choices=[('NY', 'New York'), ('CT', 'Connecticut'), ('NJ', 'New Jersey')], max_length=2)),
                ('zip_code', models.CharField(max_length=10)),
                ('delivery_instructions', models.TextField(blank=True)),
                ('times_used', models.PositiveIntegerField(default=0)),
                ('last_used_at', models.DateTimeField(blank=True, null=True)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='saved_addresses', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'customers_saved_address',
                'constraints': [models.UniqueConstraint(fields=('user', 'nickname'), name='unique_customer_address_nickname')],
            },
        ),
    ]
```

# ==== apps/customers/migrations/__init__.py ====

```python

```

# ==== apps/customers/models.py ====

```python
import uuid
from django.contrib.auth.models import User
from django.db import models
from django.core.validators import RegexValidator
from django.utils import timezone


class CustomerProfile(models.Model):
    """Customer profile linked to Django's User model"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='customer_profile')
    
    # Customer-specific fields
    phone = models.CharField(
        max_length=20, 
        validators=[RegexValidator(regex=r'^\+?1?\d{9,15}$')],
        blank=True
    )
    stripe_customer_id = models.CharField(max_length=100, blank=True)
    
    # Booking statistics
    total_bookings = models.PositiveIntegerField(default=0)
    total_spent_cents = models.PositiveBigIntegerField(default=0)
    last_booking_at = models.DateTimeField(null=True, blank=True)
    
    # Customer preferences
    preferred_pickup_time = models.CharField(
        max_length=20,
        choices=[
            ('morning', '8 AM - 11 AM'),
            ('afternoon', '12 PM - 3 PM'),
            ('evening', '4 PM - 7 PM'),
        ],
        default='morning'
    )
    
    email_notifications = models.BooleanField(default=True)
    sms_notifications = models.BooleanField(default=False)
    is_vip = models.BooleanField(default=False)
    notes = models.TextField(blank=True, help_text="Internal notes for staff")
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'customers_profile'
    
    def __str__(self):
        return f"Profile: {self.user.get_full_name()}"
    
    @property
    def total_spent_dollars(self):
        return self.total_spent_cents / 100
    
    def add_booking_stats(self, booking_total_cents):
        """Update customer statistics after booking completion"""
        self.total_bookings += 1
        self.total_spent_cents += booking_total_cents
        self.last_booking_at = timezone.now()
        self.save()


class SavedAddress(models.Model):
    """Customer's saved addresses"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='saved_addresses')
    
    nickname = models.CharField(max_length=50)
    address_line_1 = models.CharField(max_length=200)
    address_line_2 = models.CharField(max_length=200, blank=True)
    city = models.CharField(max_length=100)
    state = models.CharField(max_length=2, choices=[
        ('NY', 'New York'),
        ('CT', 'Connecticut'), 
        ('NJ', 'New Jersey'),
    ])
    zip_code = models.CharField(max_length=10)
    delivery_instructions = models.TextField(blank=True)
    
    times_used = models.PositiveIntegerField(default=0)
    last_used_at = models.DateTimeField(null=True, blank=True)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'customers_saved_address'
        constraints = [
            models.UniqueConstraint(
                fields=['user', 'nickname'], 
                name='unique_customer_address_nickname'
            )
        ]
    
    def __str__(self):
        return f"{self.user.get_full_name()} - {self.nickname}"
    
    @property
    def formatted_address(self):
        parts = [
            self.address_line_1,
            self.address_line_2,
            f"{self.city}, {self.state} {self.zip_code}"
        ]
        return ', '.join(filter(None, parts))
    
    def mark_used(self):
        self.times_used += 1
        self.last_used_at = timezone.now()
        self.save()


class CustomerPaymentMethod(models.Model):
    """Customer's saved payment methods"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='payment_methods')
    
    stripe_payment_method_id = models.CharField(max_length=100, unique=True)
    card_brand = models.CharField(max_length=20)
    card_last_four = models.CharField(max_length=4)
    card_exp_month = models.PositiveSmallIntegerField()
    card_exp_year = models.PositiveSmallIntegerField()
    is_default = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'customers_payment_method'
    
    def __str__(self):
        return f"{self.user.get_full_name()} - {self.card_brand} ****{self.card_last_four}"
    
    @property
    def display_name(self):
        return f"{self.card_brand.title()} ending in {self.card_last_four}"
    
    def save(self, *args, **kwargs):
        if self.is_default:
            CustomerPaymentMethod.objects.filter(
                user=self.user, 
                is_default=True
            ).exclude(id=self.id).update(is_default=False)
        super().save(*args, **kwargs)
```

# ==== apps/customers/serializers.py ====

```python
from rest_framework import serializers
from django.contrib.auth.models import User
from django.contrib.auth import authenticate
from .models import CustomerProfile, SavedAddress, CustomerPaymentMethod


class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ('id', 'username', 'email', 'first_name', 'last_name', 'date_joined')
        read_only_fields = ('id', 'username', 'date_joined')


class CustomerProfileSerializer(serializers.ModelSerializer):
    user = UserSerializer(read_only=True)
    total_spent_dollars = serializers.ReadOnlyField()
    
    class Meta:
        model = CustomerProfile
        fields = (
            'id', 'user', 'phone', 'total_bookings', 'total_spent_cents', 
            'total_spent_dollars', 'last_booking_at', 'preferred_pickup_time',
            'email_notifications', 'sms_notifications', 'is_vip'
        )
        read_only_fields = ('id', 'total_bookings', 'total_spent_cents', 'last_booking_at', 'is_vip')


class CustomerRegistrationSerializer(serializers.Serializer):
    email = serializers.EmailField()
    password = serializers.CharField(min_length=8, write_only=True)
    password_confirm = serializers.CharField(write_only=True)
    first_name = serializers.CharField(max_length=150)
    last_name = serializers.CharField(max_length=150)
    phone = serializers.CharField(max_length=20, required=False, allow_blank=True)
    
    def validate(self, attrs):
        if attrs['password'] != attrs['password_confirm']:
            raise serializers.ValidationError("Passwords don't match")
        
        if User.objects.filter(email=attrs['email']).exists():
            raise serializers.ValidationError("User with this email already exists")
        
        return attrs
    
    def create(self, validated_data):
        # Remove password_confirm from validated_data
        validated_data.pop('password_confirm')
        phone = validated_data.pop('phone', '')
        
        # Create User (use email as username for customers)
        user = User.objects.create_user(
            username=validated_data['email'],
            email=validated_data['email'],
            password=validated_data['password'],
            first_name=validated_data['first_name'],
            last_name=validated_data['last_name']
        )
        
        # Create CustomerProfile
        CustomerProfile.objects.create(
            user=user,
            phone=phone
        )
        
        return user


class CustomerLoginSerializer(serializers.Serializer):
    email = serializers.EmailField()
    password = serializers.CharField(write_only=True)
    
    def validate(self, attrs):
        email = attrs.get('email')
        password = attrs.get('password')
        
        if email and password:
            # Authenticate using email (stored as username for customers)
            user = authenticate(username=email, password=password)
            
            if user:
                if not user.is_active:
                    raise serializers.ValidationError("User account is disabled")
                
                # Ensure user has a customer profile
                if not hasattr(user, 'customer_profile'):
                    raise serializers.ValidationError("This is not a customer account")
                
                attrs['user'] = user
                return attrs
            else:
                raise serializers.ValidationError("Invalid email or password")
        else:
            raise serializers.ValidationError("Must include email and password")


class SavedAddressSerializer(serializers.ModelSerializer):
    formatted_address = serializers.ReadOnlyField()
    
    class Meta:
        model = SavedAddress
        fields = (
            'id', 'nickname', 'address_line_1', 'address_line_2', 
            'city', 'state', 'zip_code', 'delivery_instructions',
            'formatted_address', 'times_used', 'last_used_at', 'is_active'
        )
        read_only_fields = ('id', 'times_used', 'last_used_at')
```

# ==== apps/customers/tests.py ====

```python

```

# ==== apps/customers/urls.py ====

```python
from django.urls import path
from . import views, booking_views

# API patterns with both authentication and booking functionality
urlpatterns = [
    # CSRF token endpoint
    path('csrf-token/', views.CSRFTokenView.as_view(), name='csrf-token'),
    
    # Authentication endpoints
    path('auth/register/', views.CustomerRegistrationView.as_view(), name='customer-register'),
    path('auth/login/', views.CustomerLoginView.as_view(), name='customer-login'),
    path('auth/logout/', views.CustomerLogoutView.as_view(), name='customer-logout'),
    path('auth/user/', views.CurrentUserView.as_view(), name='current-user'),
    
    # Profile management
    path('profile/', views.CustomerProfileView.as_view(), name='customer-profile'),
    path('addresses/', views.SavedAddressListCreateView.as_view(), name='saved-addresses'),
    path('addresses/<uuid:pk>/', views.SavedAddressDetailView.as_view(), name='saved-address-detail'),
    
    # Enhanced customer dashboard and preferences
    path('dashboard/', booking_views.CustomerDashboardView.as_view(), name='customer-dashboard'),
    path('preferences/', booking_views.BookingPreferencesView.as_view(), name='booking-preferences'),
    
    # Authenticated booking management
    path('bookings/', views.CustomerBookingListView.as_view(), name='customer-bookings'),
    path('bookings/create/', booking_views.CustomerBookingCreateView.as_view(), name='customer-booking-create'),
    path('bookings/<uuid:booking_id>/', booking_views.CustomerBookingDetailView.as_view(), name='customer-booking-detail'),
    path('bookings/<uuid:booking_id>/rebook/', booking_views.QuickRebookView.as_view(), name='quick-rebook'),
]
```

# ==== apps/customers/views.py ====

```python
from rest_framework import generics, status, permissions
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.contrib.auth import login, logout
from django.contrib.auth.models import User
from django.middleware.csrf import get_token
from django.views.decorators.csrf import ensure_csrf_cookie
from django.utils.decorators import method_decorator
from .models import CustomerProfile, SavedAddress
from .serializers import (
    CustomerRegistrationSerializer, 
    CustomerLoginSerializer,
    CustomerProfileSerializer,
    UserSerializer,
    SavedAddressSerializer
)


@method_decorator(ensure_csrf_cookie, name='dispatch')
class CustomerRegistrationView(generics.CreateAPIView):
    """Register new customer account"""
    serializer_class = CustomerRegistrationSerializer
    permission_classes = [permissions.AllowAny]
    
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.save()
        
        return Response({
            'message': 'Account created successfully',
            'user': UserSerializer(user).data,
            'customer_profile': CustomerProfileSerializer(user.customer_profile).data,
            'csrf_token': get_token(request)
        }, status=status.HTTP_201_CREATED)


@method_decorator(ensure_csrf_cookie, name='dispatch')
class CustomerLoginView(APIView):
    """Customer login endpoint"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = CustomerLoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        user = serializer.validated_data['user']
        login(request, user)
        
        return Response({
            'message': 'Login successful',
            'user': UserSerializer(user).data,
            'customer_profile': CustomerProfileSerializer(user.customer_profile).data,
            'csrf_token': get_token(request)
        })


class CustomerLogoutView(APIView):
    """Customer logout endpoint"""
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        logout(request)
        return Response({'message': 'Logout successful'})


class CurrentUserView(APIView):
    """Get current authenticated user info"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        if hasattr(request.user, 'customer_profile'):
            return Response({
                'user': UserSerializer(request.user).data,
                'customer_profile': CustomerProfileSerializer(request.user.customer_profile).data,
                'csrf_token': get_token(request)
            })
        else:
            return Response({'error': 'Not a customer account'}, status=status.HTTP_403_FORBIDDEN)


class CSRFTokenView(APIView):
    """Get CSRF token for authenticated requests"""
    permission_classes = [permissions.AllowAny]
    
    @method_decorator(ensure_csrf_cookie)
    def get(self, request):
        return Response({
            'csrf_token': get_token(request)
        })


class CustomerProfileView(generics.RetrieveUpdateAPIView):
    """Customer profile management"""
    serializer_class = CustomerProfileSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_object(self):
        return self.request.user.customer_profile


class SavedAddressListCreateView(generics.ListCreateAPIView):
    """List and create saved addresses"""
    serializer_class = SavedAddressSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return self.request.user.saved_addresses.filter(is_active=True)
    
    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class SavedAddressDetailView(generics.RetrieveUpdateDestroyAPIView):
    """Retrieve, update, delete saved address"""
    serializer_class = SavedAddressSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return self.request.user.saved_addresses.all()


class CustomerBookingListView(generics.ListAPIView):
    """Customer booking history"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return self.request.user.bookings.all().order_by('-created_at')
    
    def get(self, request, *args, **kwargs):
        bookings = self.get_queryset()
        booking_data = []
        
        for booking in bookings:
            booking_data.append({
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'service_type': booking.get_service_type_display(),
                'status': booking.get_status_display(),
                'pickup_date': booking.pickup_date,
                'total_price': booking.total_price_dollars,
                'created_at': booking.created_at
            })
        
        return Response({
            'bookings': booking_data,
            'total_count': len(booking_data)
        })
```

# ==== apps/documents/__init__.py ====

```python

```

# ==== apps/documents/admin.py ====

```python
from django.contrib import admin

# Register your models here.
```

# ==== apps/documents/apps.py ====

```python
from django.apps import AppConfig


class DocumentsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.documents'
```

# ==== apps/documents/migrations/__init__.py ====

```python

```

# ==== apps/documents/models.py ====

```python
from django.db import models

# Create your models here.
```

# ==== apps/documents/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/documents/views.py ====

```python
from django.shortcuts import render

# Create your views here.
```

# ==== apps/logistics/__init__.py ====

```python

```

# ==== apps/logistics/admin.py ====

```python
from django.contrib import admin

# Register your models here.
```

# ==== apps/logistics/apps.py ====

```python
from django.apps import AppConfig


class LogisticsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.logistics'
```

# ==== apps/logistics/migrations/__init__.py ====

```python

```

# ==== apps/logistics/models.py ====

```python
from django.db import models

# Create your models here.
```

# ==== apps/logistics/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/logistics/views.py ====

```python
from django.shortcuts import render

# Create your views here.
```

# ==== apps/notifications/__init__.py ====

```python

```

# ==== apps/notifications/admin.py ====

```python
from django.contrib import admin

# Register your models here.
```

# ==== apps/notifications/apps.py ====

```python
from django.apps import AppConfig


class NotificationsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.notifications'
```

# ==== apps/notifications/migrations/__init__.py ====

```python

```

# ==== apps/notifications/models.py ====

```python
from django.db import models

# Create your models here.
```

# ==== apps/notifications/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/notifications/views.py ====

```python
from django.shortcuts import render

# Create your views here.
```

# ==== apps/payments/__init__.py ====

```python

```

# ==== apps/payments/admin.py ====

```python
from django.contrib import admin
from django.utils.html import format_html
from .models import Payment, Refund, PaymentAudit

@admin.register(Payment)
class PaymentAdmin(admin.ModelAdmin):
    list_display = (
        'booking', 
        'get_customer_name', 
        'amount_dollars', 
        'status', 
        'get_status_badge',
        'created_at',
        'processed_at'
    )
    list_filter = ('status', 'created_at', 'processed_at')
    search_fields = (
        'booking__booking_number', 
        'customer__email', 
        'stripe_payment_intent_id',
        'stripe_charge_id'
    )
    readonly_fields = ('created_at', 'updated_at', 'processed_at')
    
    fieldsets = (
        ('Booking & Customer', {
            'fields': ('booking', 'customer')
        }),
        ('Payment Details', {
            'fields': ('amount_cents', 'status', 'failure_reason')
        }),
        ('Stripe Integration', {
            'fields': ('stripe_payment_intent_id', 'stripe_charge_id')
        }),
        ('Timestamps', {
            'fields': ('processed_at', 'created_at', 'updated_at'),
            'classes': ('collapse',)
        })
    )
    
    def get_customer_name(self, obj):
        if obj.customer:
            return obj.customer.full_name
        else:
            return obj.booking.get_customer_name()
    get_customer_name.short_description = 'Customer'
    
    def get_status_badge(self, obj):
        colors = {
            'pending': 'orange',
            'succeeded': 'green',
            'failed': 'red',
            'refunded': 'blue'
        }
        color = colors.get(obj.status, 'gray')
        return format_html(
            '<span style="color: {}; font-weight: bold;">{}</span>',
            color,
            obj.get_status_display()
        )
    get_status_badge.short_description = 'Status'

@admin.register(Refund)
class RefundAdmin(admin.ModelAdmin):
    list_display = (
        'payment',
        'get_booking_number',
        'amount_dollars',
        'status',
        'get_status_badge',
        'requested_by',
        'approved_by',
        'created_at'
    )
    list_filter = ('status', 'created_at', 'approved_at')
    search_fields = (
        'payment__booking__booking_number',
        'reason',
        'requested_by__email',
        'approved_by__email'
    )
    readonly_fields = ('created_at', 'approved_at', 'completed_at')
    
    fieldsets = (
        ('Refund Details', {
            'fields': ('payment', 'amount_cents', 'reason')
        }),
        ('Approval Workflow', {
            'fields': ('status', 'requested_by', 'approved_by')
        }),
        ('Stripe Integration', {
            'fields': ('stripe_refund_id',)
        }),
        ('Timestamps', {
            'fields': ('approved_at', 'completed_at', 'created_at'),
            'classes': ('collapse',)
        })
    )
    
    actions = ['approve_refunds', 'deny_refunds']
    
    def get_booking_number(self, obj):
        return obj.payment.booking.booking_number
    get_booking_number.short_description = 'Booking #'
    
    def get_status_badge(self, obj):
        colors = {
            'requested': 'orange',
            'approved': 'green',
            'denied': 'red',
            'completed': 'blue'
        }
        color = colors.get(obj.status, 'gray')
        return format_html(
            '<span style="color: {}; font-weight: bold;">{}</span>',
            color,
            obj.get_status_display()
        )
    get_status_badge.short_description = 'Status'
    
    def approve_refunds(self, request, queryset):
        """Bulk approve refunds (only if user is admin)"""
        if not request.user.can_approve_refunds:
            self.message_user(request, 'Only admin users can approve refunds.', level='ERROR')
            return
        
        approved_count = 0
        for refund in queryset.filter(status='requested'):
            try:
                refund.approve(request.user)
                approved_count += 1
            except ValueError as e:
                self.message_user(request, str(e), level='ERROR')
        
        if approved_count > 0:
            self.message_user(
                request, 
                f'Successfully approved {approved_count} refund(s).'
            )
    approve_refunds.short_description = "Approve selected refunds"
    
    def deny_refunds(self, request, queryset):
        """Bulk deny refunds"""
        if not request.user.can_approve_refunds:
            self.message_user(request, 'Only admin users can deny refunds.', level='ERROR')
            return
        
        denied_count = queryset.filter(status='requested').update(status='denied')
        self.message_user(
            request, 
            f'Successfully denied {denied_count} refund(s).'
        )
    deny_refunds.short_description = "Deny selected refunds"

@admin.register(PaymentAudit)
class PaymentAuditAdmin(admin.ModelAdmin):
    list_display = ('action', 'get_short_description', 'user', 'created_at')
    list_filter = ('action', 'created_at')
    search_fields = ('description', 'user__email')
    readonly_fields = ('created_at',)
    
    fieldsets = (
        ('Action Details', {
            'fields': ('action', 'description')
        }),
        ('Related Records', {
            'fields': ('payment', 'refund')
        }),
        ('User & Timestamp', {
            'fields': ('user', 'created_at')
        })
    )
    
    def get_short_description(self, obj):
        return obj.description[:50] + ('...' if len(obj.description) > 50 else '')
    get_short_description.short_description = 'Description'
    
    # Make it mostly read-only (audit logs shouldn't be edited)
    def has_add_permission(self, request):
        return False
    
    def has_change_permission(self, request, obj=None):
        return False
    
    def has_delete_permission(self, request, obj=None):
        return request.user.is_superuser  # Only superusers can delete audit logs
```

# ==== apps/payments/apps.py ====

```python
from django.apps import AppConfig


class PaymentsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.payments'
```

# ==== apps/payments/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.5 on 2025-09-02 20:54

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('bookings', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Payment',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('amount_cents', models.PositiveBigIntegerField()),
                ('stripe_payment_intent_id', models.CharField(blank=True, max_length=200)),
                ('stripe_charge_id', models.CharField(blank=True, max_length=200)),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('succeeded', 'Succeeded'), ('failed', 'Failed'), ('refunded', 'Refunded')], default='pending', max_length=20)),
                ('failure_reason', models.TextField(blank=True)),
                ('processed_at', models.DateTimeField(blank=True, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('booking', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='payments', to='bookings.booking')),
                ('customer', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='payments', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'payments_payment',
            },
        ),
        migrations.CreateModel(
            name='Refund',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('amount_cents', models.PositiveBigIntegerField()),
                ('reason', models.TextField()),
                ('status', models.CharField(choices=[('requested', 'Requested'), ('approved', 'Approved'), ('denied', 'Denied'), ('completed', 'Completed')], default='requested', max_length=20)),
                ('stripe_refund_id', models.CharField(blank=True, max_length=200)),
                ('approved_at', models.DateTimeField(blank=True, null=True)),
                ('completed_at', models.DateTimeField(blank=True, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('approved_by', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.PROTECT, related_name='approved_refunds', to=settings.AUTH_USER_MODEL)),
                ('payment', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='refunds', to='payments.payment')),
                ('requested_by', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='requested_refunds', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'payments_refund',
            },
        ),
        migrations.CreateModel(
            name='PaymentAudit',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('action', models.CharField(choices=[('payment_created', 'Payment Created'), ('payment_succeeded', 'Payment Succeeded'), ('payment_failed', 'Payment Failed'), ('refund_requested', 'Refund Requested'), ('refund_approved', 'Refund Approved'), ('refund_completed', 'Refund Completed')], max_length=30)),
                ('description', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('payment', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='payments.payment')),
                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL)),
                ('refund', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='payments.refund')),
            ],
            options={
                'db_table': 'payments_audit',
                'ordering': ['-created_at'],
            },
        ),
    ]
```

# ==== apps/payments/migrations/__init__.py ====

```python

```

# ==== apps/payments/models.py ====

```python
import uuid
from django.db import models
from django.utils import timezone
from django.contrib.auth.models import User


class Payment(models.Model):
    """Payment records for bookings - simple Stripe integration"""
    
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('succeeded', 'Succeeded'),
        ('failed', 'Failed'),
        ('refunded', 'Refunded'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Link to booking
    booking = models.ForeignKey(
        'bookings.Booking',
        on_delete=models.PROTECT,
        related_name='payments'
    )
    
    # Customer (if authenticated)
    customer = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='payments'
    )
    
    # Payment amount
    amount_cents = models.PositiveBigIntegerField()
    
    # Stripe integration
    stripe_payment_intent_id = models.CharField(max_length=200, blank=True)
    stripe_charge_id = models.CharField(max_length=200, blank=True)
    
    # Status
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    failure_reason = models.TextField(blank=True)
    
    # Timestamps
    processed_at = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'payments_payment'
    
    def __str__(self):
        return f"{self.booking.booking_number} - ${self.amount_dollars} ({self.status})"
    
    @property
    def amount_dollars(self):
        return self.amount_cents / 100


class Refund(models.Model):
    """Refund requests with simple approval workflow"""
    
    STATUS_CHOICES = [
        ('requested', 'Requested'),
        ('approved', 'Approved'),
        ('denied', 'Denied'),
        ('completed', 'Completed'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Original payment
    payment = models.ForeignKey(
        Payment,
        on_delete=models.PROTECT,
        related_name='refunds'
    )
    
    # Refund details
    amount_cents = models.PositiveBigIntegerField()
    reason = models.TextField()
    
    # Approval workflow
    requested_by = models.ForeignKey(
        User,
        on_delete=models.PROTECT,
        related_name='requested_refunds'
    )
    approved_by = models.ForeignKey(
        User,
        on_delete=models.PROTECT,
        null=True,
        blank=True,
        related_name='approved_refunds'
    )
    
    # Status and Stripe
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='requested')
    stripe_refund_id = models.CharField(max_length=200, blank=True)
    
    # Timestamps
    approved_at = models.DateTimeField(null=True, blank=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'payments_refund'
    
    def __str__(self):
        return f"Refund ${self.amount_dollars} for {self.payment.booking.booking_number}"
    
    @property
    def amount_dollars(self):
        return self.amount_cents / 100
    
    def approve(self, admin_user):
        """Admin approves refund"""
        self.status = 'approved'
        self.approved_by = admin_user
        self.approved_at = timezone.now()
        self.save()


class PaymentAudit(models.Model):
    """Basic audit log for financial compliance"""
    
    ACTION_CHOICES = [
        ('payment_created', 'Payment Created'),
        ('payment_succeeded', 'Payment Succeeded'),
        ('payment_failed', 'Payment Failed'),
        ('refund_requested', 'Refund Requested'),
        ('refund_approved', 'Refund Approved'),
        ('refund_completed', 'Refund Completed'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # What happened
    action = models.CharField(max_length=30, choices=ACTION_CHOICES)
    description = models.TextField()
    
    # Related records
    payment = models.ForeignKey(Payment, on_delete=models.CASCADE, null=True, blank=True)
    refund = models.ForeignKey(Refund, on_delete=models.CASCADE, null=True, blank=True)
    
    # Who did it (staff user)
    user = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'payments_audit'
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.action} - {self.created_at}"
    
    @classmethod
    def log(cls, action, description, payment=None, refund=None, user=None):
        """Simple audit logging"""
        return cls.objects.create(
            action=action,
            description=description,
            payment=payment,
            refund=refund,
            user=user
        )
```

# ==== apps/payments/serializers.py ====

```python
from rest_framework import serializers
from .models import Payment, Refund
from apps.bookings.models import Booking


class PaymentIntentCreateSerializer(serializers.Serializer):
    """Serializer for creating payment intent"""
    booking_id = serializers.UUIDField()
    customer_email = serializers.EmailField(required=False)
    
    def validate_booking_id(self, value):
        try:
            booking = Booking.objects.get(id=value, deleted_at__isnull=True)
            if booking.status in ['paid', 'completed']:
                raise serializers.ValidationError("Booking is already paid")
            return value
        except Booking.DoesNotExist:
            raise serializers.ValidationError("Booking not found")


class PaymentSerializer(serializers.ModelSerializer):
    amount_dollars = serializers.ReadOnlyField()
    booking_number = serializers.SerializerMethodField()
    customer_name = serializers.SerializerMethodField()
    
    class Meta:
        model = Payment
        fields = (
            'id', 'booking_number', 'customer_name', 'amount_cents', 
            'amount_dollars', 'status', 'stripe_payment_intent_id',
            'stripe_charge_id', 'failure_reason', 'processed_at', 'created_at'
        )
        read_only_fields = ('id', 'created_at')
    
    def get_booking_number(self, obj):
        return obj.booking.booking_number
    
    def get_customer_name(self, obj):
        return obj.booking.get_customer_name()


class PaymentConfirmSerializer(serializers.Serializer):
    """Serializer for payment confirmation webhook"""
    payment_intent_id = serializers.CharField()
    status = serializers.ChoiceField(choices=['succeeded', 'failed'])
    failure_reason = serializers.CharField(required=False, allow_blank=True)


class RefundCreateSerializer(serializers.Serializer):
    """Serializer for creating refunds"""
    payment_id = serializers.UUIDField()
    amount_cents = serializers.IntegerField(min_value=1)
    reason = serializers.CharField(max_length=500)
    
    def validate_payment_id(self, value):
        try:
            payment = Payment.objects.get(id=value, status='succeeded')
            return value
        except Payment.DoesNotExist:
            raise serializers.ValidationError("Payment not found or not succeeded")
    
    def validate(self, attrs):
        try:
            payment = Payment.objects.get(id=attrs['payment_id'])
            if attrs['amount_cents'] > payment.amount_cents:
                raise serializers.ValidationError("Refund amount cannot exceed payment amount")
        except Payment.DoesNotExist:
            pass  # Already handled in validate_payment_id
        return attrs


class RefundSerializer(serializers.ModelSerializer):
    amount_dollars = serializers.ReadOnlyField()
    payment_booking_number = serializers.SerializerMethodField()
    requested_by_name = serializers.SerializerMethodField()
    approved_by_name = serializers.SerializerMethodField()
    
    class Meta:
        model = Refund
        fields = (
            'id', 'payment_booking_number', 'amount_cents', 'amount_dollars',
            'reason', 'status', 'requested_by_name', 'approved_by_name',
            'approved_at', 'completed_at', 'created_at'
        )
        read_only_fields = ('id', 'created_at')
    
    def get_payment_booking_number(self, obj):
        return obj.payment.booking.booking_number
    
    def get_requested_by_name(self, obj):
        return obj.requested_by.get_full_name() if obj.requested_by else None
    
    def get_approved_by_name(self, obj):
        return obj.approved_by.get_full_name() if obj.approved_by else None
```

# ==== apps/payments/services.py ====

```python
import stripe
from django.conf import settings
from decimal import Decimal
from .models import Payment, PaymentAudit
from apps.bookings.models import Booking

# Mock Stripe for development - replace with real keys in production
stripe.api_key = "sk_test_mock_key_for_development"


class StripePaymentService:
    """Service layer for Stripe payment processing"""
    
    @staticmethod
    def create_payment_intent(booking, customer_email=None):
        """Create Stripe PaymentIntent for a booking"""
        try:
            # Mock PaymentIntent creation for development
            # In production, this would be: stripe.PaymentIntent.create(...)
            mock_intent = {
                'id': f'pi_mock_{booking.id.hex[:16]}',
                'client_secret': f'pi_mock_{booking.id.hex[:16]}_secret_mock',
                'amount': int(booking.total_price_cents),
                'currency': 'usd',
                'status': 'requires_payment_method'
            }
            
            # Create Payment record
            payment = Payment.objects.create(
                booking=booking,
                customer=booking.customer if hasattr(booking, 'customer') else None,
                amount_cents=booking.total_price_cents,
                stripe_payment_intent_id=mock_intent['id'],
                status='pending'
            )
            
            # Log payment creation
            PaymentAudit.log(
                action='payment_created',
                description=f'PaymentIntent created for booking {booking.booking_number}',
                payment=payment,
                user=None  # System action
            )
            
            return {
                'payment': payment,
                'client_secret': mock_intent['client_secret'],
                'payment_intent_id': mock_intent['id']
            }
            
        except Exception as e:
            # In production, this would catch actual Stripe exceptions
            raise Exception(f"Failed to create PaymentIntent: {str(e)}")
    
    @staticmethod
    def confirm_payment(payment_intent_id):
        """Mock payment confirmation - in production would verify with Stripe"""
        try:
            payment = Payment.objects.get(stripe_payment_intent_id=payment_intent_id)
            
            # Mock successful payment
            payment.status = 'succeeded'
            payment.stripe_charge_id = f'ch_mock_{payment.id.hex[:16]}'
            payment.save()
            
            # Update booking status
            booking = payment.booking
            booking.status = 'paid'
            booking.save()
            
            # Log payment success
            PaymentAudit.log(
                action='payment_succeeded',
                description=f'Payment confirmed for booking {booking.booking_number}',
                payment=payment,
                user=None
            )
            
            return payment
            
        except Payment.DoesNotExist:
            raise Exception("Payment not found")
    
    @staticmethod
    def create_refund(payment, amount_cents, reason, requested_by_user):
        """Create refund for a payment"""
        from .models import Refund
        
        try:
            # Mock refund creation
            mock_refund_id = f're_mock_{payment.id.hex[:16]}'
            
            refund = Refund.objects.create(
                payment=payment,
                amount_cents=amount_cents,
                reason=reason,
                requested_by=requested_by_user,
                stripe_refund_id=mock_refund_id,
                status='requested'
            )
            
            # Log refund request
            PaymentAudit.log(
                action='refund_requested',
                description=f'Refund requested for payment {payment.id}',
                payment=payment,
                refund=refund,
                user=requested_by_user
            )
            
            return refund
            
        except Exception as e:
            raise Exception(f"Failed to create refund: {str(e)}")
```

# ==== apps/payments/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/payments/urls.py ====

```python
from django.urls import path
from . import views

# Payment API patterns
urlpatterns = [
    # Public payment endpoints (no authentication required)
    path('create-intent/', views.PaymentIntentCreateView.as_view(), name='payment-intent-create'),
    path('status/<str:booking_number>/', views.PaymentStatusView.as_view(), name='payment-status'),
    path('webhook/', views.StripeWebhookView.as_view(), name='stripe-webhook'),
    
    # Mock payment confirmation (for testing only)
    path('mock-confirm/', views.MockPaymentConfirmView.as_view(), name='mock-payment-confirm'),
    
    # Staff payment management (authentication required)
    path('payments/', views.PaymentListView.as_view(), name='payment-list'),
    path('refunds/', views.RefundListView.as_view(), name='refund-list'),
    path('refunds/create/', views.RefundCreateView.as_view(), name='refund-create'),
]
```

# ==== apps/payments/views.py ====

```python
from rest_framework import generics, status, permissions
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.shortcuts import get_object_or_404
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from django.http import HttpResponse
from .models import Payment, Refund
from .serializers import (
    PaymentIntentCreateSerializer,
    PaymentSerializer,
    PaymentConfirmSerializer,
    RefundCreateSerializer,
    RefundSerializer
)
from .services import StripePaymentService
from apps.bookings.models import Booking


class PaymentIntentCreateView(APIView):
    """Create Stripe PaymentIntent for a booking - no authentication required for guest bookings"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = PaymentIntentCreateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        booking_id = serializer.validated_data['booking_id']
        customer_email = serializer.validated_data.get('customer_email')
        
        try:
            booking = Booking.objects.get(id=booking_id, deleted_at__isnull=True)
            
            # Check if payment already exists
            existing_payment = Payment.objects.filter(booking=booking).first()
            if existing_payment and existing_payment.status == 'succeeded':
                return Response(
                    {'error': 'Booking is already paid'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Create PaymentIntent
            payment_data = StripePaymentService.create_payment_intent(
                booking=booking,
                customer_email=customer_email
            )
            
            return Response({
                'payment_intent_id': payment_data['payment_intent_id'],
                'client_secret': payment_data['client_secret'],
                'amount_cents': booking.total_price_cents,
                'amount_dollars': booking.total_price_dollars,
                'booking_number': booking.booking_number
            })
            
        except Booking.DoesNotExist:
            return Response(
                {'error': 'Booking not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class PaymentStatusView(APIView):
    """Check payment status by booking number - no authentication required"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request, booking_number):
        try:
            booking = Booking.objects.get(booking_number=booking_number, deleted_at__isnull=True)
            payment = Payment.objects.filter(booking=booking).first()
            
            if not payment:
                return Response({
                    'booking_number': booking_number,
                    'payment_status': 'not_created',
                    'booking_status': booking.status
                })
            
            return Response({
                'booking_number': booking_number,
                'payment_status': payment.status,
                'booking_status': booking.status,
                'amount_dollars': payment.amount_dollars,
                'processed_at': payment.processed_at
            })
            
        except Booking.DoesNotExist:
            return Response(
                {'error': 'Booking not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )


@method_decorator(csrf_exempt, name='dispatch')
class StripeWebhookView(APIView):
    """Handle Stripe webhooks - no authentication required"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        # In production, you'd verify the webhook signature here
        # For development, we'll mock the webhook processing
        
        try:
            event_type = request.data.get('type', '')
            
            if event_type == 'payment_intent.succeeded':
                payment_intent = request.data.get('data', {}).get('object', {})
                payment_intent_id = payment_intent.get('id')
                
                if payment_intent_id:
                    # Confirm payment
                    payment = StripePaymentService.confirm_payment(payment_intent_id)
                    return Response({'status': 'success'})
            
            elif event_type == 'payment_intent.payment_failed':
                payment_intent = request.data.get('data', {}).get('object', {})
                payment_intent_id = payment_intent.get('id')
                
                if payment_intent_id:
                    try:
                        payment = Payment.objects.get(stripe_payment_intent_id=payment_intent_id)
                        payment.status = 'failed'
                        payment.failure_reason = payment_intent.get('last_payment_error', {}).get('message', 'Payment failed')
                        payment.save()
                        
                        # Update booking status
                        payment.booking.status = 'pending'
                        payment.booking.save()
                        
                    except Payment.DoesNotExist:
                        pass
            
            return Response({'status': 'received'})
            
        except Exception as e:
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_400_BAD_REQUEST
            )


# Mock payment confirmation for testing (remove in production)
class MockPaymentConfirmView(APIView):
    """Mock payment confirmation for testing - no authentication required"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = PaymentConfirmSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        payment_intent_id = serializer.validated_data['payment_intent_id']
        status_value = serializer.validated_data['status']
        
        try:
            if status_value == 'succeeded':
                payment = StripePaymentService.confirm_payment(payment_intent_id)
                return Response({
                    'message': 'Payment confirmed successfully',
                    'payment': PaymentSerializer(payment).data
                })
            else:
                # Handle failed payment
                payment = Payment.objects.get(stripe_payment_intent_id=payment_intent_id)
                payment.status = 'failed'
                payment.failure_reason = serializer.validated_data.get('failure_reason', 'Payment failed')
                payment.save()
                
                return Response({
                    'message': 'Payment marked as failed',
                    'payment': PaymentSerializer(payment).data
                })
                
        except Payment.DoesNotExist:
            return Response(
                {'error': 'Payment not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )


class PaymentListView(generics.ListAPIView):
    """List payments - for authenticated staff only"""
    serializer_class = PaymentSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return Payment.objects.all().order_by('-created_at')


class RefundCreateView(APIView):
    """Create refund request - for authenticated staff only"""
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        serializer = RefundCreateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        payment_id = serializer.validated_data['payment_id']
        amount_cents = serializer.validated_data['amount_cents']
        reason = serializer.validated_data['reason']
        
        try:
            payment = Payment.objects.get(id=payment_id)
            refund = StripePaymentService.create_refund(
                payment=payment,
                amount_cents=amount_cents,
                reason=reason,
                requested_by_user=request.user
            )
            
            return Response({
                'message': 'Refund request created',
                'refund': RefundSerializer(refund).data
            }, status=status.HTTP_201_CREATED)
            
        except Payment.DoesNotExist:
            return Response(
                {'error': 'Payment not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class RefundListView(generics.ListAPIView):
    """List refunds - for authenticated staff only"""
    serializer_class = RefundSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return Refund.objects.all().order_by('-created_at')
```

# ==== apps/services/__init__.py ====

```python

```

# ==== apps/services/admin.py ====

```python
from django.contrib import admin
from .models import (
    MiniMovePackage, 
    StandardDeliveryConfig, 
    SpecialtyItem, 
    SurchargeRule, 
    VanSchedule
)

@admin.register(MiniMovePackage)
class MiniMovePackageAdmin(admin.ModelAdmin):
    list_display = ('name', 'package_type', 'base_price_dollars', 'max_items', 'coi_included', 'is_most_popular', 'is_active')
    list_filter = ('package_type', 'coi_included', 'is_most_popular', 'is_active')
    fieldsets = (
        ('Package Details', {
            'fields': ('package_type', 'name', 'description', 'is_most_popular', 'is_active')
        }),
        ('Pricing', {
            'fields': ('base_price_cents', 'coi_included', 'coi_fee_cents')
        }),
        ('Limits & Features', {
            'fields': ('max_items', 'max_weight_per_item_lbs', 'priority_scheduling', 'protective_wrapping')
        })
    )

@admin.register(StandardDeliveryConfig)
class StandardDeliveryConfigAdmin(admin.ModelAdmin):
    list_display = ('price_per_item_dollars', 'minimum_items', 'minimum_charge_dollars', 'is_active')
    fieldsets = (
        ('Per-Item Pricing', {
            'fields': ('price_per_item_cents', 'minimum_items', 'minimum_charge_cents')
        }),
        ('Same-Day Delivery', {
            'fields': ('same_day_flat_rate_cents',)
        }),
        ('Constraints', {
            'fields': ('max_weight_per_item_lbs', 'is_active')
        })
    )

@admin.register(SpecialtyItem)
class SpecialtyItemAdmin(admin.ModelAdmin):
    list_display = ('name', 'item_type', 'price_dollars', 'requires_van_schedule', 'is_active')
    list_filter = ('item_type', 'requires_van_schedule', 'special_handling', 'is_active')
    fieldsets = (
        ('Item Details', {
            'fields': ('item_type', 'name', 'description', 'is_active')
        }),
        ('Pricing', {
            'fields': ('price_cents',)
        }),
        ('Requirements', {
            'fields': ('requires_van_schedule', 'special_handling')
        })
    )

@admin.register(SurchargeRule)
class SurchargeRuleAdmin(admin.ModelAdmin):
    list_display = ('name', 'surcharge_type', 'calculation_type', 'get_surcharge_display', 'is_active')
    list_filter = ('surcharge_type', 'calculation_type', 'is_active')
    fieldsets = (
        ('Rule Details', {
            'fields': ('surcharge_type', 'name', 'description', 'is_active')
        }),
        ('Calculation', {
            'fields': ('calculation_type', 'percentage', 'fixed_amount_cents')
        }),
        ('Date Rules', {
            'fields': ('specific_date', 'applies_saturday', 'applies_sunday')
        })
    )
    
    def get_surcharge_display(self, obj):
        if obj.calculation_type == 'percentage' and obj.percentage:
            return f"{obj.percentage}%"
        elif obj.calculation_type == 'fixed_amount' and obj.fixed_amount_cents:
            return f"${obj.fixed_amount_cents / 100}"
        return "Not configured"
    get_surcharge_display.short_description = 'Surcharge Amount'

@admin.register(VanSchedule)
class VanScheduleAdmin(admin.ModelAdmin):
    list_display = ('date', 'is_available', 'total_bookings', 'max_capacity', 'has_capacity', 'allows_specialty_items')
    list_filter = ('is_available', 'date')
    date_hierarchy = 'date'
    fieldsets = (
        ('Schedule', {
            'fields': ('date', 'is_available', 'max_capacity')
        }),
        ('Bookings', {
            'fields': ('mini_moves_booked', 'specialty_items_booked')
        }),
        ('Notes', {
            'fields': ('notes',)
        })
    )
```

# ==== apps/services/apps.py ====

```python
from django.apps import AppConfig


class ServicesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.services'
```

# ==== apps/services/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.5 on 2025-09-02 20:54

import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='MiniMovePackage',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('package_type', models.CharField(choices=[('petite', 'Petite'), ('standard', 'Standard'), ('full', 'Full Move')], max_length=20, unique=True)),
                ('name', models.CharField(max_length=50)),
                ('description', models.TextField()),
                ('base_price_cents', models.PositiveBigIntegerField()),
                ('max_items', models.PositiveIntegerField(blank=True, help_text='Maximum items allowed (null = unlimited for Full Move)', null=True)),
                ('max_weight_per_item_lbs', models.PositiveIntegerField(default=50)),
                ('coi_included', models.BooleanField(default=False)),
                ('coi_fee_cents', models.PositiveBigIntegerField(default=5000, help_text='COI fee in cents if not included')),
                ('priority_scheduling', models.BooleanField(default=False)),
                ('protective_wrapping', models.BooleanField(default=False)),
                ('is_most_popular', models.BooleanField(default=False)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'services_mini_move_package',
                'ordering': ['base_price_cents'],
            },
        ),
        migrations.CreateModel(
            name='SpecialtyItem',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('item_type', models.CharField(choices=[('peloton', 'Peloton'), ('surfboard', 'Surfboard'), ('crib', 'Crib'), ('wardrobe_box', 'Wardrobe Box')], max_length=30, unique=True)),
                ('name', models.CharField(max_length=100)),
                ('description', models.TextField(blank=True)),
                ('price_cents', models.PositiveBigIntegerField()),
                ('requires_van_schedule', models.BooleanField(default=True, help_text='Can only be booked when van is already scheduled')),
                ('special_handling', models.BooleanField(default=True)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'services_specialty_item',
            },
        ),
        migrations.CreateModel(
            name='StandardDeliveryConfig',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('price_per_item_cents', models.PositiveBigIntegerField(default=9500, help_text='Price per item in cents')),
                ('minimum_items', models.PositiveIntegerField(default=3, help_text='Minimum number of items for delivery')),
                ('minimum_charge_cents', models.PositiveBigIntegerField(default=28500, help_text='Minimum delivery charge in cents')),
                ('same_day_flat_rate_cents', models.PositiveBigIntegerField(default=36000, help_text='Flat rate for same-day delivery')),
                ('max_weight_per_item_lbs', models.PositiveIntegerField(default=50, help_text='Maximum weight per item in pounds')),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'services_standard_delivery_config',
            },
        ),
        migrations.CreateModel(
            name='SurchargeRule',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('surcharge_type', models.CharField(choices=[('weekend', 'Weekend Surcharge'), ('holiday', 'Holiday Surcharge'), ('peak_date', 'Peak Date Surcharge')], max_length=20)),
                ('name', models.CharField(max_length=100)),
                ('description', models.TextField(blank=True)),
                ('calculation_type', models.CharField(choices=[('percentage', 'Percentage'), ('fixed_amount', 'Fixed Amount')], max_length=20)),
                ('percentage', models.DecimalField(blank=True, decimal_places=2, help_text='Percentage surcharge (e.g., 15.00 for 15%)', max_digits=5, null=True)),
                ('fixed_amount_cents', models.PositiveBigIntegerField(blank=True, help_text='Fixed surcharge amount in cents', null=True)),
                ('specific_date', models.DateField(blank=True, help_text='Specific date for peak date surcharges', null=True)),
                ('applies_saturday', models.BooleanField(default=False)),
                ('applies_sunday', models.BooleanField(default=False)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'services_surcharge_rule',
            },
        ),
        migrations.CreateModel(
            name='VanSchedule',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date', models.DateField(unique=True)),
                ('is_available', models.BooleanField(default=True, help_text='Van is available for pickups on this date')),
                ('mini_moves_booked', models.PositiveIntegerField(default=0)),
                ('specialty_items_booked', models.PositiveIntegerField(default=0)),
                ('max_capacity', models.PositiveIntegerField(default=10, help_text='Maximum bookings for this date')),
                ('notes', models.TextField(blank=True, help_text='Internal notes about availability or restrictions')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'services_van_schedule',
                'ordering': ['date'],
            },
        ),
    ]
```

# ==== apps/services/migrations/__init__.py ====

```python

```

# ==== apps/services/models.py ====

```python
import uuid
from django.db import models
from django.utils import timezone
from decimal import Decimal


class MiniMovePackage(models.Model):
    """Mini Move service packages from homework: Petite, Standard, Full"""
    
    PACKAGE_TYPES = [
        ('petite', 'Petite'),
        ('standard', 'Standard'), 
        ('full', 'Full Move'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Package details
    package_type = models.CharField(max_length=20, choices=PACKAGE_TYPES, unique=True)
    name = models.CharField(max_length=50)
    description = models.TextField()
    
    # Pricing
    base_price_cents = models.PositiveBigIntegerField()
    
    # Item limits
    max_items = models.PositiveIntegerField(
        null=True, 
        blank=True,
        help_text="Maximum items allowed (null = unlimited for Full Move)"
    )
    max_weight_per_item_lbs = models.PositiveIntegerField(default=50)
    
    # COI handling
    coi_included = models.BooleanField(default=False)
    coi_fee_cents = models.PositiveBigIntegerField(
        default=5000,  # $50
        help_text="COI fee in cents if not included"
    )
    
    # Features
    priority_scheduling = models.BooleanField(default=False)
    protective_wrapping = models.BooleanField(default=False)
    
    # Marketing
    is_most_popular = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'services_mini_move_package'
        ordering = ['base_price_cents']
    
    def __str__(self):
        return f"{self.name} - ${self.base_price_dollars}"
    
    @property
    def base_price_dollars(self):
        return self.base_price_cents / 100
    
    @property
    def coi_fee_dollars(self):
        return self.coi_fee_cents / 100


class StandardDeliveryConfig(models.Model):
    """Configuration for Standard Delivery pricing from homework"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Per-item pricing
    price_per_item_cents = models.PositiveBigIntegerField(
        default=9500,  # $95
        help_text="Price per item in cents"
    )
    
    # Minimums
    minimum_items = models.PositiveIntegerField(
        default=3,
        help_text="Minimum number of items for delivery"
    )
    minimum_charge_cents = models.PositiveBigIntegerField(
        default=28500,  # $285
        help_text="Minimum delivery charge in cents"
    )
    
    # Same-day delivery
    same_day_flat_rate_cents = models.PositiveBigIntegerField(
        default=36000,  # $360
        help_text="Flat rate for same-day delivery"
    )
    
    # Item constraints
    max_weight_per_item_lbs = models.PositiveIntegerField(
        default=50,
        help_text="Maximum weight per item in pounds"
    )
    
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'services_standard_delivery_config'
    
    def __str__(self):
        return f"Standard Delivery - ${self.price_per_item_dollars}/item"
    
    @property
    def price_per_item_dollars(self):
        return self.price_per_item_cents / 100
    
    @property
    def minimum_charge_dollars(self):
        return self.minimum_charge_cents / 100
    
    def calculate_total(self, item_count, is_same_day=False):
        """Calculate total for standard delivery"""
        if is_same_day:
            return self.same_day_flat_rate_cents
        
        item_total = self.price_per_item_cents * item_count
        return max(item_total, self.minimum_charge_cents)


class SpecialtyItem(models.Model):
    """Specialty items from homework: Peloton, Surfboard, Crib, Wardrobe Box"""
    
    ITEM_TYPES = [
        ('peloton', 'Peloton'),
        ('surfboard', 'Surfboard'),
        ('crib', 'Crib'),
        ('wardrobe_box', 'Wardrobe Box'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Item details
    item_type = models.CharField(max_length=30, choices=ITEM_TYPES, unique=True)
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    
    # Pricing
    price_cents = models.PositiveBigIntegerField()
    
    # Requirements
    requires_van_schedule = models.BooleanField(
        default=True,
        help_text="Can only be booked when van is already scheduled"
    )
    special_handling = models.BooleanField(default=True)
    
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'services_specialty_item'
    
    def __str__(self):
        return f"{self.name} - ${self.price_dollars}"
    
    @property
    def price_dollars(self):
        return self.price_cents / 100


class SurchargeRule(models.Model):
    """Weekend, holiday, and peak date surcharges from homework"""
    
    SURCHARGE_TYPES = [
        ('weekend', 'Weekend Surcharge'),
        ('holiday', 'Holiday Surcharge'),
        ('peak_date', 'Peak Date Surcharge'),
    ]
    
    CALCULATION_TYPES = [
        ('percentage', 'Percentage'),
        ('fixed_amount', 'Fixed Amount'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Surcharge details
    surcharge_type = models.CharField(max_length=20, choices=SURCHARGE_TYPES)
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    
    # Calculation
    calculation_type = models.CharField(max_length=20, choices=CALCULATION_TYPES)
    percentage = models.DecimalField(
        max_digits=5, 
        decimal_places=2, 
        null=True, 
        blank=True,
        help_text="Percentage surcharge (e.g., 15.00 for 15%)"
    )
    fixed_amount_cents = models.PositiveBigIntegerField(
        null=True,
        blank=True,
        help_text="Fixed surcharge amount in cents"
    )
    
    # Date rules (for specific dates like Sept 1)
    specific_date = models.DateField(
        null=True,
        blank=True,
        help_text="Specific date for peak date surcharges"
    )
    
    # Day of week rules (for weekend surcharges)
    applies_saturday = models.BooleanField(default=False)
    applies_sunday = models.BooleanField(default=False)
    
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'services_surcharge_rule'
    
    def __str__(self):
        return self.name
    
    def calculate_surcharge(self, base_amount_cents, booking_date):
        """Calculate surcharge for given base amount and date"""
        if not self.is_active:
            return 0
        
        # Check if rule applies to this date
        if not self.applies_to_date(booking_date):
            return 0
        
        if self.calculation_type == 'percentage' and self.percentage:
            return int(base_amount_cents * (self.percentage / 100))
        elif self.calculation_type == 'fixed_amount' and self.fixed_amount_cents:
            return self.fixed_amount_cents
        
        return 0
    
    def applies_to_date(self, booking_date):
        """Check if surcharge rule applies to given date"""
        # Specific date check
        if self.specific_date and self.specific_date == booking_date:
            return True
        
        # Weekend check
        weekday = booking_date.weekday()
        if weekday == 5 and self.applies_saturday:  # Saturday
            return True
        if weekday == 6 and self.applies_sunday:    # Sunday
            return True
        
        return False


class VanSchedule(models.Model):
    """Basic van availability for specialty item scheduling"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Schedule details
    date = models.DateField(unique=True)
    is_available = models.BooleanField(
        default=True,
        help_text="Van is available for pickups on this date"
    )
    
    # Capacity tracking
    mini_moves_booked = models.PositiveIntegerField(default=0)
    specialty_items_booked = models.PositiveIntegerField(default=0)
    max_capacity = models.PositiveIntegerField(
        default=10,
        help_text="Maximum bookings for this date"
    )
    
    # Notes
    notes = models.TextField(
        blank=True,
        help_text="Internal notes about availability or restrictions"
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'services_van_schedule'
        ordering = ['date']
    
    def __str__(self):
        status = "Available" if self.is_available else "Unavailable"
        return f"{self.date} - {status} ({self.total_bookings}/{self.max_capacity})"
    
    @property
    def total_bookings(self):
        return self.mini_moves_booked + self.specialty_items_booked
    
    @property
    def has_capacity(self):
        return self.is_available and self.total_bookings < self.max_capacity
    
    @property
    def allows_specialty_items(self):
        """Specialty items only available when van is scheduled (has any bookings)"""
        return self.has_capacity and self.total_bookings > 0
```

# ==== apps/services/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/services/views.py ====

```python
from django.shortcuts import render

# Create your views here.
```

# ========================= SCRIPTS & UTILITIES =========================


# ==== scripts/back_export.py ====

```python
#!/usr/bin/env python3
"""
ToteTaxi Backend Auto-Discovery Export
"""
import os
from pathlib import Path
from datetime import datetime

def get_file_content(file_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        return f"# Error reading file: {e}"

def should_include_file(file_path, base_dir):
    """Smart file inclusion rules for ToteTaxi"""
    rel_path = file_path.relative_to(base_dir)
    path_str = str(rel_path)
    
    # Skip patterns - SECURITY: Handle .env files separately
    skip_patterns = [
        '__pycache__', '.pyc', '.git/', '.pytest_cache/', 'htmlcov/',
        'staticfiles/', 'media/', 'logs/', '.coverage', 'db.sqlite3',
        'totetaxi_backend_snapshot.txt', 'back_export.txt',
        '.DS_Store', '*.swp', '*.swo'
    ]
    
    if any(pattern in path_str for pattern in skip_patterns):
        return False
    
    # SECURITY: Skip .env files (contain secrets)
    if file_path.name.startswith('.env'):
        return False
    
    # Include all migration files for reference
    # (Including customer app migrations)
    
    # Include patterns
    include_extensions = {'.py', '.txt', '.yml', '.yaml', '.toml', '.md', '.sh', '.ini', '.conf'}
    include_files = {
        'Dockerfile', 'Dockerfile.dev', '.dockerignore', '.gitignore', 
        'manage.py', 'docker-compose.yml', 'docker-compose.prod.yml',
        'gunicorn.conf.py', 'pytest.ini'
    }
    
    return (
        file_path.suffix in include_extensions or 
        file_path.name in include_files
    )

def categorize_file(file_path, base_dir):
    """Auto-categorize files for ToteTaxi structure"""
    rel_path = file_path.relative_to(base_dir)
    path_str = str(rel_path)
    
    # Configuration files (root level)
    if (rel_path.parent == Path('.') or 
        file_path.name in ['manage.py', 'requirements.txt', 'gunicorn.conf.py', 'pytest.ini']):
        return 'config'
    
    # ToteTaxi Django apps (including NEW customers app)
    totetaxi_apps = [
        'accounts/', 'bookings/', 'crm/', 'customers/', 'documents/', 
        'logistics/', 'notifications/', 'payments/', 'services/'
    ]
    if any(f'apps/{app}' in path_str for app in totetaxi_apps):
        return 'apps'
    
    # Django project settings (config/ directory)
    if 'config/' in path_str:
        return 'project'
    
    # Scripts directory
    if 'scripts/' in path_str:
        return 'scripts'
    
    # Everything else
    return 'other'

def main():
    backend_dir = Path(__file__).parent.parent
    output_file = backend_dir / 'scripts' / 'back_export.txt'
    
    print(f"ðŸ” Auto-discovering ToteTaxi backend files in: {backend_dir}")
    
    # Auto-discover all relevant files
    all_files = []
    for file_path in backend_dir.rglob('*'):
        if file_path.is_file() and should_include_file(file_path, backend_dir):
            all_files.append(file_path)
    
    # Categorize files
    categories = {
        'config': [],
        'project': [],
        'apps': [],
        'scripts': [],
        'other': []
    }
    
    for file_path in all_files:
        category = categorize_file(file_path, backend_dir)
        categories[category].append(file_path)
    
    # Sort within categories
    for category in categories:
        categories[category].sort()
    
    print(f"ðŸ“Š Found {len(all_files)} files:")
    for cat, files in categories.items():
        if files:
            print(f"  - {cat}: {len(files)} files")
    
    # Generate snapshot
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# TOTETAXI - BACKEND CODE SNAPSHOT\n")
        f.write("# AUTO-GENERATED - SECURE VERSION\n")
        f.write(f"# Created: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"# Total files: {len(all_files)}\n")
        f.write("# ðŸ”’ SECURITY: .env files excluded (contain secrets)\n")
        f.write("# ðŸ“‹ INCLUDES: All Django apps, migrations, configuration\n")
        f.write("# Apps: accounts (STAFF), bookings, crm, customers (NEW), documents, logistics, notifications, payments, services\n")
        f.write("# NEW FEATURES: Customer authentication, guest checkout, customer dashboard\n")
        f.write("# Tech Stack: Django 5.2.5, DRF 3.16.1, PostgreSQL, Redis, Celery\n")
        f.write("# Integration: S3 storage, SES email, mocked Stripe/Onfleet\n\n\n")
        
        # Output by category
        section_names = {
            'config': 'CONFIGURATION & ROOT FILES',
            'project': 'DJANGO PROJECT SETTINGS (config/)',
            'apps': 'DJANGO APPLICATIONS (apps/) - Including NEW customers/ app',
            'scripts': 'SCRIPTS & UTILITIES',
            'other': 'OTHER FILES'
        }
        
        for category, section_name in section_names.items():
            if categories[category]:
                f.write("# " + "="*25 + f" {section_name} " + "="*25 + "\n\n\n")
                
                for file_path in categories[category]:
                    rel_path = file_path.relative_to(backend_dir)
                    f.write(f"# ==== {rel_path} ====\n\n")
                    
                    # Smart syntax highlighting
                    if file_path.suffix == '.py':
                        f.write("```python\n")
                    elif file_path.suffix in ['.yml', '.yaml']:
                        f.write("```yaml\n")
                    elif file_path.suffix == '.toml':
                        f.write("```toml\n")
                    elif file_path.suffix == '.md':
                        f.write("```markdown\n")
                    elif file_path.suffix == '.sh':
                        f.write("```bash\n")
                    elif file_path.name in ['Dockerfile', 'Dockerfile.dev']:
                        f.write("```dockerfile\n")
                    elif file_path.suffix == '.ini':
                        f.write("```ini\n")
                    else:
                        f.write("```\n")
                    
                    content = get_file_content(file_path)
                    f.write(content)
                    if not content.endswith('\n'):
                        f.write('\n')
                    f.write("```\n\n")
    
    print(f"âœ… Auto-generated ToteTaxi backend snapshot: {output_file}")
    print("ðŸ”’ SECURITY: .env files excluded (contain secrets)")
    print("ðŸ“‹ INCLUDES: All 9 Django apps with migrations (including NEW customers/ app)")
    print("ðŸ—ï¸  STRUCTURE: accounts (staff), bookings, crm, customers (NEW), documents, logistics, notifications, payments, services")
    print("ðŸ‘¤ NEW FEATURES: Customer authentication, guest checkout, customer dashboard")
    print("ðŸ³ DOCKER: Configuration and compose files included")

if __name__ == "__main__":
    main()
```

# ==== scripts/entrypoint.sh ====

```bash
#!/bin/bash

# Exit on any failure
set -e

echo "Waiting for postgres..."
while ! pg_isready -h db -p 5432 -U postgres; do
  sleep 1
done
echo "PostgreSQL started"

# Only run migrations and collectstatic if manage.py exists
if [ -f "manage.py" ]; then
    echo "Running migrations..."
    python manage.py migrate --no-input
    
    echo "Collecting static files..."
    python manage.py collectstatic --no-input --clear || echo "Collectstatic failed, continuing..."
else
    echo "No manage.py found, skipping Django setup commands"
fi

exec "$@"

```

# ========================= OTHER FILES =========================


# ==== apps/__init__.py ====

```python

```

