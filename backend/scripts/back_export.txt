# TOTETAXI - BACKEND CODE SNAPSHOT
# AUTO-GENERATED - CODE FILES ONLY
# Created: 2025-10-25 20:16:40
# Total files: 141
# 🔒 SECURITY: .env files excluded (contain secrets)
# 📋 INCLUDES: All Django apps, migrations, configuration
# Apps: accounts (STAFF), bookings, customers, logistics, payments, services
# Tech Stack: Django 5.2.5, DRF 3.16.1, PostgreSQL, Redis, Celery
# Integration: S3 storage, SES email, mocked Stripe/Onfleet


# ========================= CONFIGURATION & ROOT FILES =========================


# ==== .dockerignore ====

```
# backend/.dockerignore
# Git
.git
.gitignore

# Docker
.docker
Dockerfile
docker-compose*

# Python
__pycache__
*.pyc
*.pyo
*.pyd
.Python
venv/
.venv/
pip-log.txt
pip-delete-this-directory.txt
.tox
.coverage
.coverage.*
.pytest_cache
.cache
htmlcov
.mypy_cache
.dmypy.json
dmypy.json

# IDEs
.vscode
.idea
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs
*.log
npm-debug.log*

# Environment
.env
.env.local
.env.development
.env.production

# Media files
media/

# Node (if any)
node_modules
npm-debug.log
```

# ==== .gitignore ====

```
# Python
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
__pycache__/
*.py[cod]
*$py.class

# Django
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal
/media
/staticfiles
/static

# Environment variables
.env
.env.local
.env.production
.env.*.local
*.env

# Virtual Environment
venv/
env/
ENV/
env.bak/
venv.bak/
.venv/

# IDEs
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store

# Testing
.pytest_cache/
.coverage
htmlcov/
.tox/
.nox/

# Celery
celerybeat-schedule
celerybeat.pid

# Jupyter Notebook
.ipynb_checkpoints

# pyenv
.python-version

# Backup files
*.bak
*.backup

# Database dumps
*.sql
*.dump

# Stripe webhook CLI (if used)
stripe-webhook-*

# Logs
logs/
*.log
```

# ==== Dockerfile ====

```dockerfile
# backend/Dockerfile
FROM python:3.11-slim

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONPATH=/app \
    PORT=8000

# Set work directory
WORKDIR /app

# Install system dependencies
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
        postgresql-client \
        build-essential \
        libpq-dev \
        curl \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt /app/
RUN pip install --no-cache-dir -r requirements.txt

# Copy project
COPY . /app/

# Create directories for logs and static files
RUN mkdir -p /app/logs /app/staticfiles /app/media

# Make entrypoint executable
RUN chmod +x /app/scripts/entrypoint.sh

# Collect static files
RUN python manage.py collectstatic --no-input --clear || echo "Collectstatic skipped"

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD curl -f http://localhost:8000/admin/ || exit 1

# Run entrypoint
ENTRYPOINT ["/app/scripts/entrypoint.sh"]
CMD ["gunicorn", "config.wsgi:application", "--bind", "0.0.0.0:8000", "--workers", "2", "--timeout", "120"]
```

# ==== conftest.py ====

```python
import os
import django

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
django.setup()
```

# ==== cookies.txt ====

```
# Netscape HTTP Cookie File
# https://curl.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

totetaxi-backend.fly.dev	FALSE	/	TRUE	1792160459	csrftoken	0DEHEAn76W7FlZ3DmrlviZOLrTKRouS6
```

# ==== docker-compose.prod.yml ====

```yaml
# backend/docker-compose.prod.yml
name: totetaxi-production

services:
  # PostgreSQL Database - Internal only for security
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: ${DB_NAME:-totetaxi}
      POSTGRES_USER: ${DB_USER:-postgres}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_INITDB_ARGS: "--auth-host=scram-sha-256"
    volumes:
      - postgres_data:/var/lib/postgresql/data/
      - ./postgresql.conf:/etc/postgresql/postgresql.conf:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-postgres}"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - internal
    restart: unless-stopped
    # No external ports - database is internal only

  # Redis for Celery - Internal only with authentication
  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD} --maxmemory 256mb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "--no-auth-warning", "-a", "${REDIS_PASSWORD}", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - internal
    restart: unless-stopped

  # Django Backend with Gunicorn
  web:
    build:
      context: .
      dockerfile: Dockerfile.prod
    command: gunicorn config.wsgi:application --bind 0.0.0.0:8000 --workers 4 --worker-class sync --max-requests 1000 --access-logfile - --error-logfile -
    volumes:
      - static_volume:/app/staticfiles:ro
      - media_volume:/app/media
      - logs_volume:/app/logs
    ports:
      - "8005:8000"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env.production
    environment:
      - DATABASE_URL=postgres://${DB_USER:-postgres}:${DB_PASSWORD}@db:5432/${DB_NAME:-totetaxi}?sslmode=prefer
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
    networks:
      - internal
      - external
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 512M

  # Celery Worker
  celery:
    build:
      context: .
      dockerfile: Dockerfile.prod
    command: celery -A config worker -l info --concurrency 4 --max-tasks-per-child 1000
    volumes:
      - logs_volume:/app/logs
      - media_volume:/app/media
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env.production
    environment:
      - DATABASE_URL=postgres://${DB_USER:-postgres}:${DB_PASSWORD}@db:5432/${DB_NAME:-totetaxi}?sslmode=prefer
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
    networks:
      - internal
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 512M

  # Celery Beat Scheduler
  celery-beat:
    build:
      context: .
      dockerfile: Dockerfile.prod
    command: celery -A config beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler
    volumes:
      - logs_volume:/app/logs
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env.production
    environment:
      - DATABASE_URL=postgres://${DB_USER:-postgres}:${DB_PASSWORD}@db:5432/${DB_NAME:-totetaxi}?sslmode=prefer
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
    networks:
      - internal
    restart: unless-stopped

volumes:
  postgres_data:
    driver: local
  static_volume:
    driver: local
  media_volume:
    driver: local
  redis_data:
    driver: local
  logs_volume:
    driver: local

networks:
  internal:
    driver: bridge
    internal: true
  external:
    driver: bridge
```

# ==== docker-compose.yml ====

```yaml
name: totetaxi-backend

services:
  # PostgreSQL Database - PORT 5435
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: totetaxi
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5435:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis for Celery - PORT 6382
  redis:
    image: redis:7-alpine
    ports:
      - "6382:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Django Backend - PORT 8005
  web:
    build: .
    command: python manage.py runserver 0.0.0.0:8000
    volumes:
      - .:/app
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    ports:
      - "8005:8000"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/totetaxi
      - REDIS_URL=redis://redis:6379/0

  # Celery Worker
  celery:
    build: .
    command: celery -A config worker -l info
    volumes:
      - .:/app
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/totetaxi
      - REDIS_URL=redis://redis:6379/0

  # Celery Beat Scheduler
  celery-beat:
    build: .
    command: celery -A config beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler
    volumes:
      - .:/app
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/totetaxi
      - REDIS_URL=redis://redis:6379/0

volumes:
  postgres_data:
  static_volume:
  media_volume:
  redis_data:
```

# ==== fly.toml ====

```toml
app = 'totetaxi-backend'
primary_region = 'ewr'

[build]
  dockerfile = 'Dockerfile.prod'

[deploy]
  release_command = "python manage.py migrate --noinput"

[env]
  DEBUG = "False"
  DJANGO_LOG_LEVEL = "INFO"
  DJANGO_SETTINGS_MODULE = 'config.settings'
  PORT = '8000'
  PYTHONUNBUFFERED = '1'
  PYTHONPATH = '/app'

# ✅ MULTI-PROCESS CONFIGURATION
[processes]
  web = "gunicorn config.wsgi:application --bind 0.0.0.0:8000 --workers 4"
  worker = "celery -A config worker -l info --concurrency 2"
  beat = "celery -A config beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler"

[http_service]
  internal_port = 8000
  force_https = true
  auto_stop_machines = false
  auto_start_machines = true
  min_machines_running = 1
  processes = ['web']  # Only web handles HTTP traffic

  [http_service.concurrency]
    type = 'requests'
    hard_limit = 200
    soft_limit = 100

# ✅ MACHINE CONFIGURATION - Separate for each process
[[vm]]
  memory = '1gb'
  cpu_kind = 'shared'
  cpus = 1
  processes = ['web']

[[vm]]
  memory = '512mb'
  cpu_kind = 'shared'
  cpus = 1
  processes = ['worker']

[[vm]]
  memory = '256mb'
  cpu_kind = 'shared'
  cpus = 1
  processes = ['beat']

[[statics]]
  guest_path = "/app/staticfiles"
  url_prefix = "/static/"
```

# ==== gunicorn.conf.py ====

```python
import multiprocessing

# Server socket
bind = "0.0.0.0:8000"
backlog = 2048

# Worker processes
workers = multiprocessing.cpu_count() * 2 + 1
worker_class = "sync"
worker_connections = 1000
timeout = 30
keepalive = 2
max_requests = 1000
max_requests_jitter = 100

# Logging
accesslog = "-"
errorlog = "-"
loglevel = "info"

# Process naming
proc_name = "totetaxi"

# Server mechanics
preload_app = True
pidfile = "/tmp/gunicorn.pid"
```

# ==== manage.py ====

```python
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
```

# ==== pyproject.toml ====

```toml
[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "totetaxi-backend"
version = "0.1.0"
description = "ToteTaxi luxury delivery service backend API"
requires-python = ">=3.11"

[tool.black]
line-length = 88
target-version = ['py311']
include = '\.pyi?$'
extend-exclude = '''
/(
  migrations
)/
'''

[tool.isort]
profile = "black"
multi_line_output = 3
line_length = 88
skip_glob = ["**/migrations/*.py"]

[tool.coverage.run]
source = "."
omit = [
    "*/migrations/*",
    "*/venv/*",
    "*/tests/*",
    "manage.py",
    "config/wsgi.py",
    "config/asgi.py",
]
```

# ==== pytest.ini ====

```ini
[pytest]
DJANGO_SETTINGS_MODULE = config.settings
python_files = tests.py test_*.py *_tests.py
python_classes = Test*
python_functions = test_*
addopts = 
    --strict-markers
    --reuse-db
    --ds=config.settings
    -ra
    --tb=short
testpaths = apps
```

# ==== recreate_services.py ====

```python
from apps.services.models import *

print("🚀 Creating service catalog...")

# 1. Mini Move Packages
print("📦 Creating Mini Move Packages...")
MiniMovePackage.objects.create(
    package_type='petite',
    name='Petite',
    description='15 items <50 lbs. Shared van with COI available for +$50.',
    base_price_cents=99500,
    max_items=15,
    max_weight_per_item_lbs=50,
    coi_included=False,
    coi_fee_cents=5000,
    priority_scheduling=False,
    protective_wrapping=False,
    is_most_popular=False,
    is_active=True
)

MiniMovePackage.objects.create(
    package_type='standard',
    name='Standard',
    description='30 items <50 lbs. COI included, protective wrapping, priority scheduling.',
    base_price_cents=172500,
    max_items=30,
    max_weight_per_item_lbs=50,
    coi_included=True,
    coi_fee_cents=0,
    priority_scheduling=True,
    protective_wrapping=True,
    is_most_popular=True,
    is_active=True
)

MiniMovePackage.objects.create(
    package_type='full',
    name='Full Move',
    description='Van exclusive, unlimited items within van capacity. Direct pickup-to-delivery.',
    base_price_cents=249000,
    max_items=None,
    max_weight_per_item_lbs=50,
    coi_included=True,
    coi_fee_cents=0,
    priority_scheduling=True,
    protective_wrapping=True,
    is_most_popular=False,
    is_active=True
)

# 2. Organizing Services (CORRECT PRICING FROM MIGRATION)
print("📋 Creating Organizing Services...")

OrganizingService.objects.create(
    service_type='petite_packing',
    mini_move_tier='petite',
    name='Petite Packing',
    description='1/2 day (up to 4 hours) with 2 organizers. Includes garment bags, moving bags + additional packing supplies upon request (up to $250).',
    price_cents=244500,
    duration_hours=4,
    organizer_count=2,
    supplies_allowance_cents=25000,
    is_packing_service=True,
    is_active=True
)

OrganizingService.objects.create(
    service_type='petite_unpacking',
    mini_move_tier='petite',
    name='Petite Unpacking',
    description='1/2 day (up to 4 hours) with 2 organizers. Organizing light (no supplies).',
    price_cents=211000,
    duration_hours=4,
    organizer_count=2,
    supplies_allowance_cents=0,
    is_packing_service=False,
    is_active=True
)

OrganizingService.objects.create(
    service_type='standard_packing',
    mini_move_tier='standard',
    name='Standard Packing',
    description='1 day (up to 8 hours) with 2 organizers. Includes garment bags, moving bags + additional packing supplies upon request (up to $350).',
    price_cents=333000,
    duration_hours=8,
    organizer_count=2,
    supplies_allowance_cents=35000,
    is_packing_service=True,
    is_active=True
)

OrganizingService.objects.create(
    service_type='standard_unpacking',
    mini_move_tier='standard',
    name='Standard Unpacking',
    description='1 day (up to 8 hours) with 2 organizers. Organizing light (no supplies).',
    price_cents=288500,
    duration_hours=8,
    organizer_count=2,
    supplies_allowance_cents=0,
    is_packing_service=False,
    is_active=True
)

OrganizingService.objects.create(
    service_type='full_packing',
    mini_move_tier='full',
    name='Full Packing',
    description='1 day (up to 8 hours) with 4 organizers. Includes garment bags, moving bags + additional packing supplies upon request (up to $500).',
    price_cents=507000,
    duration_hours=8,
    organizer_count=4,
    supplies_allowance_cents=50000,
    is_packing_service=True,
    is_active=True
)

OrganizingService.objects.create(
    service_type='full_unpacking',
    mini_move_tier='full',
    name='Full Unpacking',
    description='1 day (up to 8 hours) with 4 organizers. Organizing light (no supplies).',
    price_cents=452500,
    duration_hours=8,
    organizer_count=4,
    supplies_allowance_cents=0,
    is_packing_service=False,
    is_active=True
)

# 3. Specialty Items
print("🏄 Creating Specialty Items...")
SpecialtyItem.objects.create(
    item_type='peloton',
    name='Peloton / Large Equipment',
    description='Peloton bikes and large equipment moving',
    price_cents=50000,
    special_handling=True,
    is_active=True
)

SpecialtyItem.objects.create(
    item_type='surfboard',
    name='Surfboard',
    description='Professional surfboard transport',
    price_cents=35000,
    special_handling=True,
    is_active=True
)

SpecialtyItem.objects.create(
    item_type='crib',
    name='Crib',
    description='Foldable crib delivery (may vary for non-foldable)',
    price_cents=35000,
    special_handling=True,
    is_active=True
)

SpecialtyItem.objects.create(
    item_type='wardrobe_box',
    name='Wardrobe Box',
    description='Professional wardrobe box handling',
    price_cents=27500,
    special_handling=True,
    is_active=True
)

# 4. Standard Delivery Config
print("🚚 Creating Standard Delivery Config...")
StandardDeliveryConfig.objects.create(
    price_per_item_cents=9500,
    minimum_items=1,
    minimum_charge_cents=28500,
    same_day_flat_rate_cents=36000,
    max_weight_per_item_lbs=50,
    is_active=True
)

# 5. Surcharge Rules
print("💰 Creating Surcharge Rules...")
SurchargeRule.objects.create(
    surcharge_type='weekend',
    name='Mini Move Weekend Surcharge',
    description='Weekend surcharge for Mini Move packages - $175 for Sat/Sun bookings',
    applies_to_service_type='mini_move',
    calculation_type='fixed_amount',
    percentage=None,
    fixed_amount_cents=17500,
    specific_date=None,
    applies_saturday=True,
    applies_sunday=True,
    is_active=True
)

SurchargeRule.objects.create(
    surcharge_type='weekend',
    name='Standard Delivery Weekend Surcharge',
    description='Weekend surcharge for Standard Delivery service - $50 for Sat/Sun bookings',
    applies_to_service_type='standard_delivery',
    calculation_type='fixed_amount',
    percentage=None,
    fixed_amount_cents=5000,
    specific_date=None,
    applies_saturday=True,
    applies_sunday=True,
    is_active=True
)

SurchargeRule.objects.create(
    surcharge_type='geographic',
    name='CT/NJ Distance Surcharge',
    description='Additional charge for CT/NJ pickups (30+ min outside Manhattan)',
    applies_to_service_type='all',
    calculation_type='fixed_amount',
    percentage=None,
    fixed_amount_cents=22000,
    specific_date=None,
    applies_saturday=False,
    applies_sunday=False,
    is_active=True
)

SurchargeRule.objects.create(
    surcharge_type='geographic',
    name='Amagansett/Montauk Surcharge',
    description='Additional charge for Amagansett/Montauk deliveries',
    applies_to_service_type='all',
    calculation_type='fixed_amount',
    percentage=None,
    fixed_amount_cents=12000,
    specific_date=None,
    applies_saturday=False,
    applies_sunday=False,
    is_active=True
)

print("\n✅ Service catalog created successfully!")
print(f"📦 {MiniMovePackage.objects.count()} Mini Move Packages")
print(f"📋 {OrganizingService.objects.count()} Organizing Services")
print(f"🏄 {SpecialtyItem.objects.count()} Specialty Items")
print(f"🚚 {StandardDeliveryConfig.objects.count()} Standard Delivery Config")
print(f"💰 {SurchargeRule.objects.count()} Surcharge Rules")
```

# ==== requirements.txt ====

```
# Django Core - Latest LTS with full compatibility
Django==5.2.5
djangorestframework==3.16.1
django-cors-headers==4.6.0
django-environ==0.11.2

# Database
psycopg2-binary==2.9.9
dj-database-url==2.1.0

# Authentication & Security
djangorestframework-simplejwt==5.3.0
django-allauth==0.63.6
django-ipware==7.0.1

# API Documentation
drf-yasg==1.21.7

# Background Jobs - Latest stable versions
celery==5.5.3
redis==5.1.1
django-celery-beat==2.8.1

# File Storage
boto3==1.35.19
django-storages==1.14.4
Pillow==10.4.0

# Integrations - Latest versions
stripe==12.4.0
requests==2.32.3

# Monitoring & Logging
sentry-sdk==2.13.0

# Development
django-debug-toolbar==4.4.6
django-extensions==3.2.3

# Testing (Updated October 2025)
pytest==8.3.3
pytest-django==4.9.0
pytest-cov==5.0.0
factory-boy==3.3.1
faker==30.8.2
freezegun==1.5.1

# Production Server
gunicorn==23.0.0
whitenoise==6.7.0

# Rate Limiting & Caching
django-ratelimit==4.1.0
django-redis==5.4.0
```

# ==== staff_cookies.txt ====

```
# Netscape HTTP Cookie File
# https://curl.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

#HttpOnly_localhost	FALSE	/	FALSE	1758066188	sessionid	fwh9hh6geqv27ua54oalc21vmmdbzz6a
localhost	FALSE	/	FALSE	1788306188	csrftoken	9q6dfu6t1kUNO5j926PupDyEP2bSl9gP
```

# ========================= DJANGO PROJECT SETTINGS (config/) =========================


# ==== config/__init__.py ====

```python
# This will make sure the app is always imported when
# Django starts so that shared_task will use this app.
from .celery import app as celery_app

__all__ = ('celery_app',)
```

# ==== config/asgi.py ====

```python
"""
ASGI config for config project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_asgi_application()
```

# ==== config/celery.py ====

```python
import os
from celery import Celery

# Set the default Django settings module for the 'celery' program.
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

app = Celery('totetaxi')

# Using a string here means the worker doesn't have to serialize
# the configuration object to child processes.
app.config_from_object('django.conf:settings', namespace='CELERY')

# Load task modules from all registered Django apps.
app.autodiscover_tasks()

@app.task(bind=True, ignore_result=True)
def debug_task(self):
    print(f'Request: {self.request!r}')
```

# ==== config/settings.py ====

```python
import os
import sys
import environ
from pathlib import Path
from celery.schedules import crontab
import logging
import sentry_sdk
from sentry_sdk.integrations.django import DjangoIntegration
from sentry_sdk.integrations.celery import CeleryIntegration
from sentry_sdk.integrations.redis import RedisIntegration
from sentry_sdk.integrations.logging import LoggingIntegration



BASE_DIR = Path(__file__).resolve().parent.parent

env = environ.Env(
    DEBUG=(bool, False),
)

# Only load .env locally; Fly.io uses real env vars
if not os.environ.get('FLY_APP_NAME') and (BASE_DIR / '.env').exists():
    environ.Env.read_env(BASE_DIR / '.env')

SECRET_KEY = env('SECRET_KEY', default='django-insecure-change-me-in-production')
DEBUG = env('DEBUG', default=False)
FLY_APP_NAME = env('FLY_APP_NAME', default='')

SENTRY_DSN = env('SENTRY_DSN', default='')
SENTRY_ENVIRONMENT = env('SENTRY_ENVIRONMENT', default='development')
TESTING = 'test' in sys.argv or ('pytest' in sys.argv[0] if sys.argv else False)

def filter_sentry_events(event, hint):
    """Filter out certain events from being sent to Sentry"""
    if 'exc_info' in hint:
        exc_type, exc_value, tb = hint['exc_info']
        if exc_type.__name__ == 'DisallowedHost':
            return None
    
    if 'log_record' in hint:
        record = hint['log_record']
        if 'Not Found:' in record.getMessage():
            return None
    
    return event

if SENTRY_DSN and not TESTING:
    sentry_sdk.init(
        dsn=SENTRY_DSN,
        environment=SENTRY_ENVIRONMENT,
        integrations=[
            DjangoIntegration(
                transaction_style='url',
                middleware_spans=True,
                signals_spans=True,
                cache_spans=True,
            ),
            CeleryIntegration(
                monitor_beat_tasks=True,
                propagate_traces=True,
            ),
            RedisIntegration(),
            LoggingIntegration(
                level=logging.INFO,
                event_level=logging.ERROR
            ),
        ],
        traces_sample_rate=1.0 if DEBUG else 0.1,
        release=env('SENTRY_RELEASE', default=None),
        before_send=filter_sentry_events,
        attach_stacktrace=True,
        send_default_pii=False,
        max_breadcrumbs=50,
        debug=DEBUG,
    )

ALLOWED_HOSTS = env.list('ALLOWED_HOSTS', default=['localhost', '127.0.0.1', '0.0.0.0'])
if FLY_APP_NAME:
    ALLOWED_HOSTS.extend([
        f'{FLY_APP_NAME}.fly.dev',
        f'{FLY_APP_NAME}.internal',
        '.fly.dev',
    ])

DJANGO_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

THIRD_PARTY_APPS = [
    'rest_framework',
    'corsheaders',
    'django_celery_beat',
    'drf_yasg',
    'django_ratelimit',
]

LOCAL_APPS = [
    'apps.accounts',
    'apps.bookings',
    'apps.services',
    'apps.payments',
    'apps.logistics',
    'apps.customers',
]

INSTALLED_APPS = DJANGO_APPS + THIRD_PARTY_APPS + LOCAL_APPS

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [{
    'BACKEND': 'django.template.backends.django.DjangoTemplates',
    'DIRS': [BASE_DIR / 'templates'],
    'APP_DIRS': True,
    'OPTIONS': {
        'context_processors': [
            'django.template.context_processors.debug',
            'django.template.context_processors.request',
            'django.contrib.auth.context_processors.auth',
            'django.contrib.messages.context_processors.messages',
        ],
    },
}]

WSGI_APPLICATION = 'config.wsgi.application'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': env('DB_NAME', default='totetaxi'),
        'USER': env('DB_USER', default='postgres'),
        'PASSWORD': env('DB_PASSWORD', default='postgres'),
        'HOST': env('DB_HOST', default='db'),
        'PORT': env('DB_PORT', default='5432'),
    }
}
database_url = env('DATABASE_URL', default=None)
if database_url:
    import dj_database_url
    DATABASES['default'] = dj_database_url.config(
        default=database_url,
        conn_max_age=600,
        conn_health_checks=True,
    )

CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': env('REDIS_URL', default='redis://redis:6379/1'),
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'IGNORE_EXCEPTIONS': True,
        }
    }
}

RATELIMIT_USE_CACHE = 'default'
RATELIMIT_ENABLE = True

AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'America/New_York'
USE_I18N = True
USE_TZ = True

STATIC_URL = '/static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'
STATICFILES_DIRS = []
if (BASE_DIR / 'static').exists():
    STATICFILES_DIRS.append(BASE_DIR / 'static')
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'apps.customers.authentication.HybridAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.BrowsableAPIRenderer',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 20,
}

CORS_ALLOWED_ORIGINS = env.list('CORS_ALLOWED_ORIGINS', default=[
    'http://localhost:3000',
    'http://127.0.0.1:3000',
    'https://totetaxi.netlify.app',
])
if FLY_APP_NAME:
    CORS_ALLOWED_ORIGINS.append(f'https://{FLY_APP_NAME}.fly.dev')

CORS_ALLOW_CREDENTIALS = True
CORS_ALLOW_HEADERS = [
    'accept', 'accept-encoding', 'authorization', 'content-type', 'dnt',
    'origin', 'user-agent', 'x-csrftoken', 'x-requested-with', 'x-session-id',
]

CSRF_COOKIE_SECURE = not DEBUG
CSRF_COOKIE_HTTPONLY = False
CSRF_COOKIE_SAMESITE = 'Lax' if DEBUG else 'None'
CSRF_TRUSTED_ORIGINS = env.list('CSRF_TRUSTED_ORIGINS', default=[
    'http://localhost:3000',
    'http://127.0.0.1:3000',
    'https://totetaxi.netlify.app',
])
if FLY_APP_NAME:
    CSRF_TRUSTED_ORIGINS.extend([f'https://{FLY_APP_NAME}.fly.dev'])

SESSION_COOKIE_SECURE = not DEBUG
SESSION_COOKIE_SAMESITE = 'Lax' if DEBUG else 'None'
SESSION_COOKIE_AGE = 60 * 60 * 24 * 30
SESSION_EXPIRE_AT_BROWSER_CLOSE = False
SESSION_SAVE_EVERY_REQUEST = True
SESSION_COOKIE_NAME = 'totetaxi_sessionid'
SESSION_ENGINE = 'django.contrib.sessions.backends.db'

# EMAIL — use OS env first (Fly secrets), then .env
EMAIL_BACKEND = os.environ.get('EMAIL_BACKEND') or env('EMAIL_BACKEND', default='django.core.mail.backends.console.EmailBackend')
EMAIL_HOST = os.environ.get('EMAIL_HOST') or env('EMAIL_HOST', default='localhost')
EMAIL_PORT = int(os.environ.get('EMAIL_PORT', env.int('EMAIL_PORT', default=587)))
EMAIL_USE_TLS = (os.environ.get('EMAIL_USE_TLS', '') or '').lower() in ('true', '1', 'yes') if os.environ.get('EMAIL_USE_TLS') else env.bool('EMAIL_USE_TLS', default=True)
EMAIL_HOST_USER = os.environ.get('EMAIL_HOST_USER') or env('EMAIL_HOST_USER', default='')
EMAIL_HOST_PASSWORD = os.environ.get('EMAIL_HOST_PASSWORD') or env('EMAIL_HOST_PASSWORD', default='')
DEFAULT_FROM_EMAIL = os.environ.get('DEFAULT_FROM_EMAIL') or env('DEFAULT_FROM_EMAIL', default='ToteTaxi <noreply@totetaxi.com>')

# ⬇️ NEW: BCC list for booking confirmations (comma-separated env)
BOOKING_EMAIL_BCC = env.list('BOOKING_EMAIL_BCC', default=[])

FRONTEND_URL = env('FRONTEND_URL', default='https://totetaxi.netlify.app')

CELERY_BROKER_URL = env('REDIS_URL', default='redis://redis:6379/0')
CELERY_RESULT_BACKEND = env('REDIS_URL', default='redis://redis:6379/0')
CELERY_ACCEPT_CONTENT = ['application/json']
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TIMEZONE = TIME_ZONE

if not DEBUG:
    SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
    SECURE_SSL_REDIRECT = True
    SECURE_BROWSER_XSS_FILTER = True
    SECURE_CONTENT_TYPE_NOSNIFF = True
    SECURE_HSTS_INCLUDE_SUBDOMAINS = True
    SECURE_HSTS_SECONDS = 31536000
    SECURE_HSTS_PRELOAD = True
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {'format': '{levelname} {asctime} {module} {message}', 'style': '{'},
    },
    'handlers': {'console': {'class': 'logging.StreamHandler', 'formatter': 'verbose'}},
    'root': {'handlers': ['console'], 'level': 'INFO'},
    'loggers': {
        'django': {'handlers': ['console'], 'level': env('DJANGO_LOG_LEVEL', default='INFO'), 'propagate': False},
        'django.request': {'handlers': ['console'], 'level': 'DEBUG', 'propagate': False},
        'django_ratelimit': {'handlers': ['console'], 'level': 'INFO', 'propagate': False},
    },
}

# Stripe
STRIPE_SECRET_KEY = env('STRIPE_SECRET_KEY', default='')
STRIPE_PUBLISHABLE_KEY = env('STRIPE_PUBLISHABLE_KEY', default='')
STRIPE_WEBHOOK_SECRET = env('STRIPE_WEBHOOK_SECRET', default='')

# Onfleet
ONFLEET_API_KEY = env('ONFLEET_API_KEY', default='')
ONFLEET_MOCK_MODE = env.bool('ONFLEET_MOCK_MODE', default=True)
ONFLEET_ENVIRONMENT = env('ONFLEET_ENVIRONMENT', default='sandbox')
ONFLEET_WEBHOOK_SECRET = env('ONFLEET_WEBHOOK_SECRET', default='')

BLADE_PHONE_NUMBER = env('BLADE_PHONE_NUMBER', default='+1234567890')

CELERY_BEAT_SCHEDULE = {
    'send-booking-reminders-hourly': {
        'task': 'apps.bookings.tasks.send_booking_reminders',
        'schedule': crontab(minute=0),
        'options': {'expires': 3600}
    },
}# Replace your TESTING section cache configuration with this:
# ADD THIS TO YOUR config/settings.py - COMPLETE TESTING SECTION

# ============================================================================
# TEST CONFIGURATION
# ============================================================================
# Detect if we're running tests
TESTING = 'test' in sys.argv or ('pytest' in sys.argv[0] if sys.argv else False)

if TESTING:
    # Use faster in-memory SQLite for tests
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': ':memory:',
        }
    }

    # Disable password hashing for faster tests
    PASSWORD_HASHERS = [
        'django.contrib.auth.hashers.MD5PasswordHasher',
    ]

    # Use console email backend for tests
    EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

    # Make Celery tasks run synchronously during tests
    CELERY_TASK_ALWAYS_EAGER = True
    CELERY_TASK_EAGER_PROPAGATES = True

    # Disable ratelimit logic
    RATELIMIT_ENABLE = False
    
    # Use Redis for tests (different DB number) - required by django-ratelimit
    CACHES = {
        'default': {
            'BACKEND': 'django_redis.cache.RedisCache',
            'LOCATION': env('REDIS_URL', default='redis://redis:6379/2'),  # DB 2 for tests
            'OPTIONS': {
                'CLIENT_CLASS': 'django_redis.client.DefaultClient',
                'IGNORE_EXCEPTIONS': True,
            }
        }
    }

    # ✅ Force Onfleet mock mode during tests
    ONFLEET_MOCK_MODE = True
    ONFLEET_ENVIRONMENT = 'sandbox'

    # Relax cookie security for test client
    CSRF_COOKIE_SECURE = False
    SESSION_COOKIE_SECURE = False
```

# ==== config/urls.py ====

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),

    # Public + customer
    path('api/customer/', include('apps.customers.urls')),
    path('api/public/', include('apps.bookings.urls')),

    # Payments (includes Stripe webhook)
    path('api/payments/', include('apps.payments.urls')),

    # Staff
    path('api/staff/', include('apps.accounts.urls')),
    path('api/staff/logistics/', include('apps.logistics.urls')),
]
```

# ==== config/wsgi.py ====

```python
"""
WSGI config for config project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_wsgi_application()
```

# ========================= DJANGO APPLICATIONS (apps/) =========================


# ==== apps/accounts/__init__.py ====

```python

```

# ==== apps/accounts/admin.py ====

```python
from django.contrib import admin
from django.core.exceptions import ValidationError
from django.contrib import messages
from .models import StaffProfile, StaffAction


@admin.register(StaffProfile)
class StaffProfileAdmin(admin.ModelAdmin):
    list_display = ('user', 'user_email', 'role', 'department', 'can_approve_refunds', 'can_manage_staff', 'is_active', 'created_at')
    list_filter = ('role', 'department', 'is_active', 'created_at')
    search_fields = ('user__username', 'user__email', 'user__first_name', 'user__last_name')
    readonly_fields = ('can_approve_refunds', 'can_manage_staff', 'can_view_financial_reports', 'is_account_locked', 'created_at', 'updated_at')
    
    fieldsets = (
        ('User Information', {
            'fields': ('user', 'role', 'department', 'phone')
        }),
        ('Permissions', {
            'fields': ('can_approve_refunds', 'can_manage_staff', 'can_view_financial_reports'),
            'classes': ('collapse',)
        }),
        ('Security', {
            'fields': ('login_attempts', 'account_locked_until', 'is_account_locked', 'last_login_ip'),
            'classes': ('collapse',)
        }),
        ('Management', {
            'fields': ('is_active', 'hire_date', 'created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
    )
    
    def user_email(self, obj):
        return obj.user.email
    user_email.short_description = 'Email'
    user_email.admin_order_field = 'user__email'
    
    def save_model(self, request, obj, form, change):
        try:
            super().save_model(request, obj, form, change)
        except ValidationError as e:
            messages.error(request, f"Cannot save staff profile: {e}")
            raise
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related('user')


@admin.register(StaffAction)
class StaffActionAdmin(admin.ModelAdmin):
    list_display = ('staff_user', 'action_type', 'created_at', 'ip_address', 'customer_id', 'booking_id')
    list_filter = ('action_type', 'created_at')
    search_fields = ('staff_user__username', 'staff_user__email', 'description', 'ip_address')
    readonly_fields = ('staff_user', 'action_type', 'description', 'ip_address', 'user_agent', 'customer_id', 'booking_id', 'created_at')
    ordering = ('-created_at',)
    
    def has_add_permission(self, request):
        # Staff actions should only be created programmatically
        return False
    
    def has_change_permission(self, request, obj=None):
        # Staff actions should be immutable audit logs
        return False
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related('staff_user')
```

# ==== apps/accounts/apps.py ====

```python
from django.apps import AppConfig

class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.accounts'  # Changed from 'accounts' to 'apps.accounts'
```

# ==== apps/accounts/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.5 on 2025-09-02 20:54

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='StaffProfile',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('role', models.CharField(choices=[('staff', 'Staff'), ('admin', 'Admin')], default='staff', max_length=20)),
                ('department', models.CharField(blank=True, max_length=50)),
                ('hire_date', models.DateField(blank=True, null=True)),
                ('phone', models.CharField(blank=True, max_length=20)),
                ('last_login_ip', models.GenericIPAddressField(blank=True, null=True)),
                ('login_attempts', models.PositiveIntegerField(default=0)),
                ('account_locked_until', models.DateTimeField(blank=True, null=True)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='staff_profile', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Staff Profile',
                'verbose_name_plural': 'Staff Profiles',
                'db_table': 'accounts_staff_profile',
            },
        ),
        migrations.CreateModel(
            name='StaffAction',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('action_type', models.CharField(choices=[('login', 'Login'), ('logout', 'Logout'), ('view_customer', 'View Customer'), ('modify_booking', 'Modify Booking'), ('process_refund', 'Process Refund'), ('approve_refund', 'Approve Refund'), ('upload_document', 'Upload Document'), ('send_notification', 'Send Notification'), ('export_data', 'Export Data')], max_length=30)),
                ('description', models.TextField()),
                ('ip_address', models.GenericIPAddressField()),
                ('user_agent', models.TextField(blank=True)),
                ('customer_id', models.UUIDField(blank=True, help_text='Customer affected by action', null=True)),
                ('booking_id', models.UUIDField(blank=True, help_text='Booking affected by action', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('staff_user', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='staff_actions', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'accounts_staff_action',
                'ordering': ['-created_at'],
                'indexes': [models.Index(fields=['staff_user', '-created_at'], name='accounts_st_staff_u_7518f9_idx'), models.Index(fields=['action_type', '-created_at'], name='accounts_st_action__992fd0_idx'), models.Index(fields=['customer_id'], name='accounts_st_custome_407eb4_idx'), models.Index(fields=['booking_id'], name='accounts_st_booking_824dc4_idx')],
            },
        ),
    ]
```

# ==== apps/accounts/migrations/0002_alter_staffaction_action_type.py ====

```python
# Generated by Django 5.2.5 on 2025-09-25 23:09

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0001_initial'),
    ]

    operations = [
        migrations.AlterField(
            model_name='staffaction',
            name='action_type',
            field=models.CharField(choices=[('login', 'Login'), ('logout', 'Logout'), ('view_customer', 'View Customer'), ('modify_booking', 'Modify Booking'), ('process_refund', 'Process Refund'), ('approve_refund', 'Approve Refund'), ('upload_document', 'Upload Document'), ('send_notification', 'Send Notification'), ('export_data', 'Export Data'), ('view_dashboard', 'View Dashboard'), ('modify_customer', 'Modify Customer')], max_length=30),
        ),
    ]
```

# ==== apps/accounts/migrations/__init__.py ====

```python

```

# ==== apps/accounts/models.py ====

```python
import uuid
from django.contrib.auth.models import User
from django.db import models
from django.core.exceptions import ValidationError
from django.utils import timezone


class StaffProfile(models.Model):
    """Extended profile for staff users (Django User model + additional fields)"""
    
    ROLE_CHOICES = [
        ('staff', 'Staff'),
        ('admin', 'Admin'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='staff_profile')
    
    # Staff role within the staff system
    role = models.CharField(max_length=20, choices=ROLE_CHOICES, default='staff')
    
    # Staff-specific information
    department = models.CharField(max_length=50, blank=True)
    hire_date = models.DateField(null=True, blank=True)
    phone = models.CharField(max_length=20, blank=True)
    
    # Permissions tracking
    last_login_ip = models.GenericIPAddressField(null=True, blank=True)
    login_attempts = models.PositiveIntegerField(default=0)
    account_locked_until = models.DateTimeField(null=True, blank=True)
    
    # Management
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'accounts_staff_profile'
        verbose_name = 'Staff Profile'
        verbose_name_plural = 'Staff Profiles'
    
    def clean(self):
        """Prevent hybrid accounts - users cannot have both staff and customer profiles"""
        if self.user and hasattr(self.user, 'customer_profile'):
            raise ValidationError(
                f"User {self.user.email} already has a customer profile. "
                "Users cannot have both staff and customer profiles."
            )
    
    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)
    
    def __str__(self):
        return f"{self.user.get_full_name()} ({self.role})"
    
    @property
    def can_approve_refunds(self):
        """Only admin role can approve refunds"""
        return self.role == 'admin'
    
    @property
    def can_manage_staff(self):
        """Only admin role can manage other staff accounts"""
        return self.role == 'admin'
    
    @property
    def can_view_financial_reports(self):
        """Both staff and admin can view financial reports"""
        return self.role in ['staff', 'admin']
    
    @property
    def full_name(self):
        """Get full name from associated User model"""
        return self.user.get_full_name()
    
    @property
    def email(self):
        """Get email from associated User model"""
        return self.user.email
    
    def lock_account(self, minutes=30):
        """Lock account for specified minutes after failed login attempts"""
        self.account_locked_until = timezone.now() + timezone.timedelta(minutes=minutes)
        self.save()
    
    def unlock_account(self):
        """Unlock account and reset login attempts"""
        self.account_locked_until = None
        self.login_attempts = 0
        self.save()
    
    @property
    def is_account_locked(self):
        """Check if account is currently locked"""
        if self.account_locked_until:
            return timezone.now() < self.account_locked_until
        return False

    @classmethod
    def ensure_single_profile_type(cls, user):
        """Ensure user only has one type of profile"""
        if hasattr(user, 'staff_profile') and hasattr(user, 'customer_profile'):
            raise ValidationError(
                f"User {user.email} cannot have both staff and customer profiles. "
                "Please remove one profile type."
            )


class StaffAction(models.Model):
    """Audit log for staff actions - required for compliance"""
    
    ACTION_TYPES = [
        ('login', 'Login'),
        ('logout', 'Logout'),
        ('view_customer', 'View Customer'),
        ('modify_booking', 'Modify Booking'),
        ('process_refund', 'Process Refund'),
        ('approve_refund', 'Approve Refund'),
        ('upload_document', 'Upload Document'),
        ('send_notification', 'Send Notification'),
        ('export_data', 'Export Data'),
        ('view_dashboard', 'View Dashboard'),
        ('modify_customer', 'Modify Customer'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Who performed the action
    staff_user = models.ForeignKey(User, on_delete=models.PROTECT, related_name='staff_actions')
    
    # What action was performed
    action_type = models.CharField(max_length=30, choices=ACTION_TYPES)
    description = models.TextField()
    
    # Context information
    ip_address = models.GenericIPAddressField()
    user_agent = models.TextField(blank=True)
    
    # Related objects (for tracking what was accessed/modified)
    customer_id = models.UUIDField(null=True, blank=True, help_text="Customer affected by action")
    booking_id = models.UUIDField(null=True, blank=True, help_text="Booking affected by action")
    
    # Timing
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'accounts_staff_action'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['staff_user', '-created_at']),
            models.Index(fields=['action_type', '-created_at']),
            models.Index(fields=['customer_id']),
            models.Index(fields=['booking_id']),
        ]
    
    def __str__(self):
        return f"{self.staff_user.username} - {self.action_type} - {self.created_at}"
    
    @classmethod
    def log_action(cls, staff_user, action_type, description, request=None, customer_id=None, booking_id=None):
        """Helper method to log staff actions with proper IP detection"""
        ip_address = '127.0.0.1'  # default fallback
        user_agent = ''
        
        if request:
            # Get client IP from request
            x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
            if x_forwarded_for:
                ip_address = x_forwarded_for.split(',')[0].strip()
            else:
                ip_address = request.META.get('REMOTE_ADDR', '127.0.0.1')
            
            user_agent = request.META.get('HTTP_USER_AGENT', '')
        
        return cls.objects.create(
            staff_user=staff_user,
            action_type=action_type,
            description=description,
            ip_address=ip_address,
            user_agent=user_agent,
            customer_id=customer_id,
            booking_id=booking_id
        )
```

# ==== apps/accounts/serializers.py ====

```python
from rest_framework import serializers
from django.contrib.auth.models import User
from django.core.exceptions import ValidationError
from .models import StaffProfile, StaffAction


class StaffUserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ('id', 'username', 'email', 'first_name', 'last_name', 'is_active', 'date_joined')
        read_only_fields = ('id', 'date_joined')


class StaffProfileSerializer(serializers.ModelSerializer):
    user = StaffUserSerializer(read_only=True)
    full_name = serializers.ReadOnlyField()
    email = serializers.ReadOnlyField()
    can_approve_refunds = serializers.ReadOnlyField()
    can_manage_staff = serializers.ReadOnlyField()
    can_view_financial_reports = serializers.ReadOnlyField()
    
    class Meta:
        model = StaffProfile
        fields = (
            'id', 'user', 'role', 'department', 'hire_date', 'phone',
            'full_name', 'email', 'is_active', 'can_approve_refunds',
            'can_manage_staff', 'can_view_financial_reports', 'created_at'
        )
        read_only_fields = ('id', 'created_at')


class StaffLoginSerializer(serializers.Serializer):
    username = serializers.CharField()
    password = serializers.CharField(write_only=True)
    
    def validate(self, attrs):
        username = attrs.get('username')
        password = attrs.get('password')
        
        if not username or not password:
            raise serializers.ValidationError("Must include username and password")
        
        return attrs


class StaffActionSerializer(serializers.ModelSerializer):
    staff_user_name = serializers.SerializerMethodField()
    
    class Meta:
        model = StaffAction
        fields = (
            'id', 'action_type', 'description', 'staff_user_name',
            'ip_address', 'customer_id', 'booking_id', 'created_at'
        )
        read_only_fields = ('id', 'created_at')
    
    def get_staff_user_name(self, obj):
        return obj.staff_user.get_full_name() if obj.staff_user else None


class StaffCreateSerializer(serializers.Serializer):
    """Serializer for creating staff accounts with hybrid prevention"""
    username = serializers.CharField(max_length=150)
    email = serializers.EmailField()
    password = serializers.CharField(min_length=8, write_only=True)
    first_name = serializers.CharField(max_length=150)
    last_name = serializers.CharField(max_length=150)
    role = serializers.ChoiceField(choices=StaffProfile.ROLE_CHOICES)
    department = serializers.CharField(max_length=50, required=False, allow_blank=True)
    phone = serializers.CharField(max_length=20, required=False, allow_blank=True)
    
    def validate(self, attrs):
        # Check if email already exists
        if User.objects.filter(email__iexact=attrs['email']).exists():
            existing_user = User.objects.get(email__iexact=attrs['email'])
            if hasattr(existing_user, 'customer_profile'):
                raise serializers.ValidationError("This email is already registered as a customer account. Please use a different email.")
            else:
                raise serializers.ValidationError("User with this email already exists")
        
        # Check if username already exists
        if User.objects.filter(username=attrs['username']).exists():
            raise serializers.ValidationError("Username already exists")
        
        return attrs
    
    def create(self, validated_data):
        # Extract staff profile fields
        role = validated_data.pop('role')
        department = validated_data.pop('department', '')
        phone = validated_data.pop('phone', '')
        
        try:
            # Create User
            user = User.objects.create_user(**validated_data)
            
            # Create StaffProfile with validation
            StaffProfile.objects.create(
                user=user,
                role=role,
                department=department,
                phone=phone
            )
            
            return user
            
        except ValidationError as e:
            # Clean up user if profile creation fails
            if 'user' in locals():
                user.delete()
            raise serializers.ValidationError(str(e))
```

# ==== apps/accounts/urls.py ====

```python
from django.urls import path
from . import views

# Staff API patterns
urlpatterns = [
    # Authentication
    path('auth/login/', views.StaffLoginView.as_view(), name='staff-login'),
    path('auth/logout/', views.StaffLogoutView.as_view(), name='staff-logout'),
    path('csrf-token/', views.StaffCSRFTokenView.as_view(), name='staff-csrf-token'),  # ADD THIS

    
    # Dashboard and operations
    path('dashboard/', views.StaffDashboardView.as_view(), name='staff-dashboard'),
    path('bookings/', views.BookingManagementView.as_view(), name='staff-bookings'),
    path('bookings/<uuid:booking_id>/', views.BookingDetailView.as_view(), name='staff-booking-detail'),
    
    # Customer management
    path('customers/', views.CustomerManagementView.as_view(), name='staff-customers'),
    path('customers/<int:customer_id>/', views.CustomerDetailView.as_view(), name='staff-customer-detail'),
    path('customers/<int:customer_id>/notes/', views.CustomerNotesUpdateView.as_view(), name='staff-customer-notes'),
]
```

# ==== apps/accounts/views.py ====

```python
# backend/apps/accounts/views.py
from rest_framework import generics, status, permissions
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.contrib.auth import login, logout, authenticate
from django.contrib.auth.models import User
from django.middleware.csrf import get_token
from django.views.decorators.csrf import ensure_csrf_cookie
from django.utils.decorators import method_decorator
from django.shortcuts import get_object_or_404
from django.db.models import Q, Count
from django_ratelimit.decorators import ratelimit
from .models import StaffProfile, StaffAction
from .serializers import (
    StaffLoginSerializer,
    StaffProfileSerializer,
    StaffUserSerializer,
    StaffActionSerializer
)
from apps.bookings.models import Booking
from apps.customers.models import CustomerProfile
from apps.payments.models import Payment, Refund
from apps.payments.serializers import RefundSerializer


@method_decorator(ratelimit(key='ip', rate='5/m', method='POST', block=True), name='post')
@method_decorator(ratelimit(key='header:user-agent', rate='10/m', method='POST', block=True), name='post')
@method_decorator(ensure_csrf_cookie, name='dispatch')
class StaffLoginView(APIView):
    """Staff authentication endpoint with rate limiting protection"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = StaffLoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        username = serializer.validated_data['username']
        password = serializer.validated_data['password']
        
        user = authenticate(username=username, password=password)
        
        if user and user.is_active:
            if not hasattr(user, 'staff_profile'):
                return Response(
                    {'error': 'This is not a staff account'}, 
                    status=status.HTTP_403_FORBIDDEN
                )
            
            if user.staff_profile.is_account_locked:
                return Response(
                    {'error': 'Account is temporarily locked. Contact administrator.'}, 
                    status=status.HTTP_403_FORBIDDEN
                )
            
            login(request, user)
            
            StaffAction.log_action(
                staff_user=user,
                action_type='login',
                description=f'Staff user {user.username} logged in successfully',
                request=request
            )
            
            user.staff_profile.login_attempts = 0
            user.staff_profile.save()
            
            # Ensure session is saved before getting key
            request.session.save()
            
            # Return session_id for mobile compatibility
            response = Response({
                'message': 'Login successful',
                'user': StaffUserSerializer(user).data,
                'staff_profile': StaffProfileSerializer(user.staff_profile).data,
                'session_id': request.session.session_key,
                'csrf_token': get_token(request)
            })
            
            return response
        else:
            if user:
                staff_profile = getattr(user, 'staff_profile', None)
                if staff_profile:
                    staff_profile.login_attempts += 1
                    if staff_profile.login_attempts >= 5:
                        staff_profile.lock_account(minutes=30)
                    staff_profile.save()
            
            return Response(
                {'error': 'Invalid username or password'}, 
                status=status.HTTP_401_UNAUTHORIZED
            )

@method_decorator(ratelimit(key='user', rate='10/m', method='POST', block=True), name='post')
class StaffLogoutView(APIView):
    """Staff logout endpoint with rate limiting"""
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        # Log logout action
        StaffAction.log_action(
            staff_user=request.user,
            action_type='logout',
            description=f'Staff user {request.user.username} logged out',
            request=request
        )
        
        logout(request)
        return Response({'message': 'Logout successful'})


@method_decorator(ratelimit(key='user', rate='30/m', method='GET', block=True), name='get')
class StaffDashboardView(APIView):
    """Staff operations dashboard with KPIs and rate limiting"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        if not hasattr(request.user, 'staff_profile'):
            return Response(
                {'error': 'Not a staff account'}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        # Log dashboard access
        StaffAction.log_action(
            staff_user=request.user,
            action_type='view_dashboard',
            description='Accessed staff dashboard',
            request=request
        )
        
        # Get booking statistics
        total_bookings = Booking.objects.filter(deleted_at__isnull=True).count()
        pending_bookings = Booking.objects.filter(status='pending', deleted_at__isnull=True).count()
        confirmed_bookings = Booking.objects.filter(status='confirmed', deleted_at__isnull=True).count()
        paid_bookings = Booking.objects.filter(status='paid', deleted_at__isnull=True).count()
        completed_bookings = Booking.objects.filter(status='completed', deleted_at__isnull=True).count()
        
        # Get payment statistics
        total_payments = Payment.objects.filter(status='succeeded').count()
        pending_payments = Payment.objects.filter(status='pending').count()
        failed_payments = Payment.objects.filter(status='failed').count()
        
        # Calculate revenue
        from django.db.models import Sum
        total_revenue_cents = Payment.objects.filter(status='succeeded').aggregate(
            total=Sum('amount_cents')
        )['total'] or 0
        
        # Get recent bookings needing attention
        urgent_bookings = Booking.objects.filter(
            status__in=['pending', 'confirmed'],
            deleted_at__isnull=True
        ).order_by('pickup_date', 'created_at')[:10]
        
        # Get customer statistics
        total_customers = CustomerProfile.objects.count()
        vip_customers = CustomerProfile.objects.filter(is_vip=True).count()
        
        return Response({
            'staff_info': {
                'name': request.user.get_full_name(),
                'role': request.user.staff_profile.role,
                'permissions': {
                    'can_approve_refunds': request.user.staff_profile.can_approve_refunds,
                    'can_manage_staff': request.user.staff_profile.can_manage_staff,
                    'can_view_financial_reports': request.user.staff_profile.can_view_financial_reports
                }
            },
            'booking_stats': {
                'total_bookings': total_bookings,
                'pending_bookings': pending_bookings,
                'confirmed_bookings': confirmed_bookings,
                'paid_bookings': paid_bookings,
                'completed_bookings': completed_bookings
            },
            'payment_stats': {
                'total_payments': total_payments,
                'pending_payments': pending_payments,
                'failed_payments': failed_payments,
                'total_revenue_dollars': total_revenue_cents / 100
            },
            'customer_stats': {
                'total_customers': total_customers,
                'vip_customers': vip_customers
            },
            'urgent_bookings': self._serialize_urgent_bookings(urgent_bookings)
        })
    
    def _serialize_urgent_bookings(self, bookings):
        """Serialize urgent bookings for dashboard"""
        urgent_data = []
        for booking in bookings:
            urgent_data.append({
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'customer_name': booking.get_customer_name(),
                'customer_email': booking.get_customer_email(),
                'service_type': booking.get_service_type_display(),
                'pickup_date': booking.pickup_date,
                'status': booking.get_status_display(),
                'total_price_dollars': booking.total_price_dollars,
                'created_at': booking.created_at
            })
        return urgent_data


@method_decorator(ratelimit(key='user', rate='20/m', method='GET', block=True), name='get')
class CustomerManagementView(APIView):
    """Staff customer management with rate limiting - list and search customers"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Not a staff account'}, status=status.HTTP_403_FORBIDDEN)
        
        # Get query parameters
        search = request.query_params.get('search', '')
        vip = request.query_params.get('vip', '')
        
        # Start with all customer profiles
        customers = User.objects.filter(customer_profile__isnull=False).select_related('customer_profile')
        
        # Apply search filter
        if search:
            customers = customers.filter(
                Q(first_name__icontains=search) |
                Q(last_name__icontains=search) |
                Q(email__icontains=search) |
                Q(customer_profile__phone__icontains=search)
            )
        
        # Apply VIP filter
        if vip == 'true':
            customers = customers.filter(customer_profile__is_vip=True)
        elif vip == 'false':
            customers = customers.filter(customer_profile__is_vip=False)
        
        # Serialize customer data
        customer_data = []
        for user in customers[:100]:  # Limit to 100 results
            profile = user.customer_profile
            
            # Get recent bookings
            recent_bookings = user.bookings.filter(deleted_at__isnull=True).order_by('-created_at')[:5]
            
            customer_data.append({
                'id': user.id,
                'name': user.get_full_name(),
                'email': user.email,
                'phone': profile.phone,
                'is_vip': profile.is_vip,
                'total_bookings': profile.total_bookings,
                'total_spent_dollars': profile.total_spent_dollars,
                'last_booking_at': profile.last_booking_at,
                'created_at': profile.created_at,
                'notes': profile.notes,
                'recent_bookings': [{
                    'id': str(booking.id),
                    'booking_number': booking.booking_number,
                    'service_type': booking.get_service_type_display(),
                    'status': booking.status,
                    'total_price_dollars': booking.total_price_dollars,
                    'created_at': booking.created_at
                } for booking in recent_bookings],
                'saved_addresses': [{
                    'id': str(addr.id),
                    'address_line_1': addr.address_line_1,
                    'city': addr.city,
                    'state': addr.state,
                    'is_primary': addr.times_used > 0
                } for addr in user.saved_addresses.filter(is_active=True)[:3]]
            })
        
        return Response({
            'customers': customer_data,
            'total_count': customers.count(),
            'filters': {
                'search': search,
                'vip': vip
            }
        })


@method_decorator(ratelimit(key='user', rate='15/m', method='GET', block=True), name='get')
class CustomerDetailView(APIView):
    """Staff view for individual customer details with rate limiting"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request, customer_id):
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Not a staff account'}, status=status.HTTP_403_FORBIDDEN)
        
        try:
            user = User.objects.get(id=customer_id, customer_profile__isnull=False)
            profile = user.customer_profile
        except User.DoesNotExist:
            return Response({'error': 'Customer not found'}, status=status.HTTP_404_NOT_FOUND)
        
        # Log viewing customer data
        StaffAction.log_action(
            staff_user=request.user,
            action_type='view_customer',
            description=f'Viewed customer {user.get_full_name()} ({user.email})',
            request=request,
            customer_id=user.id
        )
        
        # Get all bookings
        all_bookings = user.bookings.filter(deleted_at__isnull=True).order_by('-created_at')
        
        return Response({
            'id': user.id,
            'name': user.get_full_name(),
            'email': user.email,
            'phone': profile.phone,
            'is_vip': profile.is_vip,
            'total_bookings': profile.total_bookings,
            'total_spent_dollars': profile.total_spent_dollars,
            'last_booking_at': profile.last_booking_at,
            'created_at': profile.created_at,
            'notes': profile.notes,
            'recent_bookings': [{
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'service_type': booking.get_service_type_display(),
                'status': booking.status,
                'total_price_dollars': booking.total_price_dollars,
                'created_at': booking.created_at
            } for booking in all_bookings],
            'saved_addresses': [{
                'id': str(addr.id),
                'address_line_1': addr.address_line_1,
                'address_line_2': addr.address_line_2,
                'city': addr.city,
                'state': addr.state,
                'zip_code': addr.zip_code,
                'is_primary': addr.times_used > 0
            } for addr in user.saved_addresses.filter(is_active=True)]
        })


@method_decorator(ratelimit(key='user', rate='5/m', method='PATCH', block=True), name='patch')
class CustomerNotesUpdateView(APIView):
    """Update customer notes with rate limiting - staff only"""
    permission_classes = [permissions.IsAuthenticated]
    
    def patch(self, request, customer_id):
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Staff access required'}, status=status.HTTP_403_FORBIDDEN)
        
        try:
            user = User.objects.get(id=customer_id, customer_profile__isnull=False)
            profile = user.customer_profile
        except User.DoesNotExist:
            return Response({'error': 'Customer not found'}, status=status.HTTP_404_NOT_FOUND)
        
        notes = request.data.get('notes', '')
        old_notes = profile.notes
        
        profile.notes = notes
        profile.save()
        
        # Log notes update
        StaffAction.log_action(
            staff_user=request.user,
            action_type='modify_customer',
            description=f'Updated notes for customer {user.get_full_name()}',
            request=request,
            customer_id=user.id
        )
        
        return Response({
            'message': 'Customer notes updated successfully',
            'notes': profile.notes
        })


@method_decorator(ratelimit(key='user', rate='30/m', method='GET', block=True), name='get')
class BookingManagementView(APIView):
    """Enhanced staff booking management with rate limiting and date range support"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        """List all bookings with enhanced filtering including date ranges"""
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Not a staff account'}, status=status.HTTP_403_FORBIDDEN)
        
        # Get query parameters
        status_filter = request.query_params.get('status', None)
        date_filter = request.query_params.get('date', None)
        start_date = request.query_params.get('start_date', None)
        end_date = request.query_params.get('end_date', None)
        search = request.query_params.get('search', None)
        
        # ✅ OPTIMIZED: Added select_related to avoid N+1 queries
        bookings = Booking.objects.filter(
            deleted_at__isnull=True
        ).select_related(
            'customer',
            'customer__customer_profile',
            'guest_checkout',
            'mini_move_package',
            'pickup_address',
            'delivery_address'
        ).order_by('-created_at')
        
        if status_filter:
            bookings = bookings.filter(status=status_filter)
        
        if date_filter:
            bookings = bookings.filter(pickup_date=date_filter)
        
        # Date range filtering for calendar
        if start_date and end_date:
            bookings = bookings.filter(
                pickup_date__gte=start_date,
                pickup_date__lte=end_date
            )
        elif start_date:
            bookings = bookings.filter(pickup_date__gte=start_date)
        elif end_date:
            bookings = bookings.filter(pickup_date__lte=end_date)
        
        if search:
            bookings = bookings.filter(
                Q(booking_number__icontains=search) |
                Q(customer__email__icontains=search) |
                Q(guest_checkout__email__icontains=search) |
                Q(customer__first_name__icontains=search) |
                Q(customer__last_name__icontains=search) |
                Q(guest_checkout__first_name__icontains=search) |
                Q(guest_checkout__last_name__icontains=search)
            )
        
        # Serialize bookings
        booking_data = []
        for booking in bookings[:50]:  # Limit to 50 results
            booking_data.append({
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'customer_name': booking.get_customer_name(),
                'customer_email': booking.get_customer_email(),
                'service_type': booking.get_service_type_display(),
                'pickup_date': booking.pickup_date,
                'pickup_time': booking.get_pickup_time_display(),
                'status': booking.get_status_display(),
                'total_price_dollars': booking.total_price_dollars,
                'payment_status': self._get_payment_status(booking),
                'created_at': booking.created_at,
                'coi_required': booking.coi_required
            })
        
        return Response({
            'bookings': booking_data,
            'total_count': bookings.count(),
            'filters': {
                'status': status_filter,
                'date': date_filter,
                'start_date': start_date,
                'end_date': end_date,
                'search': search
            }
        })
    
    def _get_payment_status(self, booking):
        """Get payment status for booking"""
        payment = booking.payments.first()
        return payment.status if payment else 'not_created'

@method_decorator(ratelimit(key='user', rate='20/m', method='GET', block=True), name='get')
@method_decorator(ratelimit(key='user', rate='10/m', method='PATCH', block=True), name='patch')
class BookingDetailView(APIView):
    """Staff view for individual booking details and management with rate limiting"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request, booking_id):
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Not a staff account'}, status=status.HTTP_403_FORBIDDEN)
        
        try:
            booking = Booking.objects.select_related(
                'customer', 'customer__customer_profile', 
                'mini_move_package', 'guest_checkout',
                'pickup_address', 'delivery_address'
            ).prefetch_related('specialty_items').get(id=booking_id, deleted_at__isnull=True)
        except Booking.DoesNotExist:
            return Response({'error': 'Booking not found'}, status=status.HTTP_404_NOT_FOUND)
        
        # Log viewing booking data
        StaffAction.log_action(
            staff_user=request.user,
            action_type='view_booking',
            description=f'Viewed booking {booking.booking_number}',
            request=request,
            booking_id=booking.id
        )
        
        # Get payment information
        payment = booking.payments.first()
        payment_data = None
        if payment:
            payment_data = {
                'id': str(payment.id),
                'status': payment.status,
                'amount_dollars': payment.amount_dollars,
                'stripe_payment_intent_id': payment.stripe_payment_intent_id,
                'processed_at': payment.processed_at,
                'failure_reason': payment.failure_reason
            }
        
        # Get refund information
        refunds_data = []
        if payment:
            refunds = Refund.objects.filter(payment=payment).order_by('-created_at')
            refunds_data = RefundSerializer(refunds, many=True).data
        
        # Get customer information
        customer_data = None
        if booking.customer:
            customer_data = {
                'id': booking.customer.id,
                'name': booking.customer.get_full_name(),
                'email': booking.customer.email,
                'phone': getattr(booking.customer.customer_profile, 'phone', ''),
                'is_vip': getattr(booking.customer.customer_profile, 'is_vip', False),
                'total_bookings': getattr(booking.customer.customer_profile, 'total_bookings', 0),
                'total_spent_dollars': getattr(booking.customer.customer_profile, 'total_spent_dollars', 0)
            }
        
        # Get service-specific details
        service_details = self._get_service_details(booking)
        
        return Response({
            'booking': {
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'service_type': booking.service_type,
                'service_type_display': booking.get_service_type_display(),
                'status': booking.status,
                'pickup_date': booking.pickup_date,
                'pickup_time': booking.pickup_time,
                'pickup_time_display': booking.get_pickup_time_display(),
                'specific_pickup_hour': booking.specific_pickup_hour,
                'pickup_address': {
                    'address_line_1': booking.pickup_address.address_line_1,
                    'address_line_2': booking.pickup_address.address_line_2,
                    'city': booking.pickup_address.city,
                    'state': booking.pickup_address.state,
                    'zip_code': booking.pickup_address.zip_code
                },
                'delivery_address': {
                    'address_line_1': booking.delivery_address.address_line_1,
                    'address_line_2': booking.delivery_address.address_line_2,
                    'city': booking.delivery_address.city,
                    'state': booking.delivery_address.state,
                    'zip_code': booking.delivery_address.zip_code
                },
                'special_instructions': booking.special_instructions,
                'coi_required': booking.coi_required,
                'is_outside_core_area': booking.is_outside_core_area,
                
                # PRICING FIELDS
                'base_price_dollars': booking.base_price_dollars,
                'surcharge_dollars': booking.surcharge_dollars,
                'same_day_surcharge_dollars': booking.same_day_surcharge_dollars,
                'coi_fee_dollars': booking.coi_fee_dollars,
                'organizing_total_dollars': booking.organizing_total_dollars,
                'organizing_tax_dollars': booking.organizing_tax_dollars,
                'geographic_surcharge_dollars': booking.geographic_surcharge_dollars,
                'time_window_surcharge_dollars': booking.time_window_surcharge_dollars,
                'total_price_dollars': booking.total_price_dollars,
                
                'pricing_breakdown': booking.get_pricing_breakdown(),
                'service_details': service_details,
                'created_at': booking.created_at,
                'updated_at': booking.updated_at
            },
            'customer': customer_data,
            'guest_checkout': {
                'first_name': booking.guest_checkout.first_name if booking.guest_checkout else None,
                'last_name': booking.guest_checkout.last_name if booking.guest_checkout else None,
                'email': booking.guest_checkout.email if booking.guest_checkout else None,
                'phone': booking.guest_checkout.phone if booking.guest_checkout else None
            } if booking.guest_checkout else None,
            'payment': payment_data,
            'refunds': refunds_data
        })
    
    def _get_service_details(self, booking):
        """Get detailed service-specific information"""
        from apps.services.models import OrganizingService
        
        details = {}
        
        # Mini Move details
        if booking.service_type == 'mini_move' and booking.mini_move_package:
            details['mini_move'] = {
                'package_name': booking.mini_move_package.name,
                'package_type': booking.mini_move_package.package_type,
                'description': booking.mini_move_package.description,
                'max_items': booking.mini_move_package.max_items,
                'max_weight_per_item_lbs': booking.mini_move_package.max_weight_per_item_lbs,
                'coi_included': booking.mini_move_package.coi_included,
                'priority_scheduling': booking.mini_move_package.priority_scheduling,
                'protective_wrapping': booking.mini_move_package.protective_wrapping,
                'base_price_dollars': booking.mini_move_package.base_price_dollars,
            }
            
            # Organizing services
            if booking.include_packing or booking.include_unpacking:
                organizing_data = {
                    'include_packing': booking.include_packing,
                    'include_unpacking': booking.include_unpacking,
                }
                
                tier = booking.mini_move_package.package_type
                
                if booking.include_packing:
                    packing_service = OrganizingService.objects.filter(
                        mini_move_tier=tier,
                        is_packing_service=True,
                        is_active=True
                    ).first()
                    if packing_service:
                        organizing_data['packing_service'] = {
                            'name': packing_service.name,
                            'price_dollars': packing_service.price_dollars,
                            'duration_hours': packing_service.duration_hours,
                            'organizer_count': packing_service.organizer_count,
                            'supplies_allowance': packing_service.supplies_allowance_dollars,
                        }
                
                if booking.include_unpacking:
                    unpacking_service = OrganizingService.objects.filter(
                        mini_move_tier=tier,
                        is_packing_service=False,
                        is_active=True
                    ).first()
                    if unpacking_service:
                        organizing_data['unpacking_service'] = {
                            'name': unpacking_service.name,
                            'price_dollars': unpacking_service.price_dollars,
                            'duration_hours': unpacking_service.duration_hours,
                            'organizer_count': unpacking_service.organizer_count,
                            'supplies_allowance': unpacking_service.supplies_allowance_dollars,
                        }
                
                details['organizing_services'] = organizing_data
        
        # Specialty Item details
        elif booking.service_type == 'specialty_item' and booking.specialty_items.exists():
            details['specialty_items'] = [
                {
                    'id': str(item.id),
                    'name': item.name,
                    'item_type': item.item_type,
                    'description': item.description,
                    'price_dollars': item.price_dollars,
                    'special_handling': item.special_handling
                }
                for item in booking.specialty_items.all()
            ]
        
        # Standard Delivery details
        elif booking.service_type == 'standard_delivery':
            details['standard_delivery'] = {
                'item_count': booking.standard_delivery_item_count or 0,
                'is_same_day': booking.is_same_day_delivery,
            }
            # Include specialty items if any
            if booking.specialty_items.exists():
                details['specialty_items'] = [
                    {
                        'id': str(item.id),
                        'name': item.name,
                        'price_dollars': item.price_dollars,
                    }
                    for item in booking.specialty_items.all()
                ]
        
        # BLADE Transfer details
        elif booking.service_type == 'blade_transfer':
            details['blade_transfer'] = {
                'airport': booking.blade_airport,
                'flight_date': booking.blade_flight_date,
                'flight_time': booking.blade_flight_time.strftime('%H:%M') if booking.blade_flight_time else None,
                'bag_count': booking.blade_bag_count,
                'ready_time': booking.blade_ready_time.strftime('%H:%M') if booking.blade_ready_time else None,
                'per_bag_price': 75,
            }
        
        return details
    
    def patch(self, request, booking_id):
        """Update booking status and details"""
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Not a staff account'}, status=status.HTTP_403_FORBIDDEN)
        
        try:
            booking = Booking.objects.get(id=booking_id, deleted_at__isnull=True)
        except Booking.DoesNotExist:
            return Response({'error': 'Booking not found'}, status=status.HTTP_404_NOT_FOUND)
        
        # Get update data
        new_status = request.data.get('status')
        staff_notes = request.data.get('staff_notes', '')
        
        old_status = booking.status
        
        # Update booking
        if new_status and new_status != old_status:
            booking.status = new_status
            booking.save()
            
            # Log status change
            StaffAction.log_action(
                staff_user=request.user,
                action_type='modify_booking',
                description=f'Changed booking {booking.booking_number} status from {old_status} to {new_status}. Notes: {staff_notes}',
                request=request,
                booking_id=booking.id
            )
        
        return Response({
            'message': 'Booking updated successfully',
            'booking': {
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'status': booking.status,
                'updated_at': booking.updated_at
            }
        })


@method_decorator(ensure_csrf_cookie, name='dispatch')
class StaffCSRFTokenView(APIView):
    """Get CSRF token for staff - ensures cookie is set"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Staff access required'}, status=status.HTTP_403_FORBIDDEN)
        
        return Response({
            'csrf_token': get_token(request)
        })
```

# ==== apps/bookings/__init__.py ====

```python

```

# ==== apps/bookings/admin.py ====

```python
from django.contrib import admin
from django.utils.html import format_html
from .models import Booking, Address, GuestCheckout, BookingSpecialtyItem
from django.utils import timezone
from django.contrib import messages


class BookingSpecialtyItemInline(admin.TabularInline):
    """Inline admin for specialty items with quantities"""
    model = BookingSpecialtyItem
    extra = 1
    fields = ('specialty_item', 'quantity', 'get_subtotal')
    readonly_fields = ('get_subtotal',)
    
    def get_subtotal(self, obj):
        if obj.id:
            return f"${obj.subtotal_dollars}"
        return "—"
    get_subtotal.short_description = 'Subtotal'


@admin.register(Booking)
class BookingAdmin(admin.ModelAdmin):
    list_display = (
        'booking_number', 
        'get_customer_name', 
        'service_type', 
        'get_service_details',
        'get_organizing_services',
        'status', 
        'pickup_date', 
        'total_price_dollars',
        'visibility_status'
    )
    list_filter = (
        'service_type', 
        'status', 
        'pickup_date', 
        'coi_required', 
        'include_packing', 
        'include_unpacking',
        ('deleted_at', admin.EmptyFieldListFilter),
    )
    search_fields = ('booking_number', 'customer__email', 'guest_checkout__email')
    readonly_fields = (
        'booking_number', 'base_price_cents', 'surcharge_cents', 
        'coi_fee_cents', 'organizing_total_cents', 'total_price_cents', 
        'created_at', 'updated_at'
    )
    
    inlines = [BookingSpecialtyItemInline]
    
    fieldsets = (
        ('Customer Info', {
            'fields': ('customer', 'guest_checkout')
        }),
        ('Service Selection', {
            'fields': (
                'service_type', 
                'mini_move_package', 
                'standard_delivery_item_count',
                'is_same_day_delivery',
            )
        }),
        ('Organizing Services', {
            'fields': ('include_packing', 'include_unpacking'),
            'classes': ('wide',),
            'description': 'Professional packing and unpacking services (Mini Moves only)'
        }),
        ('Booking Details', {
            'fields': ('pickup_date', 'pickup_time', 'pickup_address', 'delivery_address')
        }),
        ('Requirements', {
            'fields': ('special_instructions', 'coi_required')
        }),
        ('Calculated Pricing', {
            'fields': ('base_price_cents', 'surcharge_cents', 'coi_fee_cents', 'organizing_total_cents', 'total_price_cents'),
            'classes': ('collapse',)
        }),
        ('Status', {
            'fields': ('status',)
        }),
        ('System Info', {
            'fields': ('booking_number', 'created_at', 'updated_at'),
            'classes': ('collapse',)
        })
    )
    
    actions = ['soft_delete_selected', 'restore_selected']
    
    def get_queryset(self, request):
        """Show all bookings when filter is used, otherwise show only active ones"""
        qs = super().get_queryset(request)
        return qs
        # If user is specifically filtering by deleted_at, show all results
     #   if 'deleted_at__isnull' in request.GET:
      #      return qs  # Let the filter handle it
        # Otherwise only show active bookings by default
       # return qs.filter(deleted_at__isnull=True)
    
    def get_customer_name(self, obj):
        return obj.get_customer_name()
    get_customer_name.short_description = 'Customer'
    
    def get_service_details(self, obj):
        if obj.service_type == 'mini_move' and obj.mini_move_package:
            return obj.mini_move_package.name
        elif obj.service_type == 'standard_delivery' and obj.standard_delivery_item_count:
            return f"{obj.standard_delivery_item_count} items"
        elif obj.service_type == 'specialty_item':
            booking_items = obj.bookingspecialtyitem_set.all()
            items_list = [f"{bi.quantity}x {bi.specialty_item.name}" for bi in booking_items[:2]]
            return ", ".join(items_list) + ("..." if len(booking_items) > 2 else "")
        return "Not configured"
    get_service_details.short_description = 'Service Details'
    
    def get_organizing_services(self, obj):
        """Show organizing services for this booking"""
        if obj.service_type != 'mini_move':
            return "—"
        
        services = []
        if obj.include_packing:
            services.append("📦 Packing")
        if obj.include_unpacking:
            services.append("📤 Unpacking")
        
        if services:
            services_text = " + ".join(services)
            return format_html(
                '<span style="color: #059669; font-weight: bold;">{}</span><br>'
                '<small style="color: #6b7280;">${}</small>',
                services_text,
                obj.organizing_total_dollars
            )
        return format_html('<span style="color: #9ca3af;">None</span>')
    get_organizing_services.short_description = 'Organizing Services'
    
    def visibility_status(self, obj):
        """Show if booking is visible in staff dashboard"""
        if obj.deleted_at:
            return format_html('<span style="color: red;">🙈 Hidden</span>')
        return format_html('<span style="color: green;">👁️ Visible</span>')
    visibility_status.short_description = 'Dashboard Status'
    
    def soft_delete_selected(self, request, queryset):
        count = queryset.filter(deleted_at__isnull=True).update(deleted_at=timezone.now())
        self.message_user(request, f'Hidden {count} bookings from staff dashboard')
    soft_delete_selected.short_description = "Hide selected bookings from dashboard"
    
    def restore_selected(self, request, queryset):
        count = queryset.filter(deleted_at__isnull=False).update(deleted_at=None)
        self.message_user(request, f'Restored {count} bookings to dashboard')
    restore_selected.short_description = "Restore hidden bookings"


@admin.register(Address)
class AddressAdmin(admin.ModelAdmin):
    list_display = ('address_line_1', 'city', 'state', 'customer', 'created_at')
    list_filter = ('state', 'city')
    search_fields = ('address_line_1', 'city', 'customer__email')


@admin.register(GuestCheckout)
class GuestCheckoutAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', 'email', 'phone', 'created_at')
    search_fields = ('first_name', 'last_name', 'email')
    readonly_fields = ('created_at',)
```

# ==== apps/bookings/apps.py ====

```python
from django.apps import AppConfig


class BookingsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.bookings'

    def ready(self):
        # Ensure signal handlers are registered
        import apps.bookings.signals  # noqa: F401
```

# ==== apps/bookings/management/__init__.py ====

```python

```

# ==== apps/bookings/management/commands/__init__.py ====

```python

```

# ==== apps/bookings/management/commands/wipe_all_bookings.py ====

```python
from django.core.management.base import BaseCommand
from django.db import transaction
from django.contrib.auth.models import User
from apps.bookings.models import Booking, Address, GuestCheckout
from apps.payments.models import Payment, Refund, PaymentAudit
from apps.logistics.models import OnfleetTask
from apps.customers.models import CustomerProfile

class Command(BaseCommand):
    help = 'PRODUCTION: Wipe ALL bookings (customer + guest) and related data'
    
    def add_arguments(self, parser):
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='Show what would be deleted without actually deleting'
        )
        parser.add_argument(
            '--yes-i-am-sure',
            action='store_true',
            help='Required confirmation flag for production deletion'
        )
        parser.add_argument(
            '--keep-addresses',
            action='store_true',
            help='Keep Address records (only delete bookings/payments)'
        )
    
    def handle(self, *args, **options):
        dry_run = options['dry_run']
        confirmed = options['yes_i_am_sure']
        keep_addresses = options['keep_addresses']
        
        # Safety check
        if not confirmed and not dry_run:
            self.stdout.write(
                self.style.ERROR(
                    '\n❌ SAFETY CHECK FAILED\n'
                    'You must pass --yes-i-am-sure to delete production data\n'
                    'Example: python manage.py wipe_all_bookings --yes-i-am-sure\n'
                )
            )
            return
        
        # Display current counts
        self.stdout.write(self.style.WARNING('\n' + '='*60))
        self.stdout.write(self.style.WARNING('  PRODUCTION DATABASE WIPE - CURRENT STATE'))
        self.stdout.write(self.style.WARNING('='*60))
        
        counts = self._get_current_counts()
        self._display_counts(counts)
        
        # Display what will happen
        self.stdout.write('\n' + '='*60)
        self.stdout.write(self.style.WARNING('  DELETION PLAN'))
        self.stdout.write('='*60)
        self.stdout.write('\n📋 Order of deletion (respects PROTECT relationships):')
        self.stdout.write('   1. ❌ Payment Audits')
        self.stdout.write('   2. ❌ Refunds (PROTECT on Payment)')
        self.stdout.write('   3. ❌ Payments (PROTECT on Booking)')
        self.stdout.write('   4. ❌ Bookings (CASCADE to OnfleetTask, GuestCheckout)')
        if not keep_addresses:
            self.stdout.write('   5. ❌ Addresses')
        else:
            self.stdout.write('   5. ✅ Addresses (keeping per --keep-addresses)')
        self.stdout.write('\n✅ User accounts will be PRESERVED')
        self.stdout.write('✅ CustomerProfiles will be PRESERVED (stats will reset)')
        self.stdout.write('✅ Service catalog will be PRESERVED\n')
        
        if dry_run:
            self.stdout.write(
                self.style.WARNING('\n🔍 DRY RUN MODE - No data will be deleted\n')
            )
            return
        
        # Confirm one more time
        self.stdout.write(
            self.style.ERROR(
                f'\n⚠️  FINAL WARNING: About to delete {counts["bookings"]} bookings '
                f'and {counts["payments"]} payments from PRODUCTION!\n'
            )
        )
        
        # Perform deletion
        self.stdout.write(self.style.WARNING('\n🗑️  Starting deletion process...\n'))
        
        deleted_counts = {}
        
        try:
            with transaction.atomic():
                # Step 1: Delete PaymentAudits (no PROTECT, just CASCADE)
                deleted_counts['payment_audits'], _ = PaymentAudit.objects.all().delete()
                self.stdout.write(
                    self.style.SUCCESS(f'   ✅ Deleted {deleted_counts["payment_audits"]} payment audit records')
                )
                
                # Step 2: Delete Refunds (PROTECT on Payment, must go first)
                deleted_counts['refunds'], _ = Refund.objects.all().delete()
                self.stdout.write(
                    self.style.SUCCESS(f'   ✅ Deleted {deleted_counts["refunds"]} refunds')
                )
                
                # Step 3: Delete Payments (PROTECT on Booking, must go second)
                deleted_counts['payments'], _ = Payment.objects.all().delete()
                self.stdout.write(
                    self.style.SUCCESS(f'   ✅ Deleted {deleted_counts["payments"]} payments')
                )
                
                # Step 4: Delete Bookings (CASCADE deletes OnfleetTask + GuestCheckout)
                deleted_counts['bookings'], _ = Booking.objects.all().delete()
                self.stdout.write(
                    self.style.SUCCESS(
                        f'   ✅ Deleted {deleted_counts["bookings"]} bookings '
                        f'(auto-deleted OnfleetTasks + GuestCheckouts via CASCADE)'
                    )
                )
                
                # Step 5: Optionally delete Addresses
                if not keep_addresses:
                    deleted_counts['addresses'], _ = Address.objects.all().delete()
                    self.stdout.write(
                        self.style.SUCCESS(f'   ✅ Deleted {deleted_counts["addresses"]} addresses')
                    )
                else:
                    deleted_counts['addresses'] = 0
                    self.stdout.write(
                        self.style.WARNING(f'   ⏭️  Kept {counts["addresses"]} addresses (--keep-addresses flag)')
                    )
            
            # Success!
            self.stdout.write('\n' + '='*60)
            self.stdout.write(self.style.SUCCESS('  ✅ DELETION COMPLETED SUCCESSFULLY'))
            self.stdout.write('='*60)
            self._display_deleted_summary(deleted_counts, counts)
            
            # Reset customer stats
            self.stdout.write('\n📊 Resetting customer booking statistics...')
            reset_count = self._reset_customer_stats()
            self.stdout.write(
                self.style.SUCCESS(f'   ✅ Reset stats for {reset_count} customers\n')
            )
            
            # Final verification
            self.stdout.write('🔍 Verifying deletion...')
            final_counts = self._get_current_counts()
            if final_counts['bookings'] == 0 and final_counts['payments'] == 0:
                self.stdout.write(self.style.SUCCESS('   ✅ All bookings and payments removed'))
            else:
                self.stdout.write(
                    self.style.ERROR(
                        f'   ⚠️  Warning: {final_counts["bookings"]} bookings, '
                        f'{final_counts["payments"]} payments still remain'
                    )
                )
            
            self.stdout.write('\n' + '='*60)
            self.stdout.write(self.style.SUCCESS('  🎉 DATABASE WIPE COMPLETE'))
            self.stdout.write('='*60 + '\n')
            
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'\n❌ ERROR during deletion: {str(e)}\n')
            )
            raise
    
    def _get_current_counts(self):
        """Get current record counts"""
        return {
            'payment_audits': PaymentAudit.objects.count(),
            'refunds': Refund.objects.count(),
            'payments': Payment.objects.count(),
            'bookings': Booking.objects.count(),
            'customer_bookings': Booking.objects.filter(customer__isnull=False).count(),
            'guest_bookings': Booking.objects.filter(guest_checkout__isnull=False).count(),
            'onfleet_tasks': OnfleetTask.objects.count(),
            'guest_checkouts': GuestCheckout.objects.count(),
            'addresses': Address.objects.count(),
            'users': User.objects.count(),
            'customer_profiles': CustomerProfile.objects.count(),
        }
    
    def _display_counts(self, counts):
        """Display current database state"""
        self.stdout.write('\n📊 Current Database State:')
        self.stdout.write(f'   🗑️  TO DELETE:')
        self.stdout.write(f'      • Bookings: {counts["bookings"]} total')
        self.stdout.write(f'        ├─ Customer bookings: {counts["customer_bookings"]}')
        self.stdout.write(f'        └─ Guest bookings: {counts["guest_bookings"]}')
        self.stdout.write(f'      • Payments: {counts["payments"]}')
        self.stdout.write(f'      • Refunds: {counts["refunds"]}')
        self.stdout.write(f'      • Payment Audits: {counts["payment_audits"]}')
        self.stdout.write(f'      • OnfleetTasks: {counts["onfleet_tasks"]} (CASCADE)')
        self.stdout.write(f'      • GuestCheckouts: {counts["guest_checkouts"]} (CASCADE)')
        self.stdout.write(f'      • Addresses: {counts["addresses"]}')
        
        self.stdout.write(f'\n   ✅ WILL PRESERVE:')
        self.stdout.write(f'      • User accounts: {counts["users"]}')
        self.stdout.write(f'      • Customer profiles: {counts["customer_profiles"]}')
        self.stdout.write(f'      • Service catalog (MiniMovePackages, SpecialtyItems, etc.)')
    
    def _display_deleted_summary(self, deleted, original):
        """Display deletion summary"""
        self.stdout.write('\n📋 Deletion Summary:')
        self.stdout.write(f'   ❌ Payment Audits: {deleted["payment_audits"]}/{original["payment_audits"]}')
        self.stdout.write(f'   ❌ Refunds: {deleted["refunds"]}/{original["refunds"]}')
        self.stdout.write(f'   ❌ Payments: {deleted["payments"]}/{original["payments"]}')
        self.stdout.write(f'   ❌ Bookings: {deleted["bookings"]}/{original["bookings"]}')
        self.stdout.write(f'      ├─ Customer bookings: {original["customer_bookings"]}')
        self.stdout.write(f'      └─ Guest bookings: {original["guest_bookings"]}')
        self.stdout.write(f'   ❌ OnfleetTasks: {original["onfleet_tasks"]} (auto-deleted via CASCADE)')
        self.stdout.write(f'   ❌ GuestCheckouts: {original["guest_checkouts"]} (auto-deleted via CASCADE)')
        if deleted.get('addresses', 0) > 0:
            self.stdout.write(f'   ❌ Addresses: {deleted["addresses"]}/{original["addresses"]}')
        
        self.stdout.write(f'\n   ✅ Users preserved: {original["users"]}')
        self.stdout.write(f'   ✅ Customer profiles preserved: {original["customer_profiles"]}')
    
    def _reset_customer_stats(self):
        """Reset customer booking statistics to zero"""
        reset_count = 0
        for profile in CustomerProfile.objects.all():
            profile.total_bookings = 0
            profile.total_spent_cents = 0
            profile.last_booking_at = None
            profile.save()
            reset_count += 1
        return reset_count
```

# ==== apps/bookings/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.5 on 2025-09-02 20:54

import django.core.validators
import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('services', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='GuestCheckout',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('first_name', models.CharField(max_length=100)),
                ('last_name', models.CharField(max_length=100)),
                ('email', models.EmailField(max_length=254)),
                ('phone', models.CharField(max_length=20, validators=[django.core.validators.RegexValidator(regex='^\\+?1?\\d{9,15}$')])),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'db_table': 'bookings_guest_checkout',
            },
        ),
        migrations.CreateModel(
            name='Address',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('address_line_1', models.CharField(max_length=200)),
                ('address_line_2', models.CharField(blank=True, max_length=200)),
                ('city', models.CharField(max_length=100)),
                ('state', models.CharField(choices=[('NY', 'New York'), ('CT', 'Connecticut'), ('NJ', 'New Jersey')], max_length=2)),
                ('zip_code', models.CharField(max_length=10)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('customer', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='booking_addresses', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'bookings_address',
            },
        ),
        migrations.CreateModel(
            name='Booking',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('booking_number', models.CharField(blank=True, max_length=20, unique=True)),
                ('service_type', models.CharField(choices=[('mini_move', 'Mini Move'), ('standard_delivery', 'Standard Delivery'), ('specialty_item', 'Specialty Item')], max_length=20)),
                ('standard_delivery_item_count', models.PositiveIntegerField(blank=True, help_text='Number of items for standard delivery', null=True)),
                ('is_same_day_delivery', models.BooleanField(default=False, help_text='Same-day delivery (flat $360 rate)')),
                ('pickup_date', models.DateField()),
                ('pickup_time', models.CharField(choices=[('morning', '8 AM - 11 AM'), ('afternoon', '12 PM - 3 PM'), ('evening', '4 PM - 7 PM')], default='morning', max_length=20)),
                ('special_instructions', models.TextField(blank=True)),
                ('coi_required', models.BooleanField(default=False)),
                ('base_price_cents', models.PositiveBigIntegerField(default=0)),
                ('surcharge_cents', models.PositiveBigIntegerField(default=0)),
                ('coi_fee_cents', models.PositiveBigIntegerField(default=0)),
                ('total_price_cents', models.PositiveBigIntegerField(default=0)),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('confirmed', 'Confirmed'), ('paid', 'Paid'), ('completed', 'Completed'), ('cancelled', 'Cancelled')], default='pending', max_length=20)),
                ('deleted_at', models.DateTimeField(blank=True, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('customer', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='bookings', to=settings.AUTH_USER_MODEL)),
                ('delivery_address', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='delivery_bookings', to='bookings.address')),
                ('mini_move_package', models.ForeignKey(blank=True, help_text='Selected mini move package (Petite/Standard/Full)', null=True, on_delete=django.db.models.deletion.PROTECT, to='services.minimovepackage')),
                ('pickup_address', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='pickup_bookings', to='bookings.address')),
                ('specialty_items', models.ManyToManyField(blank=True, help_text='Selected specialty items (Peloton, Surfboard, etc.)', to='services.specialtyitem')),
                ('guest_checkout', models.OneToOneField(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='booking', to='bookings.guestcheckout')),
            ],
            options={
                'db_table': 'bookings_booking',
                'constraints': [models.CheckConstraint(condition=models.Q(models.Q(('customer__isnull', False), ('guest_checkout__isnull', True)), models.Q(('customer__isnull', True), ('guest_checkout__isnull', False)), _connector='OR'), name='booking_exactly_one_customer_type')],
            },
        ),
    ]
```

# ==== apps/bookings/migrations/0002_booking_include_packing_booking_include_unpacking_and_more.py ====

```python
# Generated by Django 5.2.5 on 2025-09-08 21:42

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('bookings', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='booking',
            name='include_packing',
            field=models.BooleanField(default=False, help_text='Include professional packing service for this Mini Move tier'),
        ),
        migrations.AddField(
            model_name='booking',
            name='include_unpacking',
            field=models.BooleanField(default=False, help_text='Include professional unpacking service for this Mini Move tier'),
        ),
        migrations.AddField(
            model_name='booking',
            name='organizing_total_cents',
            field=models.PositiveBigIntegerField(default=0, help_text='Total cost for packing and unpacking services'),
        ),
    ]
```

# ==== apps/bookings/migrations/0003_booking_geographic_surcharge_cents_and_more.py ====

```python
# Generated by Django 5.2.5 on 2025-09-19 23:12

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('bookings', '0002_booking_include_packing_booking_include_unpacking_and_more'),
    ]

    operations = [
        migrations.AddField(
            model_name='booking',
            name='geographic_surcharge_cents',
            field=models.PositiveBigIntegerField(default=0, help_text='$175 surcharge for 30+ miles from Manhattan'),
        ),
        migrations.AddField(
            model_name='booking',
            name='is_outside_core_area',
            field=models.BooleanField(default=False, help_text='True if pickup/delivery is 30+ miles from Manhattan'),
        ),
        migrations.AddField(
            model_name='booking',
            name='organizing_tax_cents',
            field=models.PositiveBigIntegerField(default=0, help_text='Tax on organizing services'),
        ),
        migrations.AddField(
            model_name='booking',
            name='specific_pickup_hour',
            field=models.PositiveSmallIntegerField(blank=True, choices=[(8, '8:00 AM - 9:00 AM'), (9, '9:00 AM - 10:00 AM'), (10, '10:00 AM - 11:00 AM')], help_text='Specific hour for 1-hour window pickup', null=True),
        ),
        migrations.AddField(
            model_name='booking',
            name='time_window_surcharge_cents',
            field=models.PositiveBigIntegerField(default=0, help_text='Surcharge for specific 1-hour window'),
        ),
        migrations.AlterField(
            model_name='booking',
            name='pickup_time',
            field=models.CharField(choices=[('morning', '8 AM - 11 AM'), ('morning_specific', 'Specific 1-hour window (surcharge applies)'), ('no_time_preference', 'No time preference (available for certain packages)')], default='morning', max_length=30),
        ),
    ]
```

# ==== apps/bookings/migrations/0004_booking_blade_airport_booking_blade_bag_count_and_more.py ====

```python
# Generated by Django 5.2.5 on 2025-10-02 21:07

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('bookings', '0003_booking_geographic_surcharge_cents_and_more'),
    ]

    operations = [
        migrations.AddField(
            model_name='booking',
            name='blade_airport',
            field=models.CharField(blank=True, choices=[('JFK', 'JFK International Airport'), ('EWR', 'Newark Liberty International Airport')], help_text='Destination airport for BLADE transfer', max_length=3, null=True),
        ),
        migrations.AddField(
            model_name='booking',
            name='blade_bag_count',
            field=models.PositiveIntegerField(blank=True, help_text='Number of bags for BLADE transfer (minimum 2)', null=True),
        ),
        migrations.AddField(
            model_name='booking',
            name='blade_flight_date',
            field=models.DateField(blank=True, help_text='Date of BLADE flight', null=True),
        ),
        migrations.AddField(
            model_name='booking',
            name='blade_flight_time',
            field=models.TimeField(blank=True, help_text='Time of BLADE flight departure', null=True),
        ),
        migrations.AddField(
            model_name='booking',
            name='blade_ready_time',
            field=models.TimeField(blank=True, help_text='Auto-calculated: when bags must be ready for pickup', null=True),
        ),
        migrations.AlterField(
            model_name='booking',
            name='service_type',
            field=models.CharField(choices=[('mini_move', 'Mini Move'), ('standard_delivery', 'Standard Delivery'), ('specialty_item', 'Specialty Item'), ('blade_transfer', 'BLADE Airport Transfer')], max_length=20),
        ),
    ]
```

# ==== apps/bookings/migrations/0005_booking_same_day_surcharge_cents.py ====

```python
# Generated by Django 5.2.5 on 2025-10-06 18:58

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('bookings', '0004_booking_blade_airport_booking_blade_bag_count_and_more'),
    ]

    operations = [
        migrations.AddField(
            model_name='booking',
            name='same_day_surcharge_cents',
            field=models.PositiveBigIntegerField(default=0, help_text='Same-day delivery surcharge ($360)'),
        ),
    ]
```

# ==== apps/bookings/migrations/0006_booking_reminder_sent_at.py ====

```python
# Generated by Django 5.2.5 on 2025-10-15 18:15

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('bookings', '0005_booking_same_day_surcharge_cents'),
    ]

    operations = [
        migrations.AddField(
            model_name='booking',
            name='reminder_sent_at',
            field=models.DateTimeField(blank=True, help_text='When 24hr reminder email was sent', null=True),
        ),
    ]
```

# ==== apps/bookings/migrations/0007_add_specialty_item_quantities.py ====

```python
# Generated manually to handle ManyToMany to Through conversion
from django.db import migrations, models
import django.db.models.deletion


def migrate_existing_specialty_items(apps, schema_editor):
    """Migrate existing specialty items to use quantities (default = 1)"""
    Booking = apps.get_model('bookings', 'Booking')
    BookingSpecialtyItem = apps.get_model('bookings', 'BookingSpecialtyItem')
    
    # Get the old M2M table name
    db_alias = schema_editor.connection.alias
    
    # For each booking with specialty items, create BookingSpecialtyItem records
    for booking in Booking.objects.using(db_alias).prefetch_related('specialty_items').all():
        for item in booking.specialty_items.all():
            BookingSpecialtyItem.objects.using(db_alias).create(
                booking=booking,
                specialty_item=item,
                quantity=1  # Default quantity for existing items
            )


class Migration(migrations.Migration):

    dependencies = [
        ('bookings', '0006_booking_reminder_sent_at'),  # ✅ FIXED!
        ('services', '0006_remove_specialtyitem_requires_van_schedule'),
    ]

    operations = [
        # Step 1: Create the through model
        migrations.CreateModel(
            name='BookingSpecialtyItem',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('quantity', models.PositiveIntegerField(default=1)),
                ('booking', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='bookings.booking')),
                ('specialty_item', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, to='services.specialtyitem')),
            ],
            options={
                'db_table': 'bookings_booking_specialty_item',
                'ordering': ['specialty_item__name'],
                'unique_together': {('booking', 'specialty_item')},
            },
        ),
        
        # Step 2: Migrate existing data
        migrations.RunPython(
            code=migrate_existing_specialty_items,
            reverse_code=migrations.RunPython.noop,
        ),
        
        # Step 3: Remove old M2M field
        migrations.RemoveField(
            model_name='booking',
            name='specialty_items',
        ),
        
        # Step 4: Add new M2M field with through model
        migrations.AddField(
            model_name='booking',
            name='specialty_items',
            field=models.ManyToManyField(
                blank=True,
                help_text='Selected specialty items with quantities',
                through='bookings.BookingSpecialtyItem',
                to='services.specialtyitem'
            ),
        ),
    ]
```

# ==== apps/bookings/migrations/0008_address_bookings_ad_custome_ebf57e_idx_and_more.py ====

```python
# Generated by Django 5.2.5 on 2025-10-20 18:25

from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('bookings', '0007_add_specialty_item_quantities'),
        ('services', '0007_remove_specialty_item_choices'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AddIndex(
            model_name='address',
            index=models.Index(fields=['customer'], name='bookings_ad_custome_ebf57e_idx'),
        ),
        migrations.AddIndex(
            model_name='address',
            index=models.Index(fields=['zip_code'], name='bookings_ad_zip_cod_e9e007_idx'),
        ),
        migrations.AddIndex(
            model_name='booking',
            index=models.Index(fields=['booking_number'], name='bookings_booking_number_idx'),
        ),
        migrations.AddIndex(
            model_name='booking',
            index=models.Index(fields=['pickup_date', 'status'], name='bookings_pickup_status_idx'),
        ),
        migrations.AddIndex(
            model_name='booking',
            index=models.Index(fields=['customer', 'created_at'], name='bookings_customer_created_idx'),
        ),
        migrations.AddIndex(
            model_name='booking',
            index=models.Index(fields=['status', 'pickup_date'], name='bookings_status_pickup_idx'),
        ),
        migrations.AddIndex(
            model_name='booking',
            index=models.Index(fields=['created_at'], name='bookings_created_idx'),
        ),
        migrations.AddIndex(
            model_name='booking',
            index=models.Index(fields=['service_type'], name='bookings_service_type_idx'),
        ),
        migrations.AddIndex(
            model_name='guestcheckout',
            index=models.Index(fields=['email'], name='bookings_gu_email_c611ad_idx'),
        ),
    ]
```

# ==== apps/bookings/migrations/__init__.py ====

```python

```

# ==== apps/bookings/models.py ====

```python
# backend/apps/bookings/models.py
import uuid
from django.db import models
from django.utils import timezone
from django.contrib.auth.models import User
from django.core.validators import RegexValidator
from datetime import timedelta


class Address(models.Model):
    """Address for pickup/delivery - can be saved by customer or one-time"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    customer = models.ForeignKey(
        User, 
        on_delete=models.CASCADE, 
        null=True, 
        blank=True,
        related_name='booking_addresses'
    )
    
    address_line_1 = models.CharField(max_length=200)
    address_line_2 = models.CharField(max_length=200, blank=True)
    city = models.CharField(max_length=100)
    state = models.CharField(max_length=2, choices=[
        ('NY', 'New York'),
        ('CT', 'Connecticut'), 
        ('NJ', 'New Jersey'),
    ])
    zip_code = models.CharField(max_length=10)
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'bookings_address'
        indexes = [
            models.Index(fields=['customer']),
            models.Index(fields=['zip_code']),
        ]
    
    def __str__(self):
        return f"{self.address_line_1}, {self.city}, {self.state} {self.zip_code}"


class GuestCheckout(models.Model):
    """Guest customer info for non-authenticated bookings"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    email = models.EmailField()
    phone = models.CharField(
        max_length=20, 
        validators=[RegexValidator(regex=r'^\+?1?\d{9,15}$')]
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'bookings_guest_checkout'
        indexes = [
            models.Index(fields=['email']),
        ]
    
    def __str__(self):
        return f"{self.first_name} {self.last_name} ({self.email})"


class BookingSpecialtyItem(models.Model):
    """Through model to track quantity of each specialty item per booking"""
    booking = models.ForeignKey('Booking', on_delete=models.CASCADE)
    specialty_item = models.ForeignKey('services.SpecialtyItem', on_delete=models.PROTECT)
    quantity = models.PositiveIntegerField(default=1)
    
    class Meta:
        db_table = 'bookings_booking_specialty_item'
        unique_together = ('booking', 'specialty_item')
        ordering = ['specialty_item__name']
    
    def __str__(self):
        return f"{self.booking.booking_number} - {self.quantity}x {self.specialty_item.name}"
    
    @property
    def subtotal_cents(self):
        return self.specialty_item.price_cents * self.quantity
    
    @property
    def subtotal_dollars(self):
        return self.subtotal_cents / 100


class Booking(models.Model):
    """Core booking - works with customer OR guest checkout - WITH SERVICES INTEGRATION + BLADE"""
    
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('confirmed', 'Confirmed'),
        ('paid', 'Paid'),
        ('completed', 'Completed'),
        ('cancelled', 'Cancelled'),
    ]
    
    SERVICE_TYPE_CHOICES = [
        ('mini_move', 'Mini Move'),
        ('standard_delivery', 'Standard Delivery'),
        ('specialty_item', 'Specialty Item'),
        ('blade_transfer', 'BLADE Airport Transfer'),
    ]
    
    PICKUP_TIME_CHOICES = [
        ('morning', '8 AM - 11 AM'),
        ('morning_specific', 'Specific 1-hour window (surcharge applies)'),
        ('no_time_preference', 'No time preference (available for certain packages)'),
    ]
    
    BLADE_AIRPORT_CHOICES = [
        ('JFK', 'JFK International Airport'),
        ('EWR', 'Newark Liberty International Airport'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    booking_number = models.CharField(max_length=20, unique=True, blank=True)
    
    customer = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name='bookings'
    )
    guest_checkout = models.OneToOneField(
        GuestCheckout,
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name='booking'
    )
    
    service_type = models.CharField(max_length=20, choices=SERVICE_TYPE_CHOICES)
    
    # Mini Move fields
    mini_move_package = models.ForeignKey(
        'services.MiniMovePackage',
        on_delete=models.PROTECT,
        null=True,
        blank=True,
        help_text="Selected mini move package (Petite/Standard/Full)"
    )
    include_packing = models.BooleanField(
        default=False,
        help_text="Include professional packing service for this Mini Move tier"
    )
    include_unpacking = models.BooleanField(
        default=False,
        help_text="Include professional unpacking service for this Mini Move tier"
    )
    
    # Standard Delivery fields
    standard_delivery_item_count = models.PositiveIntegerField(
        null=True,
        blank=True,
        help_text="Number of items for standard delivery"
    )
    is_same_day_delivery = models.BooleanField(
        default=False,
        help_text="Same-day delivery (flat $360 rate)"
    )
    specialty_items = models.ManyToManyField(
        'services.SpecialtyItem',
        through='BookingSpecialtyItem',
        blank=True,
        help_text="Selected specialty items with quantities"
    )
    
    # BLADE Airport Transfer fields
    blade_airport = models.CharField(
        max_length=3,
        choices=BLADE_AIRPORT_CHOICES,
        null=True,
        blank=True,
        help_text="Destination airport for BLADE transfer"
    )
    blade_flight_date = models.DateField(
        null=True, 
        blank=True,
        help_text="Date of BLADE flight"
    )
    blade_flight_time = models.TimeField(
        null=True, 
        blank=True,
        help_text="Time of BLADE flight departure"
    )
    blade_bag_count = models.PositiveIntegerField(
        null=True, 
        blank=True,
        help_text="Number of bags for BLADE transfer (minimum 2)"
    )
    blade_ready_time = models.TimeField(
        null=True, 
        blank=True,
        help_text="Auto-calculated: when bags must be ready for pickup"
    )
    
    # Address and scheduling
    pickup_address = models.ForeignKey(
        Address, 
        on_delete=models.PROTECT, 
        related_name='pickup_bookings'
    )
    delivery_address = models.ForeignKey(
        Address, 
        on_delete=models.PROTECT, 
        related_name='delivery_bookings'
    )
    
    pickup_date = models.DateField()
    pickup_time = models.CharField(
        max_length=30,
        choices=PICKUP_TIME_CHOICES,
        default='morning'
    )
    
    specific_pickup_hour = models.PositiveSmallIntegerField(
        null=True,
        blank=True,
        choices=[
            (8, '8:00 AM - 9:00 AM'),
            (9, '9:00 AM - 10:00 AM'),
            (10, '10:00 AM - 11:00 AM'),
        ],
        help_text="Specific hour for 1-hour window pickup"
    )
    
    special_instructions = models.TextField(blank=True)
    coi_required = models.BooleanField(default=False)
    
    is_outside_core_area = models.BooleanField(
        default=False,
        help_text="True if pickup/delivery is 30+ miles from Manhattan"
    )
    
    # Pricing fields
    base_price_cents = models.PositiveBigIntegerField(default=0)
    surcharge_cents = models.PositiveBigIntegerField(default=0)
    same_day_surcharge_cents = models.PositiveBigIntegerField(
        default=0,
        help_text="Same-day delivery surcharge ($360)"
    )
    coi_fee_cents = models.PositiveBigIntegerField(default=0)
    organizing_total_cents = models.PositiveBigIntegerField(
        default=0,
        help_text="Total cost for packing and unpacking services"
    )
    geographic_surcharge_cents = models.PositiveBigIntegerField(
        default=0,
        help_text="$175 surcharge for 30+ miles from Manhattan"
    )
    time_window_surcharge_cents = models.PositiveBigIntegerField(
        default=0,
        help_text="Surcharge for specific 1-hour window"
    )
    organizing_tax_cents = models.PositiveBigIntegerField(
        default=0,
        help_text="Tax on organizing services"
    )
    total_price_cents = models.PositiveBigIntegerField(default=0)
    
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    
    deleted_at = models.DateTimeField(null=True, blank=True)
    reminder_sent_at = models.DateTimeField(null=True, blank=True, help_text='When 24hr reminder email was sent')

    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'bookings_booking'
        constraints = [
            models.CheckConstraint(
                check=(
                    models.Q(customer__isnull=False, guest_checkout__isnull=True) |
                    models.Q(customer__isnull=True, guest_checkout__isnull=False)
                ),
                name='booking_exactly_one_customer_type'
            )
        ]
        # ✅ OPTIMIZED: Added indexes for common queries
        indexes = [
            models.Index(fields=['booking_number'], name='bookings_booking_number_idx'),
            models.Index(fields=['pickup_date', 'status'], name='bookings_pickup_status_idx'),
            models.Index(fields=['customer', 'created_at'], name='bookings_customer_created_idx'),
            models.Index(fields=['status', 'pickup_date'], name='bookings_status_pickup_idx'),
            models.Index(fields=['created_at'], name='bookings_created_idx'),
            models.Index(fields=['service_type'], name='bookings_service_type_idx'),
        ]
    
    def save(self, *args, **kwargs):
        # Generate booking number if new
        if not self.booking_number:
            last_booking = Booking.objects.order_by('created_at').last()
            if last_booking and last_booking.booking_number:
                last_num = int(last_booking.booking_number.split('-')[1])
                next_num = last_num + 1
            else:
                next_num = 1
            self.booking_number = f"TT-{next_num:06d}"
        
        # ========== AUTO-SET GEOGRAPHIC SURCHARGE (NEW) ==========
        if self.pickup_address and self.delivery_address:
            from .zip_codes import validate_service_area
            
            # Validate pickup ZIP
            pickup_valid, pickup_surcharge, _, _ = validate_service_area(
                self.pickup_address.zip_code
            )
            
            # Validate delivery ZIP
            delivery_valid, delivery_surcharge, _, _ = validate_service_area(
                self.delivery_address.zip_code
            )
            
            # Apply surcharge if EITHER address is in surcharge zone
            self.is_outside_core_area = pickup_surcharge or delivery_surcharge
        # ========== END AUTO-SET GEOGRAPHIC SURCHARGE ==========
        
        
        self.calculate_pricing()
        super().save(*args, **kwargs)
    
    def __str__(self):
        customer_name = self.get_customer_name()
        return f"{self.booking_number} - {customer_name} - ${self.total_price_dollars}"
    
    def get_customer_name(self):
        if self.customer:
            return self.customer.get_full_name()
        elif self.guest_checkout:
            return f"{self.guest_checkout.first_name} {self.guest_checkout.last_name}"
        return "Unknown"
    
    def get_customer_email(self):
        if self.customer:
            return self.customer.email
        elif self.guest_checkout:
            return self.guest_checkout.email
        return None
    
    @property
    def total_price_dollars(self):
        return self.total_price_cents / 100
    
    @property
    def base_price_dollars(self):
        return self.base_price_cents / 100
    
    @property
    def surcharge_dollars(self):
        return self.surcharge_cents / 100
    
    @property
    def same_day_surcharge_dollars(self):
        return self.same_day_surcharge_cents / 100
    
    @property
    def coi_fee_dollars(self):
        return self.coi_fee_cents / 100
    
    @property
    def organizing_total_dollars(self):
        return self.organizing_total_cents / 100
    
    @property
    def geographic_surcharge_dollars(self):
        return self.geographic_surcharge_cents / 100
    
    @property
    def time_window_surcharge_dollars(self):
        return self.time_window_surcharge_cents / 100
    
    @property
    def organizing_tax_dollars(self):
        return self.organizing_tax_cents / 100
            
    def get_pickup_time_display(self):
        """
        Override Django's auto-generated method to include specific hour.
        Returns formatted pickup time with actual hour window when applicable.
        """
        if self.pickup_time == 'morning_specific' and self.specific_pickup_hour is not None:
            start = self.specific_pickup_hour
            end = start + 1
            
            # Format hours (handle 12 PM properly)
            def format_hour(h):
                if h == 12:
                    return "12:00 PM"
                elif h > 12:
                    return f"{h - 12}:00 PM"
                else:
                    return f"{h}:00 AM"
            
            return f"{format_hour(start)} - {format_hour(end)} (1-hour window)"
        
        # Use Django's default display for other choices
        return dict(self.PICKUP_TIME_CHOICES).get(self.pickup_time, self.pickup_time)
    
    
    def calculate_blade_ready_time(self):
        """Calculate BLADE ready time based on flight time"""
        if self.service_type == 'blade_transfer' and self.blade_flight_time:
            from datetime import time
            if self.blade_flight_time < time(13, 0):
                self.blade_ready_time = time(5, 0)
            else:
                self.blade_ready_time = time(10, 0)
    
    def calculate_organizing_costs(self):
        """Calculate organizing service costs based on Mini Move tier"""
        if self.service_type != 'mini_move' or not self.mini_move_package:
            return 0
        
        from apps.services.models import OrganizingService
        
        total_organizing_cents = 0
        tier = self.mini_move_package.package_type
        
        if self.include_packing:
            try:
                packing_service = OrganizingService.objects.get(
                    mini_move_tier=tier,
                    is_packing_service=True,
                    is_active=True
                )
                total_organizing_cents += packing_service.price_cents
            except OrganizingService.DoesNotExist:
                pass
        
        if self.include_unpacking:
            try:
                unpacking_service = OrganizingService.objects.get(
                    mini_move_tier=tier,
                    is_packing_service=False,
                    is_active=True
                )
                total_organizing_cents += unpacking_service.price_cents
            except OrganizingService.DoesNotExist:
                pass
        
        return total_organizing_cents
    
    def calculate_coi_fee(self):
        """Calculate COI fee - $50 for Standard Delivery, Specialty Items, and Petite Mini Moves"""
        if not self.coi_required:
            return 0
        
        # ✅ FIX: $50 COI fee for Standard Delivery and Specialty Items
        if self.service_type in ['standard_delivery', 'specialty_item']:
            return 5000
        
        # Mini Move COI logic
        if self.service_type == 'mini_move' and self.mini_move_package:
            if self.mini_move_package.package_type == 'petite':
                return 5000
            elif not self.mini_move_package.coi_included:
                return self.mini_move_package.coi_fee_cents
        
        return 0
    
    def calculate_geographic_surcharge(self):
        """Calculate $175 surcharge for 30+ miles from Manhattan"""
        if self.is_outside_core_area:
            return 17500
        return 0
    
    def calculate_time_window_surcharge(self):
        """Calculate $175 surcharge for 1-hour window selection"""
        if self.pickup_time == 'morning_specific':
            if self.service_type == 'mini_move' and self.mini_move_package:
                if self.mini_move_package.package_type == 'standard':
                    return 17500
                elif self.mini_move_package.package_type == 'full':
                    return 0
        return 0
    
    def calculate_organizing_tax(self):
        """Calculate tax on organizing services - 8.25%"""
        if self.organizing_total_cents > 0:
            return int(self.organizing_total_cents * 0.0825)
        return 0
    
    def calculate_pricing(self):
        """Calculate total pricing using services pricing engine + BLADE support"""
        from apps.services.models import StandardDeliveryConfig, SurchargeRule
        
        self.base_price_cents = 0
        self.surcharge_cents = 0
        self.same_day_surcharge_cents = 0
        self.coi_fee_cents = 0
        self.organizing_total_cents = 0
        self.geographic_surcharge_cents = 0
        self.time_window_surcharge_cents = 0
        self.organizing_tax_cents = 0
        
        # BLADE pricing
        if self.service_type == 'blade_transfer':
            if self.blade_bag_count:
                per_bag_price = 7500  # $75 per bag in cents
                self.base_price_cents = self.blade_bag_count * per_bag_price
                self.base_price_cents = max(self.base_price_cents, 15000)
            
            self.calculate_blade_ready_time()
        
        # Mini Move pricing
        elif self.service_type == 'mini_move' and self.mini_move_package:
            self.base_price_cents = self.mini_move_package.base_price_cents
            
            self.organizing_total_cents = self.calculate_organizing_costs()
            self.organizing_tax_cents = self.calculate_organizing_tax()
            self.coi_fee_cents = self.calculate_coi_fee()
            
            if self.pickup_date:
                active_surcharges = SurchargeRule.objects.filter(is_active=True)
                for surcharge in active_surcharges:
                    surcharge_amount = surcharge.calculate_surcharge(
                        self.base_price_cents, 
                        self.pickup_date,
                        self.service_type
                    )
                    self.surcharge_cents += surcharge_amount
            
            self.geographic_surcharge_cents = self.calculate_geographic_surcharge()
            self.time_window_surcharge_cents = self.calculate_time_window_surcharge()
        
        # Standard Delivery pricing
        elif self.service_type == 'standard_delivery':
            try:
                config = StandardDeliveryConfig.objects.filter(is_active=True).first()
                if config:
                    if self.standard_delivery_item_count and self.standard_delivery_item_count > 0:
                        item_total = config.price_per_item_cents * self.standard_delivery_item_count
                        self.base_price_cents = max(item_total, config.minimum_charge_cents)
                    else:
                        self.base_price_cents = 0
                    
                    if self.specialty_items.exists():
                        specialty_total = 0
                        for booking_item in self.bookingspecialtyitem_set.all():
                            specialty_total += booking_item.subtotal_cents
                        self.base_price_cents += specialty_total
                    
                    # Apply same-day delivery surcharge
                    if self.is_same_day_delivery:
                        self.same_day_surcharge_cents = config.same_day_flat_rate_cents
                    
            except StandardDeliveryConfig.DoesNotExist:
                pass
            
            # Weekend surcharges
            if self.pickup_date:
                active_surcharges = SurchargeRule.objects.filter(is_active=True)
                for surcharge in active_surcharges:
                    surcharge_amount = surcharge.calculate_surcharge(
                        self.base_price_cents, 
                        self.pickup_date,
                        self.service_type
                    )
                    self.surcharge_cents += surcharge_amount
            
            # ✅ FIX: Apply geographic surcharge and COI fee
            self.geographic_surcharge_cents = self.calculate_geographic_surcharge()
            self.coi_fee_cents = self.calculate_coi_fee()
        
        # Specialty Item pricing
        elif self.service_type == 'specialty_item':
            specialty_total = 0
            for booking_item in self.bookingspecialtyitem_set.all():
                specialty_total += booking_item.subtotal_cents
            self.base_price_cents = specialty_total
            
            # ✅ FIX: Apply same-day delivery surcharge for specialty items
            if self.is_same_day_delivery:
                try:
                    config = StandardDeliveryConfig.objects.filter(is_active=True).first()
                    if config:
                        self.same_day_surcharge_cents = config.same_day_flat_rate_cents
                except StandardDeliveryConfig.DoesNotExist:
                    pass
            
            # ✅ FIX: Apply weekend surcharges
            if self.pickup_date:
                active_surcharges = SurchargeRule.objects.filter(is_active=True)
                for surcharge in active_surcharges:
                    surcharge_amount = surcharge.calculate_surcharge(
                        self.base_price_cents, 
                        self.pickup_date,
                        self.service_type
                    )
                    self.surcharge_cents += surcharge_amount
            
            # ✅ FIX: Apply geographic surcharge and COI fee
            self.geographic_surcharge_cents = self.calculate_geographic_surcharge()
            self.coi_fee_cents = self.calculate_coi_fee()
        
        # Calculate total
        self.total_price_cents = (
            self.base_price_cents + 
            self.surcharge_cents + 
            self.same_day_surcharge_cents +
            self.coi_fee_cents + 
            self.organizing_total_cents +
            self.organizing_tax_cents +
            self.geographic_surcharge_cents +
            self.time_window_surcharge_cents
        )
    
    def get_pricing_breakdown(self):
        """Return detailed pricing breakdown for display"""
        breakdown = {
            'base_price_dollars': self.base_price_dollars,
            'surcharge_dollars': self.surcharge_dollars,
            'same_day_surcharge_dollars': self.same_day_surcharge_dollars,
            'coi_fee_dollars': self.coi_fee_dollars,
            'organizing_total_dollars': self.organizing_total_dollars,
            'organizing_tax_dollars': self.organizing_tax_dollars,
            'geographic_surcharge_dollars': self.geographic_surcharge_dollars,
            'time_window_surcharge_dollars': self.time_window_surcharge_dollars,
            'total_price_dollars': self.total_price_dollars,
            'service_type': self.get_service_type_display(),
        }
        
        if self.organizing_total_cents > 0:
            breakdown['organizing_services'] = self.get_organizing_services_breakdown()
        
        if self.service_type == 'blade_transfer':
            breakdown['blade_details'] = {
                'airport': self.blade_airport,
                'bag_count': self.blade_bag_count,
                'per_bag_price': 75,
                'flight_date': self.blade_flight_date.isoformat() if self.blade_flight_date else None,
                'flight_time': self.blade_flight_time.isoformat() if self.blade_flight_time else None,
                'ready_time': self.blade_ready_time.isoformat() if self.blade_ready_time else None,
            }
        
        return breakdown
    
    def get_organizing_services_breakdown(self):
        """Get detailed breakdown of organizing services"""
        if self.service_type != 'mini_move' or not self.mini_move_package:
            return {}
        
        from apps.services.models import OrganizingService
        
        services = []
        tier = self.mini_move_package.package_type
        
        if self.include_packing:
            try:
                packing_service = OrganizingService.objects.get(
                    mini_move_tier=tier,
                    is_packing_service=True,
                    is_active=True
                )
                services.append({
                    'name': packing_service.name,
                    'price_dollars': packing_service.price_dollars,
                    'duration_hours': packing_service.duration_hours,
                    'organizer_count': packing_service.organizer_count,
                    'supplies_allowance': packing_service.supplies_allowance_dollars
                })
            except OrganizingService.DoesNotExist:
                pass
        
        if self.include_unpacking:
            try:
                unpacking_service = OrganizingService.objects.get(
                    mini_move_tier=tier,
                    is_packing_service=False,
                    is_active=True
                )
                services.append({
                    'name': unpacking_service.name,
                    'price_dollars': unpacking_service.price_dollars,
                    'duration_hours': unpacking_service.duration_hours,
                    'organizer_count': unpacking_service.organizer_count,
                    'supplies_allowance': 0
                })
            except OrganizingService.DoesNotExist:
                pass
        
        return services
```

# ==== apps/bookings/serializers.py ====

```python
# backend/apps/bookings/serializers.py
from rest_framework import serializers
from django.contrib.auth.models import User
from django.utils import timezone
from datetime import timedelta, time as dt_time
from .models import Booking, Address, GuestCheckout, BookingSpecialtyItem
from apps.services.models import MiniMovePackage, SpecialtyItem, OrganizingService, StandardDeliveryConfig, SurchargeRule


class AddressSerializer(serializers.ModelSerializer):
    class Meta:
        model = Address
        fields = (
            'id', 'address_line_1', 'address_line_2', 
            'city', 'state', 'zip_code'
        )


class GuestCheckoutSerializer(serializers.ModelSerializer):
    class Meta:
        model = GuestCheckout
        fields = ('first_name', 'last_name', 'email', 'phone')


class OrganizingServiceDetailSerializer(serializers.ModelSerializer):
    """Detailed organizing service info for booking responses"""
    price_dollars = serializers.ReadOnlyField()
    supplies_allowance_dollars = serializers.ReadOnlyField()
    
    class Meta:
        model = OrganizingService
        fields = (
            'id', 'service_type', 'name', 'description',
            'price_dollars', 'duration_hours', 'organizer_count',
            'supplies_allowance_dollars', 'is_packing_service'
        )


class BookingSerializer(serializers.ModelSerializer):
    customer_name = serializers.SerializerMethodField()
    customer_email = serializers.SerializerMethodField()
    pickup_address = AddressSerializer(read_only=True)
    delivery_address = AddressSerializer(read_only=True)
    guest_checkout = GuestCheckoutSerializer(read_only=True)
    total_price_dollars = serializers.ReadOnlyField()
    organizing_total_dollars = serializers.ReadOnlyField()
    pricing_breakdown = serializers.SerializerMethodField()
    organizing_services_breakdown = serializers.SerializerMethodField()
    
    pickup_date = serializers.DateField(format='%Y-%m-%d')
    blade_flight_date = serializers.DateField(format='%Y-%m-%d', allow_null=True)
    
    class Meta:
        model = Booking
        fields = (
            'id', 'booking_number', 'customer_name', 'customer_email',
            'service_type', 'pickup_date', 'pickup_time', 'specific_pickup_hour', 'status',
            'pickup_address', 'delivery_address', 'guest_checkout',
            'special_instructions', 'coi_required', 'is_outside_core_area',
            'include_packing', 'include_unpacking',
            'blade_airport', 'blade_flight_date', 'blade_flight_time', 
            'blade_bag_count', 'blade_ready_time',
            'total_price_dollars', 'organizing_total_dollars',
            'pricing_breakdown', 'organizing_services_breakdown', 'created_at'
        )
    
    def get_customer_name(self, obj):
        return obj.get_customer_name()
    
    def get_customer_email(self, obj):
        return obj.get_customer_email()
    
    def get_pricing_breakdown(self, obj):
        return obj.get_pricing_breakdown()
    
    def get_organizing_services_breakdown(self, obj):
        return obj.get_organizing_services_breakdown()


class BookingStatusSerializer(serializers.ModelSerializer):
    customer_name = serializers.SerializerMethodField()
    pickup_address = AddressSerializer(read_only=True)
    delivery_address = AddressSerializer(read_only=True)
    total_price_dollars = serializers.ReadOnlyField()
    organizing_total_dollars = serializers.ReadOnlyField()
    
    pickup_date = serializers.DateField(format='%Y-%m-%d')
    blade_flight_date = serializers.DateField(format='%Y-%m-%d', allow_null=True)
    
    class Meta:
        model = Booking
        fields = (
            'booking_number', 'customer_name', 'service_type', 
            'pickup_date', 'pickup_time', 'specific_pickup_hour', 'status',
            'pickup_address', 'delivery_address',
            'include_packing', 'include_unpacking',
            'blade_airport', 'blade_flight_date', 'blade_flight_time', 
            'blade_bag_count', 'blade_ready_time',
            'total_price_dollars', 'organizing_total_dollars', 'created_at'
        )
    
    def get_customer_name(self, obj):
        return obj.get_customer_name()


class PricingPreviewSerializer(serializers.Serializer):
    service_type = serializers.ChoiceField(choices=[
        ('mini_move', 'Mini Move'),
        ('standard_delivery', 'Standard Delivery'),
        ('specialty_item', 'Specialty Item'),
        ('blade_transfer', 'BLADE Airport Transfer'),
    ])
    pickup_date = serializers.DateField()
    
    # Mini Move fields
    mini_move_package_id = serializers.UUIDField(required=False)
    coi_required = serializers.BooleanField(required=False, default=False)
    include_packing = serializers.BooleanField(required=False, default=False)
    include_unpacking = serializers.BooleanField(required=False, default=False)
    
    pickup_time = serializers.ChoiceField(
        choices=[
            ('morning', '8 AM - 11 AM'),
            ('morning_specific', 'Specific 1-hour window'),
            ('no_time_preference', 'No time preference'),
        ],
        required=False,
        default='morning'
    )
    specific_pickup_hour = serializers.IntegerField(required=False, min_value=8, max_value=10)
    is_outside_core_area = serializers.BooleanField(required=False, default=False)
    
    # Standard Delivery fields
    standard_delivery_item_count = serializers.IntegerField(required=False, min_value=0)
    is_same_day_delivery = serializers.BooleanField(required=False, default=False)
    
    specialty_items = serializers.ListField(
        child=serializers.DictField(),
        required=False,
        allow_empty=True,
        help_text="List of {item_id: UUID, quantity: int}"
    )
    
    # BLADE fields
    blade_airport = serializers.ChoiceField(
        choices=[('JFK', 'JFK'), ('EWR', 'EWR')],
        required=False
    )
    blade_flight_date = serializers.DateField(required=False)
    blade_flight_time = serializers.TimeField(required=False)
    blade_bag_count = serializers.IntegerField(required=False, min_value=2)
    
    def validate_specialty_items(self, value):
        """Validate specialty items list with quantities"""
        if not value:
            return []
        
        for item in value:
            if 'item_id' not in item or 'quantity' not in item:
                raise serializers.ValidationError(
                    "Each specialty item must have 'item_id' and 'quantity'"
                )
            if item['quantity'] < 1:
                raise serializers.ValidationError("Quantity must be at least 1")
        
        return value
    
    def validate(self, attrs):
        service_type = attrs.get('service_type')
        
        # BLADE validation
        if service_type == 'blade_transfer':
            if not attrs.get('blade_airport'):
                raise serializers.ValidationError({'blade_airport': 'Airport selection required'})
            if not attrs.get('blade_flight_date'):
                raise serializers.ValidationError({'blade_flight_date': 'Flight date required'})
            if not attrs.get('blade_flight_time'):
                raise serializers.ValidationError({'blade_flight_time': 'Flight time required'})
            if not attrs.get('blade_bag_count'):
                raise serializers.ValidationError({'blade_bag_count': 'Bag count required'})
            
            if attrs.get('blade_bag_count', 0) < 2:
                raise serializers.ValidationError({'blade_bag_count': 'Minimum 2 bags'})
        
        # Standard Delivery validation
        elif service_type == 'standard_delivery':
            item_count = attrs.get('standard_delivery_item_count', 0)
            specialty_items = attrs.get('specialty_items', [])
            
            if item_count == 0 and len(specialty_items) == 0:
                raise serializers.ValidationError({
                    'standard_delivery': 'At least one item required'
                })
        
        return attrs


class GuestPaymentIntentSerializer(serializers.Serializer):
    """
    Serializer for creating payment intent BEFORE guest booking
    ✅ NOW SUPPORTS QUANTITIES
    """
    
    # Guest customer info
    first_name = serializers.CharField(max_length=100)
    last_name = serializers.CharField(max_length=100)
    email = serializers.EmailField()
    phone = serializers.CharField(max_length=20)
    
    service_type = serializers.ChoiceField(choices=[
        ('mini_move', 'Mini Move'),
        ('standard_delivery', 'Standard Delivery'),
        ('specialty_item', 'Specialty Item'),
        ('blade_transfer', 'BLADE Airport Transfer'),
    ])
    
    # Service-specific fields
    mini_move_package_id = serializers.UUIDField(required=False, allow_null=True)
    include_packing = serializers.BooleanField(default=False)
    include_unpacking = serializers.BooleanField(default=False)
    standard_delivery_item_count = serializers.IntegerField(required=False, min_value=0)
    is_same_day_delivery = serializers.BooleanField(default=False)
    
    specialty_items = serializers.ListField(
        child=serializers.DictField(),
        required=False,
        allow_empty=True,
        help_text="List of {item_id: UUID, quantity: int}"
    )
    
    # BLADE fields
    blade_airport = serializers.ChoiceField(choices=[('JFK', 'JFK'), ('EWR', 'EWR')], required=False)
    blade_flight_date = serializers.DateField(required=False)
    blade_flight_time = serializers.TimeField(required=False)
    blade_bag_count = serializers.IntegerField(required=False, min_value=2)
    
    pickup_date = serializers.DateField()
    pickup_time = serializers.ChoiceField(choices=[
        ('morning', '8 AM - 11 AM'),
        ('morning_specific', 'Specific 1-hour window'),
        ('no_time_preference', 'No time preference'),
    ], required=False)
    specific_pickup_hour = serializers.IntegerField(required=False, allow_null=True)
    
    coi_required = serializers.BooleanField(default=False)
    is_outside_core_area = serializers.BooleanField(default=False)
    
    def validate_specialty_items(self, value):
        """Validate specialty items with quantities"""
        if not value:
            return []
        
        for item in value:
            if 'item_id' not in item or 'quantity' not in item:
                raise serializers.ValidationError(
                    "Each specialty item must have 'item_id' and 'quantity'"
                )
            if item['quantity'] < 1:
                raise serializers.ValidationError("Quantity must be at least 1")
        
        return value
    
    def validate(self, attrs):
        service_type = attrs['service_type']
        
        if service_type == 'blade_transfer':
            if not all([attrs.get('blade_airport'), attrs.get('blade_flight_date'), 
                       attrs.get('blade_flight_time'), attrs.get('blade_bag_count')]):
                raise serializers.ValidationError("All BLADE fields required")
            
            if attrs.get('blade_bag_count', 0) < 2:
                raise serializers.ValidationError("Minimum 2 bags")
        
        elif service_type == 'mini_move':
            if not attrs.get('mini_move_package_id'):
                raise serializers.ValidationError("Package ID required")
        
        elif service_type == 'standard_delivery':
            item_count = attrs.get('standard_delivery_item_count', 0)
            specialty_items = attrs.get('specialty_items', [])
            
            if item_count == 0 and len(specialty_items) == 0:
                raise serializers.ValidationError("At least one item required")
        
        elif service_type == 'specialty_item':
            if not attrs.get('specialty_items'):
                raise serializers.ValidationError("Specialty items required")
        
        # Calculate pricing
        attrs['calculated_total_cents'] = self._calculate_total_price(attrs)
        
        return attrs
    
    def _calculate_total_price(self, data):
        """
        Calculate total price WITH QUANTITIES
        ✅ OPTIMIZED: Bulk fetch specialty items to avoid N+1 queries
        """
        service_type = data['service_type']
        total_cents = 0
        
        # BLADE pricing
        if service_type == 'blade_transfer':
            bag_count = data.get('blade_bag_count', 0)
            total_cents = max(bag_count * 7500, 15000)
            return total_cents
        
        # Mini Move pricing
        elif service_type == 'mini_move':
            try:
                package = MiniMovePackage.objects.get(id=data['mini_move_package_id'])
                total_cents = package.base_price_cents
                
                if data.get('coi_required') and not package.coi_included:
                    total_cents += package.coi_fee_cents
                
                # Organizing services
                organizing_total = 0
                if data.get('include_packing'):
                    packing = OrganizingService.objects.filter(
                        mini_move_tier=package.package_type,
                        is_packing_service=True,
                        is_active=True
                    ).first()
                    if packing:
                        organizing_total += packing.price_cents
                
                if data.get('include_unpacking'):
                    unpacking = OrganizingService.objects.filter(
                        mini_move_tier=package.package_type,
                        is_packing_service=False,
                        is_active=True
                    ).first()
                    if unpacking:
                        organizing_total += unpacking.price_cents
                
                if organizing_total > 0:
                    total_cents += organizing_total + int(organizing_total * 0.0825)
                
                if data.get('is_outside_core_area'):
                    total_cents += 17500
                
                if data.get('pickup_time') == 'morning_specific' and package.package_type == 'standard':
                    total_cents += 17500
                
            except MiniMovePackage.DoesNotExist:
                raise serializers.ValidationError("Invalid package")
        
        # Standard Delivery pricing - ✅ OPTIMIZED WITH BULK FETCH
        elif service_type == 'standard_delivery':
            try:
                config = StandardDeliveryConfig.objects.filter(is_active=True).first()
                if config:
                    item_count = data.get('standard_delivery_item_count', 0)
                    if item_count > 0:
                        item_total = config.price_per_item_cents * item_count
                        total_cents = max(item_total, config.minimum_charge_cents)
                    
                    # ✅ OPTIMIZED: Bulk fetch specialty items (was N+1 query)
                    specialty_items_data = data.get('specialty_items', [])
                    if specialty_items_data:
                        # Extract all item IDs
                        item_ids = [item_data['item_id'] for item_data in specialty_items_data]
                        
                        # Single query to fetch all items
                        items_dict = {
                            str(item.id): item 
                            for item in SpecialtyItem.objects.filter(id__in=item_ids, is_active=True)
                        }
                        
                        # Calculate totals
                        for item_data in specialty_items_data:
                            item_id = str(item_data['item_id'])
                            if item_id in items_dict:
                                item = items_dict[item_id]
                                quantity = item_data['quantity']
                                total_cents += item.price_cents * quantity
                    
                    if data.get('is_same_day_delivery'):
                        total_cents += config.same_day_flat_rate_cents
                    
                    if data.get('coi_required'):
                        total_cents += 5000
                    
                    if data.get('is_outside_core_area'):
                        total_cents += 17500
                        
            except StandardDeliveryConfig.DoesNotExist:
                raise serializers.ValidationError("Standard delivery not configured")
        
        # Specialty Item pricing - ✅ OPTIMIZED WITH BULK FETCH
        elif service_type == 'specialty_item':
            specialty_items_data = data.get('specialty_items', [])
            
            if specialty_items_data:
                # ✅ OPTIMIZED: Bulk fetch specialty items (was N+1 query)
                item_ids = [item_data['item_id'] for item_data in specialty_items_data]
                
                # Single query to fetch all items
                items_dict = {
                    str(item.id): item 
                    for item in SpecialtyItem.objects.filter(id__in=item_ids, is_active=True)
                }
                
                # Calculate totals
                for item_data in specialty_items_data:
                    item_id = str(item_data['item_id'])
                    if item_id in items_dict:
                        item = items_dict[item_id]
                        quantity = item_data['quantity']
                        total_cents += item.price_cents * quantity
            
            if data.get('is_same_day_delivery'):
                try:
                    config = StandardDeliveryConfig.objects.filter(is_active=True).first()
                    if config:
                        total_cents += config.same_day_flat_rate_cents
                except StandardDeliveryConfig.DoesNotExist:
                    pass
            
            if data.get('coi_required'):
                total_cents += 5000
            
            if data.get('is_outside_core_area'):
                total_cents += 17500
        
        # Weekend surcharges
        if service_type != 'blade_transfer' and data.get('pickup_date'):
            active_surcharges = SurchargeRule.objects.filter(is_active=True)
            for surcharge in active_surcharges:
                surcharge_amount = surcharge.calculate_surcharge(
                    total_cents,
                    data['pickup_date'],
                    service_type
                )
                total_cents += surcharge_amount
        
        return total_cents


class GuestBookingCreateSerializer(serializers.Serializer):
    """
    Create booking for guest AFTER payment succeeds
    ✅ NOW SUPPORTS QUANTITIES
    """
    
    payment_intent_id = serializers.CharField(required=True)
    
    # Guest info
    first_name = serializers.CharField(max_length=100)
    last_name = serializers.CharField(max_length=100)
    email = serializers.EmailField()
    phone = serializers.CharField(max_length=20)
    
    service_type = serializers.ChoiceField(choices=[
        ('mini_move', 'Mini Move'),
        ('standard_delivery', 'Standard Delivery'),
        ('specialty_item', 'Specialty Item'),
        ('blade_transfer', 'BLADE Airport Transfer'),
    ])
    
    mini_move_package_id = serializers.UUIDField(required=False)
    standard_delivery_item_count = serializers.IntegerField(required=False, min_value=0)
    is_same_day_delivery = serializers.BooleanField(default=False)
    
    specialty_items = serializers.ListField(
        child=serializers.DictField(),
        required=False,
        allow_empty=True
    )
    
    include_packing = serializers.BooleanField(default=False)
    include_unpacking = serializers.BooleanField(default=False)
    
    # BLADE fields
    blade_airport = serializers.ChoiceField(choices=[('JFK', 'JFK'), ('EWR', 'EWR')], required=False)
    blade_flight_date = serializers.DateField(required=False)
    blade_flight_time = serializers.TimeField(required=False)
    blade_bag_count = serializers.IntegerField(required=False, min_value=2)
    
    pickup_date = serializers.DateField()
    pickup_time = serializers.ChoiceField(choices=[
        ('morning', '8 AM - 11 AM'),
        ('morning_specific', 'Specific 1-hour window'),
        ('no_time_preference', 'No time preference'),
    ], default='morning')
    specific_pickup_hour = serializers.IntegerField(required=False, min_value=8, max_value=10)
    
    is_outside_core_area = serializers.BooleanField(default=False)
    
    pickup_address = serializers.DictField()
    delivery_address = serializers.DictField()
    
    special_instructions = serializers.CharField(required=False, allow_blank=True)
    coi_required = serializers.BooleanField(default=False)
    
    def validate_pickup_address(self, value):
        required_fields = ['address_line_1', 'city', 'state', 'zip_code']
        for field in required_fields:
            if field not in value:
                raise serializers.ValidationError(f"Missing: {field}")
        
        from .zip_codes import validate_service_area
        
        zip_code = value.get('zip_code')
        is_serviceable, requires_surcharge, zone, error = validate_service_area(zip_code)
        
        if not is_serviceable:
            raise serializers.ValidationError(error)
        
        return value

    def validate_delivery_address(self, value):
        required_fields = ['address_line_1', 'city', 'state', 'zip_code']
        for field in required_fields:
            if field not in value:
                raise serializers.ValidationError(f"Missing: {field}")
        
        if self.initial_data.get('service_type') == 'blade_transfer':
            return value
        
        from .zip_codes import validate_service_area
        
        zip_code = value.get('zip_code')
        is_serviceable, requires_surcharge, zone, error = validate_service_area(zip_code)
        
        if not is_serviceable:
            raise serializers.ValidationError(error)
        
        return value
    
    def validate_specialty_items(self, value):
        if not value:
            return []
        
        for item in value:
            if 'item_id' not in item or 'quantity' not in item:
                raise serializers.ValidationError(
                    "Each item needs 'item_id' and 'quantity'"
                )
            if item['quantity'] < 1:
                raise serializers.ValidationError("Quantity must be >= 1")
        
        return value
    
    def validate(self, attrs):
        service_type = attrs['service_type']
        pickup_time = attrs.get('pickup_time', 'morning')
        
        if pickup_time == 'morning_specific' and not attrs.get('specific_pickup_hour'):
            raise serializers.ValidationError("specific_pickup_hour required")
        
        # BLADE validation
        if service_type == 'blade_transfer':
            if not all([attrs.get('blade_airport'), attrs.get('blade_flight_date'), 
                       attrs.get('blade_flight_time'), attrs.get('blade_bag_count')]):
                raise serializers.ValidationError("All BLADE fields required")
            
            if attrs.get('blade_bag_count', 0) < 2:
                raise serializers.ValidationError("Minimum 2 bags")
        
        # Mini Move validation
        elif service_type == 'mini_move':
            if not attrs.get('mini_move_package_id'):
                raise serializers.ValidationError("Package ID required")
        
        # Standard Delivery validation
        elif service_type == 'standard_delivery':
            item_count = attrs.get('standard_delivery_item_count', 0)
            specialty_items = attrs.get('specialty_items', [])
            
            if item_count == 0 and len(specialty_items) == 0:
                raise serializers.ValidationError("At least one item required")
        
        elif service_type == 'specialty_item':
            if not attrs.get('specialty_items'):
                raise serializers.ValidationError("Specialty items required")
        
        return attrs
    
    def create(self, validated_data):
        payment_intent_id = validated_data.pop('payment_intent_id')
        
        # Create guest checkout
        guest_checkout = GuestCheckout.objects.create(
            first_name=validated_data['first_name'],
            last_name=validated_data['last_name'],
            email=validated_data['email'],
            phone=validated_data['phone']
        )
        
        # Create addresses
        pickup_address_data = validated_data.pop('pickup_address')
        pickup_address = Address.objects.create(**pickup_address_data)
        
        delivery_address_data = validated_data.pop('delivery_address')
        delivery_address = Address.objects.create(**delivery_address_data)
        
        # Extract specialty items BEFORE creating booking
        specialty_items_data = validated_data.pop('specialty_items', [])
        
        # Create booking
        booking = Booking.objects.create(
            guest_checkout=guest_checkout,
            service_type=validated_data['service_type'],
            pickup_date=validated_data['pickup_date'],
            pickup_time=validated_data['pickup_time'],
            specific_pickup_hour=validated_data.get('specific_pickup_hour'),
            pickup_address=pickup_address,
            delivery_address=delivery_address,
            special_instructions=validated_data.get('special_instructions', ''),
            coi_required=validated_data.get('coi_required', False),
            is_outside_core_area=validated_data.get('is_outside_core_area', False),
            standard_delivery_item_count=validated_data.get('standard_delivery_item_count'),
            is_same_day_delivery=validated_data.get('is_same_day_delivery', False),
            include_packing=validated_data.get('include_packing', False),
            include_unpacking=validated_data.get('include_unpacking', False),
            blade_airport=validated_data.get('blade_airport'),
            blade_flight_date=validated_data.get('blade_flight_date'),
            blade_flight_time=validated_data.get('blade_flight_time'),
            blade_bag_count=validated_data.get('blade_bag_count'),
            status='pending',
        )
        
        # Handle mini move package
        if validated_data['service_type'] == 'mini_move':
            try:
                package = MiniMovePackage.objects.get(id=validated_data['mini_move_package_id'])
                booking.mini_move_package = package
            except MiniMovePackage.DoesNotExist:
                raise serializers.ValidationError("Invalid package")
        
        # ✅ OPTIMIZED: Bulk fetch specialty items (was N+1 query)
        if specialty_items_data:
            booking.save()  # Save first to get ID
            
            # Bulk fetch all specialty items in one query
            item_ids = [item_data['item_id'] for item_data in specialty_items_data]
            items_dict = {
                str(item.id): item 
                for item in SpecialtyItem.objects.filter(id__in=item_ids)
            }
            
            # Create BookingSpecialtyItem records
            for item_data in specialty_items_data:
                item_id = str(item_data['item_id'])
                if item_id in items_dict:
                    BookingSpecialtyItem.objects.create(
                        booking=booking,
                        specialty_item=items_dict[item_id],
                        quantity=item_data['quantity']
                    )
        
        booking.save()
        return booking
```

# ==== apps/bookings/signals.py ====

```python
import logging
from django.db.models.signals import pre_save
from django.dispatch import receiver
from apps.bookings.models import Booking
from apps.customers.emails import (
    send_booking_status_update_email,
    send_booking_confirmation_email,
)

logger = logging.getLogger(__name__)


@receiver(pre_save, sender=Booking)
def booking_status_changed(sender, instance, **kwargs):
    """
    Send emails when a booking's status changes.
    - Always send status-update email on change.
    - Additionally send confirmation when becoming 'paid' or 'confirmed'.
    """
    if not instance.pk:
        # New booking being created; no "old" status to compare here.
        return

    try:
        old = Booking.objects.get(pk=instance.pk)
    except Booking.DoesNotExist:
        # Shouldn't happen for existing pk, but guard anyway.
        return

    old_status = old.status
    new_status = instance.status

    if old_status == new_status:
        return

    logger.info(f"📧 Booking {old.booking_number} status changed: {old_status} → {new_status}")
    # Status update notification to customer
    try:
        send_booking_status_update_email(instance, old_status, new_status)
    except Exception as e:
        logger.error(f"Failed to send status update email for {instance.booking_number}: {e}", exc_info=True)

    # Confirmation on transition to paid/confirmed
    if new_status in ('paid', 'confirmed'):
        try:
            send_booking_confirmation_email(instance)
        except Exception as e:
            logger.error(f"Failed to send confirmation for {instance.booking_number}: {e}", exc_info=True)
```

# ==== apps/bookings/tasks.py ====

```python
# apps/bookings/tasks.py
from celery import shared_task
from django.utils import timezone
from datetime import timedelta
import logging

logger = logging.getLogger(__name__)


@shared_task
def send_booking_reminders():
    """
    Send 24-hour reminder emails for upcoming bookings.
    Runs every hour via Celery Beat.
    """
    from apps.bookings.models import Booking
    from apps.customers.emails import send_booking_reminder_email
    
    try:
        # Calculate target time: 24 hours from now (with 1-hour window)
        now = timezone.now()
        target_start = now + timedelta(hours=23)
        target_end = now + timedelta(hours=25)
        
        logger.info(f'Checking for bookings between {target_start} and {target_end}')
        
        # Find confirmed bookings that:
        # 1. Pickup is in 23-25 hours
        # 2. Haven't received reminder yet
        # 3. Not cancelled/completed
        bookings = Booking.objects.filter(
            status__in=['pending', 'paid', 'confirmed'],
            pickup_date__gte=target_start.date(),
            pickup_date__lte=target_end.date(),
            reminder_sent_at__isnull=True,
            deleted_at__isnull=True
        )
        
        sent_count = 0
        failed_count = 0
        
        for booking in bookings:
            # Double-check the booking is really in the 24hr window
            # (pickup_date is date-only, so we check against date)
            if booking.pickup_date == target_start.date() or booking.pickup_date == target_end.date():
                logger.info(f'Sending reminder for booking {booking.booking_number}')
                
                if send_booking_reminder_email(booking):
                    sent_count += 1
                else:
                    failed_count += 1
        
        logger.info(f'✓ Reminder task complete: {sent_count} sent, {failed_count} failed')
        return {
            'sent': sent_count,
            'failed': failed_count,
            'checked_range': f'{target_start} to {target_end}'
        }
        
    except Exception as e:
        logger.error(f'Error in send_booking_reminders task: {e}', exc_info=True)
        return {'error': str(e)}
```

# ==== apps/bookings/tests/__init__.py ====

```python

```

# ==== apps/bookings/tests/test_booking_api.py ====

```python
# backend/apps/bookings/tests/test_booking_api.py
import pytest
from django.contrib.auth.models import User
from rest_framework.test import APIClient
from apps.customers.models import CustomerProfile
from apps.bookings.models import Booking, Address, GuestCheckout
from apps.services.models import MiniMovePackage
from django.utils import timezone
from datetime import timedelta
from unittest.mock import patch, Mock


@pytest.fixture
def authenticated_client(db):
    """Create authenticated API client"""
    user = User.objects.create_user(
        username='testuser',
        email='test@example.com',
        password='testpass123',
        is_active=True
    )
    CustomerProfile.objects.create(user=user, phone='5551234567')
    
    client = APIClient()
    client.force_authenticate(user=user)
    return client, user


@pytest.fixture
def addresses(db):
    """Create test addresses"""
    pickup = Address.objects.create(
        address_line_1='123 Pickup St',
        city='New York',
        state='NY',
        zip_code='10001'
    )
    delivery = Address.objects.create(
        address_line_1='456 Delivery Ave',
        city='New York',
        state='NY',
        zip_code='10002'
    )
    return pickup, delivery


@pytest.fixture
def mini_move_package(db):
    """Create test mini move package"""
    return MiniMovePackage.objects.create(
        package_type='petite',
        name='Petite',
        description='Test package',
        base_price_cents=99500,
        max_items=15,
        max_weight_per_item_lbs=50,
        is_active=True
    )


# backend/apps/bookings/tests/test_booking_api.py

@pytest.mark.django_db
class TestBookingCreation:
    """Test booking creation"""
    
    @patch('stripe.PaymentIntent.retrieve')
    def test_create_booking_authenticated(self, mock_retrieve, authenticated_client, addresses, mini_move_package):
        """Test creating booking as authenticated user"""
        client, user = authenticated_client
        pickup, delivery = addresses
        
        # ✅ Mock Stripe payment verification
        mock_retrieve.return_value = Mock(
            id='pi_test_123',
            status='succeeded',
            amount=99500,
            get=lambda x, default='': 'ch_test_789' if x == 'latest_charge' else default
        )
        
        response = client.post('/api/customer/bookings/create/', {
            'payment_intent_id': 'pi_test_123',
            'service_type': 'mini_move',
            'mini_move_package_id': str(mini_move_package.id),
            'new_pickup_address': {  # ✅ Changed from pickup_address
                'address_line_1': pickup.address_line_1,
                'city': pickup.city,
                'state': pickup.state,
                'zip_code': pickup.zip_code
            },
            'new_delivery_address': {  # ✅ Changed from delivery_address
                'address_line_1': delivery.address_line_1,
                'city': delivery.city,
                'state': delivery.state,
                'zip_code': delivery.zip_code
            },
            'pickup_date': (timezone.now().date() + timedelta(days=2)).isoformat(),
            'pickup_time': 'morning'
        }, format='json')  # ✅ Added format='json'
        
        assert response.status_code == 201
        assert 'booking' in response.data
        
        # Verify booking was created
        booking = Booking.objects.get(customer=user)
        assert booking.status == 'paid'
    
    @patch('stripe.PaymentIntent.retrieve')
    def test_create_booking_guest(self, mock_retrieve, addresses, mini_move_package):
        """Test creating booking as guest"""
        client = APIClient()
        pickup, delivery = addresses
        
        # ✅ Mock Stripe payment verification
        mock_retrieve.return_value = Mock(
            id='pi_test_456',
            status='succeeded',
            amount=99500,
            get=lambda x, default='': 'ch_test_123' if x == 'latest_charge' else default
        )
        
        response = client.post('/api/public/guest-booking/', {  # ✅ Fixed endpoint
            'payment_intent_id': 'pi_test_456',
            'first_name': 'Guest',
            'last_name': 'User',
            'email': 'guest@example.com',
            'phone': '5559876543',
            'service_type': 'mini_move',
            'mini_move_package_id': str(mini_move_package.id),
            'pickup_address': {  # ✅ Already correct for guest
                'address_line_1': pickup.address_line_1,
                'city': pickup.city,
                'state': pickup.state,
                'zip_code': pickup.zip_code
            },
            'delivery_address': {  # ✅ Already correct for guest
                'address_line_1': delivery.address_line_1,
                'city': delivery.city,
                'state': delivery.state,
                'zip_code': delivery.zip_code
            },
            'pickup_date': (timezone.now().date() + timedelta(days=2)).isoformat(),
            'pickup_time': 'morning'
        }, format='json')  # ✅ Added format='json'
        
        assert response.status_code == 201
        
        # Verify guest checkout was created
        booking = Booking.objects.get(booking_number=response.data['booking']['booking_number'])
        assert booking.guest_checkout is not None
        assert booking.guest_checkout.email == 'guest@example.com'
    
@pytest.mark.django_db
class TestBookingRetrieval:
    """Test booking retrieval"""
    
    def test_get_customer_bookings(self, authenticated_client, addresses, mini_move_package):
        """Test getting customer's bookings"""
        client, user = authenticated_client
        pickup, delivery = addresses
        
        # Create a booking
        Booking.objects.create(
            customer=user,
            service_type='mini_move',
            mini_move_package=mini_move_package,
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=timezone.now().date() + timedelta(days=1),
            status='confirmed'
        )
        
        response = client.get('/api/customer/bookings/')
        
        assert response.status_code == 200
        assert len(response.data['bookings']) == 1
    
    def test_cannot_see_other_customer_bookings(self, authenticated_client, addresses):
        """Test customer cannot see another customer's bookings"""
        client, user = authenticated_client
        pickup, delivery = addresses
        
        # Create another user with booking
        other_user = User.objects.create_user(
            username='other',
            email='other@example.com',
            password='testpass123'
        )
        CustomerProfile.objects.create(user=other_user, phone='5559999999')
        
        Booking.objects.create(
            customer=other_user,
            service_type='mini_move',
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=timezone.now().date() + timedelta(days=1),
            status='confirmed'
        )
        
        response = client.get('/api/customer/bookings/')
        
        assert response.status_code == 200
        assert len(response.data['bookings']) == 0
```

# ==== apps/bookings/tests/test_booking_flow.py ====

```python
# backend/apps/bookings/tests/test_booking_flow.py
import pytest
from django.contrib.auth.models import User
from rest_framework.test import APIClient
from apps.customers.models import CustomerProfile
from apps.bookings.models import Booking, Address, GuestCheckout
from apps.services.models import MiniMovePackage, StandardDeliveryConfig, SpecialtyItem, OrganizingService
from django.utils import timezone
from datetime import timedelta
from unittest.mock import patch, Mock


@pytest.fixture
def test_services(db):
    """Create or get test services"""
    # Mini Move Package
    package, _ = MiniMovePackage.objects.get_or_create(
        package_type='petite',
        defaults={
            'name': 'Petite',
            'description': 'Test package',
            'base_price_cents': 99500,
            'max_items': 15,
            'max_weight_per_item_lbs': 50,
            'coi_fee_cents': 5000,
            'is_active': True
        }
    )
    
    # Organizing Services
    packing, _ = OrganizingService.objects.get_or_create(
        service_type='petite_packing',
        defaults={
            'mini_move_tier': 'petite',
            'name': 'Petite Packing',
            'price_cents': 140000,
            'duration_hours': 4,
            'organizer_count': 2,
            'supplies_allowance_cents': 25000,
            'is_packing_service': True,
            'is_active': True
        }
    )
    
    # Specialty Item
    peloton, _ = SpecialtyItem.objects.get_or_create(
        item_type='peloton',
        defaults={
            'name': 'Peloton',
            'price_cents': 50000,
            'is_active': True
        }
    )
    
    # Standard Delivery Config
    config, _ = StandardDeliveryConfig.objects.get_or_create(
        is_active=True,
        defaults={
            'price_per_item_cents': 9500,
            'minimum_charge_cents': 28500,
            'same_day_flat_rate_cents': 36000
        }
    )
    
    return {
        'package': package,
        'packing': packing,
        'peloton': peloton,
        'config': config
    }


@pytest.fixture
def test_addresses(db):
    """Create test addresses"""
    pickup = Address.objects.create(
        address_line_1='123 Pickup St',
        city='New York',
        state='NY',
        zip_code='10001'
    )
    delivery = Address.objects.create(
        address_line_1='456 Delivery Ave',
        city='New York',
        state='NY',
        zip_code='10002'
    )
    return pickup, delivery


@pytest.fixture
def authenticated_customer(db):
    """Create authenticated customer"""
    user = User.objects.create_user(
        username='customer@example.com',
        email='customer@example.com',
        password='testpass123',
        first_name='Test',
        last_name='Customer',
        is_active=True
    )
    CustomerProfile.objects.create(user=user, phone='5551234567')
    
    client = APIClient()
    client.force_authenticate(user=user)
    return client, user


@pytest.mark.django_db
class TestGuestBookingFlow:
    """Test complete guest booking flow with payment"""
    
    @patch('stripe.PaymentIntent.create')
    @patch('stripe.PaymentIntent.retrieve')
    def test_guest_booking_complete_flow(self, mock_retrieve, mock_create, test_services, test_addresses):
        """Test full guest booking: create payment intent → pay → create booking"""
        client = APIClient()
        pickup, delivery = test_addresses
        package = test_services['package']
        
        # Step 1: Create payment intent
        mock_create.return_value = Mock(
            id='pi_test_123',
            client_secret='pi_test_123_secret_456',
            amount=99500,
            status='requires_payment_method'
        )
        
        payment_response = client.post('/api/public/create-payment-intent/', {
            'service_type': 'mini_move',
            'mini_move_package_id': str(package.id),
            'pickup_date': (timezone.now().date() + timedelta(days=2)).isoformat(),
            'first_name': 'Guest',
            'last_name': 'User',
            'email': 'guest@example.com',
            'phone': '5559876543'
        }, format='json')
        
        assert payment_response.status_code == 200
        assert 'client_secret' in payment_response.data
        assert 'payment_intent_id' in payment_response.data
        
        # Step 2: Simulate payment success
        mock_retrieve.return_value = Mock(
            id='pi_test_123',
            status='succeeded',
            amount=99500
        )
        
        # Step 3: Create booking with payment_intent_id
        booking_response = client.post('/api/public/guest-booking/', {
            'payment_intent_id': 'pi_test_123',
            'service_type': 'mini_move',
            'mini_move_package_id': str(package.id),
            'first_name': 'Guest',
            'last_name': 'User',
            'email': 'guest@example.com',
            'phone': '5559876543',
            'pickup_date': (timezone.now().date() + timedelta(days=2)).isoformat(),
            'pickup_time': 'morning',
            'pickup_address': {
                'address_line_1': '123 Pickup St',
                'city': 'New York',
                'state': 'NY',
                'zip_code': '10001'
            },
            'delivery_address': {
                'address_line_1': '456 Delivery Ave',
                'city': 'New York',
                'state': 'NY',
                'zip_code': '10002'
            }
        }, format='json')
        
        assert booking_response.status_code == 201
        assert 'booking_number' in booking_response.data['booking']
        
        # Verify booking was created
        booking = Booking.objects.get(booking_number=booking_response.data['booking']['booking_number'])
        assert booking.guest_checkout is not None
        assert booking.guest_checkout.email == 'guest@example.com'
        assert booking.status == 'paid'
        assert booking.total_price_cents == 99500
    
    def test_guest_booking_without_payment_intent_fails(self, test_services, test_addresses):
        """Test booking creation fails without payment_intent_id"""
        client = APIClient()
        package = test_services['package']
        
        response = client.post('/api/public/guest-booking/', {
            # Missing payment_intent_id
            'service_type': 'mini_move',
            'mini_move_package_id': str(package.id),
            'first_name': 'Guest',
            'last_name': 'User',
            'email': 'guest@example.com',
            'phone': '5559876543',
            'pickup_date': (timezone.now().date() + timedelta(days=2)).isoformat(),
            'pickup_address': {
                'address_line_1': '123 Test St',
                'city': 'New York',
                'state': 'NY',
                'zip_code': '10001'
            },
            'delivery_address': {
                'address_line_1': '456 Test Ave',
                'city': 'New York',
                'state': 'NY',
                'zip_code': '10002'
            }
        }, format='json')
        
        assert response.status_code == 400
        assert 'payment_intent_id' in str(response.data)

# backend/apps/bookings/tests/test_booking_flow.py
# Replace the TestAuthenticatedBookingFlow class:

@pytest.mark.django_db
class TestAuthenticatedBookingFlow:
    """Test authenticated customer booking flow"""
    
    @patch('stripe.PaymentIntent.create')
    @patch('stripe.PaymentIntent.retrieve')
    def test_authenticated_booking_complete_flow(self, mock_retrieve, mock_create, authenticated_customer, test_services, test_addresses):
        """Test full authenticated booking flow"""
        client, user = authenticated_customer
        package = test_services['package']
        pickup, delivery = test_addresses
        
        # Step 1: Create payment intent
        mock_create.return_value = Mock(
            id='pi_test_456',
            client_secret='pi_test_456_secret',
            amount=99500
        )
        
        payment_response = client.post('/api/customer/bookings/create-payment-intent/', {
            'service_type': 'mini_move',
            'mini_move_package_id': str(package.id),
            'pickup_date': (timezone.now().date() + timedelta(days=2)).isoformat(),
            'customer_email': user.email
        }, format='json')
        
        assert payment_response.status_code == 200
        
        # Step 2: Simulate payment success
        mock_retrieve.return_value = Mock(
            id='pi_test_456',
            status='succeeded',
            amount=99500,
            get=lambda x, default='': 'ch_test_789' if x == 'latest_charge' else default
        )
        
        # Step 3: Create booking - USE new_pickup_address and new_delivery_address
        booking_response = client.post('/api/customer/bookings/create/', {
            'payment_intent_id': 'pi_test_456',
            'service_type': 'mini_move',
            'mini_move_package_id': str(package.id),
            'new_pickup_address': {  # ← CHANGED to new_pickup_address
                'address_line_1': pickup.address_line_1,
                'city': pickup.city,
                'state': pickup.state,
                'zip_code': pickup.zip_code
            },
            'new_delivery_address': {  # ← CHANGED to new_delivery_address
                'address_line_1': delivery.address_line_1,
                'city': delivery.city,
                'state': delivery.state,
                'zip_code': delivery.zip_code
            },
            'pickup_date': (timezone.now().date() + timedelta(days=2)).isoformat(),
            'pickup_time': 'morning'
        }, format='json')
        
        assert booking_response.status_code == 201
        assert 'booking' in booking_response.data
        
        # Verify booking
        booking = Booking.objects.get(customer=user)
        assert booking.status == 'paid'
        assert booking.customer == user

@pytest.mark.django_db
class TestBookingPricing:
    """Test booking pricing calculations"""
    
    def test_mini_move_pricing_calculation(self, test_services, test_addresses):
        """Test mini move pricing"""
        pickup, delivery = test_addresses
        package = test_services['package']
        
        booking = Booking.objects.create(
            guest_checkout=GuestCheckout.objects.create(
                first_name='Test',
                last_name='User',
                email='test@example.com',
                phone='5551234567'
            ),
            service_type='mini_move',
            mini_move_package=package,
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=timezone.now().date() + timedelta(days=2),
            status='pending'
        )
        
        assert booking.base_price_cents == 99500
        assert booking.total_price_cents >= 99500
        assert booking.booking_number.startswith('TT-')
    
    def test_mini_move_with_organizing_services(self, test_services, test_addresses):
        """Test mini move with packing service"""
        pickup, delivery = test_addresses
        package = test_services['package']
        
        booking = Booking.objects.create(
            guest_checkout=GuestCheckout.objects.create(
                first_name='Test',
                last_name='User',
                email='test@example.com',
                phone='5551234567'
            ),
            service_type='mini_move',
            mini_move_package=package,
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=timezone.now().date() + timedelta(days=2),
            include_packing=True,
            status='pending'
        )
        
        assert booking.organizing_total_cents > 0
        assert booking.organizing_tax_cents > 0
        assert booking.total_price_cents > booking.base_price_cents
    
    def test_specialty_item_pricing(self, test_services, test_addresses):
        """Test specialty item pricing"""
        pickup, delivery = test_addresses
        peloton = test_services['peloton']
        
        booking = Booking.objects.create(
            guest_checkout=GuestCheckout.objects.create(
                first_name='Test',
                last_name='User',
                email='test@example.com',
                phone='5551234567'
            ),
            service_type='specialty_item',
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=timezone.now().date() + timedelta(days=2),
            status='pending'
        )
        
        booking.specialty_items.add(peloton)
        booking.save()
        
        assert booking.base_price_cents == 50000


@pytest.mark.django_db
class TestBookingValidation:
    """Test booking validation rules"""
    
    def test_booking_requires_customer_or_guest(self, test_services, test_addresses):
        """Test booking must have either customer or guest"""
        pickup, delivery = test_addresses
        package = test_services['package']
        
        # This should fail due to CheckConstraint
        with pytest.raises(Exception):
            Booking.objects.create(
                service_type='mini_move',
                mini_move_package=package,
                pickup_address=pickup,
                delivery_address=delivery,
                pickup_date=timezone.now().date() + timedelta(days=1),
                # No customer or guest_checkout
                status='pending'
            )
    
    def test_get_customer_name_and_email(self, test_addresses):
        """Test booking customer name/email methods"""
        pickup, delivery = test_addresses
        
        guest = GuestCheckout.objects.create(
            first_name='Guest',
            last_name='User',
            email='guest@example.com',
            phone='5551234567'
        )
        
        booking = Booking.objects.create(
            guest_checkout=guest,
            service_type='mini_move',
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=timezone.now().date() + timedelta(days=1),
            status='pending'
        )
        
        assert booking.get_customer_name() == 'Guest User'
        assert booking.get_customer_email() == 'guest@example.com'


@pytest.mark.django_db
class TestBladeTransfer:
    """Test BLADE airport transfer bookings"""
    
    def test_blade_transfer_pricing(self, test_addresses):
        """Test BLADE pricing calculation"""
        pickup, delivery = test_addresses
        
        booking = Booking.objects.create(
            guest_checkout=GuestCheckout.objects.create(
                first_name='BLADE',
                last_name='User',
                email='blade@example.com',
                phone='5551234567'
            ),
            service_type='blade_transfer',
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=timezone.now().date() + timedelta(days=2),
            blade_airport='JFK',
            blade_bag_count=3,
            blade_flight_date=timezone.now().date() + timedelta(days=2),
            blade_flight_time=timezone.now().time(),
            status='pending'
        )
        
        # $75 per bag, 3 bags = $225
        assert booking.base_price_cents == 22500
        assert booking.blade_ready_time is not None
    
    def test_blade_minimum_bags(self, test_addresses):
        """Test BLADE minimum price enforcement"""
        pickup, delivery = test_addresses
        
        booking = Booking.objects.create(
            guest_checkout=GuestCheckout.objects.create(
                first_name='BLADE',
                last_name='User',
                email='blade@example.com',
                phone='5551234567'
            ),
            service_type='blade_transfer',
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=timezone.now().date() + timedelta(days=2),
            blade_airport='JFK',
            blade_bag_count=1,
            blade_flight_date=timezone.now().date() + timedelta(days=2),
            blade_flight_time=timezone.now().time(),
            status='pending'
        )
        
        # Minimum price is $150
        assert booking.base_price_cents == 15000
```

# ==== apps/bookings/tests/test_models.py ====

```python
# backend/apps/bookings/tests/test_models.py
import pytest
from django.core.exceptions import ValidationError
from django.contrib.auth.models import User
from apps.bookings.models import Booking, Address
from apps.customers.models import CustomerProfile
from apps.services.models import MiniMovePackage
from django.utils import timezone
from datetime import timedelta


@pytest.fixture
def addresses(db):
    pickup = Address.objects.create(
        address_line_1='123 Test St',
        city='New York',
        state='NY',
        zip_code='10001'
    )
    delivery = Address.objects.create(
        address_line_1='456 Test Ave',
        city='New York',
        state='NY',
        zip_code='10002'
    )
    return pickup, delivery


@pytest.fixture
def customer_user(db):
    user = User.objects.create_user(
        username='customer',
        email='customer@example.com',
        password='testpass123'
    )
    CustomerProfile.objects.create(user=user, phone='5551234567')
    return user


@pytest.mark.django_db
class TestBookingModel:
    """Test Booking model business logic"""
    
    def test_booking_number_generation(self, customer_user, addresses):
        """Test booking numbers are generated sequentially"""
        pickup, delivery = addresses
        
        booking1 = Booking.objects.create(
            customer=customer_user,
            service_type='mini_move',
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=timezone.now().date() + timedelta(days=1)
        )
        
        booking2 = Booking.objects.create(
            customer=customer_user,
            service_type='mini_move',
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=timezone.now().date() + timedelta(days=1)
        )
        
        assert booking1.booking_number.startswith('TT-')
        assert booking2.booking_number.startswith('TT-')
        assert booking1.booking_number != booking2.booking_number
    
    def test_pricing_calculation(self, customer_user, addresses, db):
        """Test booking pricing is calculated correctly"""
        pickup, delivery = addresses
        
        package = MiniMovePackage.objects.create(
            package_type='petite',
            name='Petite',
            base_price_cents=99500,
            max_items=15,
            is_active=True
        )
        
        booking = Booking.objects.create(
            customer=customer_user,
            service_type='mini_move',
            mini_move_package=package,
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=timezone.now().date() + timedelta(days=1)
        )
        
        assert booking.base_price_cents == 99500
        assert booking.total_price_cents >= 99500
    
    def test_get_customer_name_authenticated(self, customer_user, addresses):
        """Test getting customer name from authenticated user"""
        pickup, delivery = addresses
        
        booking = Booking.objects.create(
            customer=customer_user,
            service_type='mini_move',
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=timezone.now().date() + timedelta(days=1)
        )
        
        name = booking.get_customer_name()
        assert 'customer' in name.lower() or customer_user.get_full_name() in name
    
    def test_reminder_timestamp(self, customer_user, addresses):
        """Test reminder sent timestamp"""
        pickup, delivery = addresses
        
        booking = Booking.objects.create(
            customer=customer_user,
            service_type='mini_move',
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=timezone.now().date() + timedelta(days=1),
            status='confirmed'
        )
        
        assert booking.reminder_sent_at is None
        
        from apps.customers.emails import send_booking_reminder_email
        send_booking_reminder_email(booking)
        
        booking.refresh_from_db()
        assert booking.reminder_sent_at is not None
```

# ==== apps/bookings/tests/test_pricing.py ====

```python
# apps/bookings/tests/test_pricing.py
"""
Test pricing calculations for ToteTaxi bookings
CRITICAL: These tests protect revenue - pricing bugs = money lost
"""
import pytest
from datetime import date, timedelta
from decimal import Decimal
from django.test import TestCase

from apps.bookings.models import Booking, Address, GuestCheckout
from apps.services.models import MiniMovePackage, SurchargeRule


@pytest.mark.django_db
class TestMiniMovePricing(TestCase):
    """Test Mini Move pricing calculations"""
    
    def setUp(self):
        """Create test data matching production"""
        # Create Mini Move package
        self.petite_package = MiniMovePackage.objects.create(
            package_type='petite',
            name='Petite Move',
            description='Up to 10 items',
            base_price_cents=15000,  # $150
            max_items=10,
            max_weight_per_item_lbs=50,
            coi_included=False,
            coi_fee_cents=5000,  # $50
            is_active=True
        )
        
        # Create weekend surcharge (15%)
        self.weekend_surcharge = SurchargeRule.objects.create(
            surcharge_type='weekend',
            name='Weekend Delivery Surcharge',
            description='15% surcharge for weekend deliveries',
            applies_to_service_type='all',
            calculation_type='percentage',
            percentage=Decimal('15.00'),
            applies_saturday=True,
            applies_sunday=True,
            is_active=True
        )
        
        # Create guest checkout
        self.guest = GuestCheckout.objects.create(
            first_name="Test",
            last_name="Customer",
            email="test@totetaxi.com",
            phone="212-555-0100"
        )
        
        # Create addresses (Manhattan to Manhattan - no geographic surcharge)
        self.pickup_address = Address.objects.create(
            address_line_1="123 West 57th St",
            city="New York",
            state="NY",
            zip_code="10019"
        )
        
        self.delivery_address = Address.objects.create(
            address_line_1="456 Park Ave",
            city="New York",
            state="NY",
            zip_code="10022"
        )
    
    def test_weekday_base_price_no_extras(self):
        """Test simple weekday booking - should be base price only"""
        # Get next Monday
        today = date.today()
        days_until_monday = (0 - today.weekday()) % 7
        if days_until_monday == 0:
            days_until_monday = 7
        next_monday = today + timedelta(days=days_until_monday)
        
        booking = Booking.objects.create(
            service_type='mini_move',
            mini_move_package=self.petite_package,
            guest_checkout=self.guest,
            pickup_address=self.pickup_address,
            delivery_address=self.delivery_address,
            pickup_date=next_monday,
            pickup_time='morning',
            status='pending_payment'
        )
        
        # Assertions
        assert booking.base_price_cents == 15000, \
            f"Expected $150 base, got ${booking.base_price_cents/100}"
        assert booking.surcharge_cents == 0, \
            "Weekday should have no surcharge"
        assert booking.total_price_cents == 15000, \
            f"Expected $150 total, got ${booking.total_price_cents/100}"
        
        print(f"✅ Weekday base price: ${booking.total_price_cents / 100:.2f}")
    
    def test_weekend_surcharge_saturday(self):
        """Test that Saturday bookings get 15% surcharge"""
        # Get next Saturday
        today = date.today()
        days_until_saturday = (5 - today.weekday()) % 7
        if days_until_saturday == 0:
            days_until_saturday = 7
        next_saturday = today + timedelta(days=days_until_saturday)
        
        booking = Booking.objects.create(
            service_type='mini_move',
            mini_move_package=self.petite_package,
            guest_checkout=self.guest,
            pickup_address=self.pickup_address,
            delivery_address=self.delivery_address,
            pickup_date=next_saturday,
            pickup_time='morning',
            status='pending_payment'
        )
        
        # Calculate expected values
        expected_surcharge = int(15000 * 0.15)  # $22.50 in cents
        expected_total = 15000 + expected_surcharge
        
        # Assertions
        assert booking.base_price_cents == 15000
        assert booking.surcharge_cents == expected_surcharge, \
            f"Expected ${expected_surcharge/100} surcharge, got ${booking.surcharge_cents/100}"
        assert booking.total_price_cents == expected_total, \
            f"Expected ${expected_total/100} total, got ${booking.total_price_cents/100}"
        
        print(f"✅ Weekend surcharge: Base ${booking.base_price_cents/100} + " \
              f"Surcharge ${booking.surcharge_cents/100} = ${booking.total_price_cents/100}")
    
    def test_coi_fee_applied(self):
        """Test COI fee for Petite package"""
        # Get next Monday to avoid weekend surcharge
        today = date.today()
        days_until_monday = (0 - today.weekday()) % 7
        if days_until_monday == 0:
            days_until_monday = 7
        next_monday = today + timedelta(days=days_until_monday)
        
        booking = Booking.objects.create(
            service_type='mini_move',
            mini_move_package=self.petite_package,
            guest_checkout=self.guest,
            pickup_address=self.pickup_address,
            delivery_address=self.delivery_address,
            pickup_date=next_monday,  # ✅ FIXED: Use weekday instead of +7 days
            pickup_time='morning',
            coi_required=True,  # Request COI
            status='pending_payment'
        )
        
        # Assertions
        assert booking.coi_fee_cents == 5000, \
            f"Expected $50 COI fee, got ${booking.coi_fee_cents/100}"
        assert booking.total_price_cents == 20000, \
            f"Expected $200 total ($150 + $50 COI), got ${booking.total_price_cents/100}"
        
        print(f"✅ COI fee applied: ${booking.coi_fee_cents/100}")
    
    def test_pricing_breakdown_structure(self):
        """Test that pricing breakdown returns correct structure"""
        booking = Booking.objects.create(
            service_type='mini_move',
            mini_move_package=self.petite_package,
            guest_checkout=self.guest,
            pickup_address=self.pickup_address,
            delivery_address=self.delivery_address,
            pickup_date=date.today() + timedelta(days=7),
            pickup_time='morning',
            status='pending_payment'
        )
        
        breakdown = booking.get_pricing_breakdown()
        
        # Check structure
        assert 'base_price_dollars' in breakdown
        assert 'surcharge_dollars' in breakdown
        assert 'total_price_dollars' in breakdown
        assert isinstance(breakdown['base_price_dollars'], float)
        
        print(f"✅ Pricing breakdown: {breakdown}")
```

# ==== apps/bookings/tests/test_tasks.py ====

```python
# backend/apps/bookings/tests/test_tasks.py
import pytest
from django.utils import timezone
from datetime import timedelta
from django.core import mail
from apps.bookings.models import Booking, Address, GuestCheckout
from apps.bookings.tasks import send_booking_reminders


@pytest.fixture
def test_addresses(db):
    """Create pickup and delivery addresses"""
    pickup = Address.objects.create(
        address_line_1='123 Pickup St',
        city='New York',
        state='NY',
        zip_code='10001'
    )
    delivery = Address.objects.create(
        address_line_1='456 Delivery Ave',
        city='New York',
        state='NY',
        zip_code='10002'
    )
    return pickup, delivery


@pytest.mark.django_db
class TestBookingReminderTask:
    """Test Celery reminder task"""
    
    def setup_method(self):
        mail.outbox = []
        Booking.objects.all().delete()
    
    def test_sends_reminders_for_tomorrow_bookings(self, test_addresses):
        """Test reminders sent for bookings tomorrow"""
        pickup, delivery = test_addresses
        tomorrow = timezone.now().date() + timedelta(days=1)
        
        guest = GuestCheckout.objects.create(
            first_name='Test',
            last_name='User',
            email='test@example.com',
            phone='5551234567'
        )
        
        booking = Booking.objects.create(
            guest_checkout=guest,
            service_type='mini_move',
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=tomorrow,
            total_price_cents=99500,
            status='confirmed',
            reminder_sent_at=None
        )
        
        result = send_booking_reminders()
        
        assert result['sent'] == 1
        assert result['failed'] == 0
        assert len(mail.outbox) == 1
        
        booking.refresh_from_db()
        assert booking.reminder_sent_at is not None
    
    def test_no_reminders_for_past_bookings(self, test_addresses):
        """Test no reminders sent for past bookings"""
        pickup, delivery = test_addresses
        yesterday = timezone.now().date() - timedelta(days=1)
        
        guest = GuestCheckout.objects.create(
            first_name='Test',
            last_name='User',
            email='test@example.com',
            phone='5551234567'
        )
        
        Booking.objects.create(
            guest_checkout=guest,
            service_type='mini_move',
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=yesterday,
            total_price_cents=99500,
            status='confirmed',
            reminder_sent_at=None
        )
        
        result = send_booking_reminders()
        
        assert result['sent'] == 0
        assert len(mail.outbox) == 0
    
    def test_no_duplicate_reminders(self, test_addresses):
        """Test reminder not sent twice"""
        pickup, delivery = test_addresses
        tomorrow = timezone.now().date() + timedelta(days=1)
        
        guest = GuestCheckout.objects.create(
            first_name='Test',
            last_name='User',
            email='test@example.com',
            phone='5551234567'
        )
        
        Booking.objects.create(
            guest_checkout=guest,
            service_type='mini_move',
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=tomorrow,
            total_price_cents=99500,
            status='confirmed',
            reminder_sent_at=timezone.now()
        )
        
        result = send_booking_reminders()
        
        assert result['sent'] == 0
        assert len(mail.outbox) == 0
    
    def test_only_confirmed_bookings_get_reminders(self, test_addresses):
        """Test only confirmed/paid bookings get reminders"""
        pickup, delivery = test_addresses
        tomorrow = timezone.now().date() + timedelta(days=1)
        
        # Cancelled booking
        guest1 = GuestCheckout.objects.create(
            first_name='Cancelled',
            last_name='User',
            email='cancelled@example.com',
            phone='5551234567'
        )
        
        Booking.objects.create(
            guest_checkout=guest1,
            service_type='mini_move',
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=tomorrow,
            total_price_cents=99500,
            status='cancelled',
            reminder_sent_at=None
        )
        
        # Confirmed booking
        guest2 = GuestCheckout.objects.create(
            first_name='Confirmed',
            last_name='User',
            email='confirmed@example.com',
            phone='5559876543'
        )
        
        Booking.objects.create(
            guest_checkout=guest2,
            service_type='mini_move',
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=tomorrow,
            total_price_cents=99500,
            status='confirmed',
            reminder_sent_at=None
        )
        
        result = send_booking_reminders()
        
        assert result['sent'] == 1
        assert len(mail.outbox) == 1
        assert mail.outbox[0].to == ['confirmed@example.com']
    
    def test_handles_multiple_bookings(self, test_addresses):
        """Test task handles multiple bookings correctly"""
        pickup, delivery = test_addresses
        tomorrow = timezone.now().date() + timedelta(days=1)
        
        for i in range(3):
            guest = GuestCheckout.objects.create(
                first_name='Test',
                last_name=f'User{i}',
                email=f'test{i}@example.com',
                phone='5551234567'
            )
            
            Booking.objects.create(
                guest_checkout=guest,
                service_type='mini_move',
                pickup_address=pickup,
                delivery_address=delivery,
                pickup_date=tomorrow,
                total_price_cents=99500,
                status='confirmed',
                reminder_sent_at=None
            )
        
        result = send_booking_reminders()
        
        assert result['sent'] == 3
        assert len(mail.outbox) == 3
```

# ==== apps/bookings/urls.py ====

```python
# backend/apps/bookings/urls.py
from django.urls import path
from . import views

# Public booking API patterns - no authentication required
urlpatterns = [
    # Service information
    path('services/', views.ServiceCatalogView.as_view(), name='service-catalog'),
    path('pricing-preview/', views.PricingPreviewView.as_view(), name='pricing-preview'),
    path('availability/', views.CalendarAvailabilityView.as_view(), name='calendar-availability'),
    
    # Organizing service endpoints
    path('services/mini-moves-with-organizing/', views.ServiceCatalogWithOrganizingView.as_view(), name='mini-moves-with-organizing'),
    path('services/organizing-by-tier/', views.OrganizingServicesByTierView.as_view(), name='organizing-by-tier'),
    path('services/organizing/<uuid:service_id>/', views.OrganizingServiceDetailView.as_view(), name='organizing-service-detail'),
    
    # Payment intent creation (BEFORE booking)
    path('create-payment-intent/', views.CreateGuestPaymentIntentView.as_view(), name='create-guest-payment-intent'),
    
    # Guest booking (requires payment_intent_id)
    path('guest-booking/', views.GuestBookingCreateView.as_view(), name='guest-booking-create'),
    
    # Booking status lookup
    path('booking-status/<str:booking_number>/', views.BookingStatusView.as_view(), name='booking-status'),
    
    # ZIP code validation endpoint
    path('validate-zip/', views.ValidateZipCodeView.as_view(), name='validate-zip'),
]
```

# ==== apps/bookings/views.py ====

```python
# backend/apps/bookings/views.py
from rest_framework import generics, status, permissions
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.shortcuts import get_object_or_404
from django.utils import timezone
from datetime import date, timedelta, time as dt_time
import logging
import json
import stripe
from django.conf import settings

from .models import Booking, Address, GuestCheckout
from .serializers import (
    BookingSerializer,
    GuestBookingCreateSerializer,
    GuestPaymentIntentSerializer,
    BookingStatusSerializer,
    PricingPreviewSerializer,
    AddressSerializer
)
from apps.services.models import (
    MiniMovePackage, 
    StandardDeliveryConfig, 
    SpecialtyItem, 
    OrganizingService,
    SurchargeRule
)
from apps.services.serializers import (
    ServiceCatalogSerializer,
    MiniMovePackageSerializer,
    OrganizingServiceSerializer,
    StandardDeliveryConfigSerializer,
    SpecialtyItemSerializer,
    MiniMoveWithOrganizingSerializer,
    OrganizingServicesByTierSerializer
)
from apps.payments.services import StripePaymentService

logger = logging.getLogger(__name__)

# Initialize Stripe
stripe.api_key = settings.STRIPE_SECRET_KEY


class ServiceCatalogView(APIView):
    """Get all available services including organizing services - no authentication required"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request):
        organizing_services = OrganizingService.objects.filter(
            is_active=True
        ).order_by('mini_move_tier', 'is_packing_service')
        
        mini_move_packages = MiniMovePackage.objects.filter(
            is_active=True
        ).order_by('base_price_cents')
        
        specialty_items = SpecialtyItem.objects.filter(is_active=True)
        standard_config = StandardDeliveryConfig.objects.filter(is_active=True).first()
        
        response_data = {
            'mini_move_packages': MiniMovePackageSerializer(mini_move_packages, many=True).data,
            'organizing_services': OrganizingServiceSerializer(organizing_services, many=True).data,
            'specialty_items': SpecialtyItemSerializer(specialty_items, many=True).data,
            'standard_delivery': StandardDeliveryConfigSerializer(standard_config).data if standard_config else None
        }
        
        return Response(response_data)


class ServiceCatalogWithOrganizingView(APIView):
    """Get Mini Move packages with their organizing options - optimized for booking wizard"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request):
        serializer = MiniMoveWithOrganizingSerializer()
        return Response({
            'mini_moves_with_organizing': serializer.to_representation(None)
        })


class OrganizingServicesByTierView(APIView):
    """Get organizing services grouped by Mini Move tier - for easy frontend consumption"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request):
        serializer = OrganizingServicesByTierSerializer()
        return Response(serializer.to_representation(None))


class PricingPreviewView(APIView):
    """Calculate pricing for booking selection including organizing services + BLADE - no authentication required"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = PricingPreviewSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        service_type = serializer.validated_data['service_type']
        pickup_date = serializer.validated_data['pickup_date']
        
        base_price_cents = 0
        surcharge_cents = 0
        coi_fee_cents = 0
        organizing_total_cents = 0
        organizing_tax_cents = 0
        geographic_surcharge_cents = 0
        time_window_surcharge_cents = 0
        same_day_fee_cents = 0
        details = {}
        
        # BLADE pricing
        if service_type == 'blade_transfer':
            bag_count = serializer.validated_data.get('blade_bag_count', 0)
            
            if bag_count < 2:
                return Response({
                    'error': 'BLADE service requires minimum 2 bags'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            per_bag_price = 7500  # $75 in cents
            base_price_cents = bag_count * per_bag_price
            base_price_cents = max(base_price_cents, 15000)  # $150 minimum
            
            # Calculate ready time
            flight_time = serializer.validated_data.get('blade_flight_time')
            if flight_time:
                if flight_time < dt_time(13, 0):
                    ready_time = dt_time(5, 0)
                else:
                    ready_time = dt_time(10, 0)
                
                details['ready_time'] = ready_time.isoformat()
            
            details['airport'] = serializer.validated_data.get('blade_airport')
            details['bag_count'] = bag_count
            details['per_bag_price'] = 75
            details['flight_date'] = serializer.validated_data.get('blade_flight_date').isoformat() if serializer.validated_data.get('blade_flight_date') else None
            details['flight_time'] = serializer.validated_data.get('blade_flight_time').isoformat() if serializer.validated_data.get('blade_flight_time') else None
        
        # Mini Move pricing
        elif service_type == 'mini_move':
            package_id = serializer.validated_data.get('mini_move_package_id')
            if package_id:
                try:
                    package = MiniMovePackage.objects.get(id=package_id, is_active=True)
                    base_price_cents = package.base_price_cents
                    details['package_name'] = package.name
                    details['package_tier'] = package.package_type
                    
                    coi_required = serializer.validated_data.get('coi_required', False)
                    if coi_required and not package.coi_included:
                        coi_fee_cents = package.coi_fee_cents
                        details['coi_required'] = True
                    
                    include_packing = serializer.validated_data.get('include_packing', False)
                    include_unpacking = serializer.validated_data.get('include_unpacking', False)
                    
                    organizing_services_breakdown = []
                    
                    if include_packing:
                        packing_service = OrganizingService.objects.filter(
                            mini_move_tier=package.package_type,
                            is_packing_service=True,
                            is_active=True
                        ).first()
                        
                        if packing_service:
                            organizing_total_cents += packing_service.price_cents
                            organizing_services_breakdown.append({
                                'service': 'packing',
                                'name': packing_service.name,
                                'price_dollars': packing_service.price_dollars,
                                'duration_hours': packing_service.duration_hours,
                                'organizer_count': packing_service.organizer_count,
                                'supplies_allowance_dollars': packing_service.supplies_allowance_dollars
                            })
                        else:
                            logger.warning(f"Packing service not found for tier {package.package_type}")
                            return Response({
                                'error': f'Packing service not available for {package.package_type} tier'
                            }, status=status.HTTP_400_BAD_REQUEST)
                    
                    if include_unpacking:
                        unpacking_service = OrganizingService.objects.filter(
                            mini_move_tier=package.package_type,
                            is_packing_service=False,
                            is_active=True
                        ).first()
                        
                        if unpacking_service:
                            organizing_total_cents += unpacking_service.price_cents
                            organizing_services_breakdown.append({
                                'service': 'unpacking',
                                'name': unpacking_service.name,
                                'price_dollars': unpacking_service.price_dollars,
                                'duration_hours': unpacking_service.duration_hours,
                                'organizer_count': unpacking_service.organizer_count,
                                'supplies_allowance_dollars': 0
                            })
                        else:
                            logger.warning(f"Unpacking service not found for tier {package.package_type}")
                            return Response({
                                'error': f'Unpacking service not available for {package.package_type} tier'
                            }, status=status.HTTP_400_BAD_REQUEST)
                    
                    if organizing_total_cents > 0:
                        organizing_tax_cents = int(organizing_total_cents * 0.0825)
                    
                    pickup_time = serializer.validated_data.get('pickup_time', 'morning')
                    if pickup_time == 'morning_specific' and package.package_type == 'standard':
                        time_window_surcharge_cents = 17500
                    
                    is_outside_core_area = serializer.validated_data.get('is_outside_core_area', False)
                    if is_outside_core_area:
                        geographic_surcharge_cents = 17500
                    
                    if organizing_services_breakdown:
                        details['organizing_services'] = organizing_services_breakdown
                    
                except MiniMovePackage.DoesNotExist:
                    return Response({'error': 'Invalid mini move package'}, status=status.HTTP_400_BAD_REQUEST)
        
        # Standard Delivery pricing
        elif service_type == 'standard_delivery':
            if serializer.validated_data.get('include_packing') or serializer.validated_data.get('include_unpacking'):
                return Response({
                    'error': 'Organizing services are only available for Mini Move bookings'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            item_count = serializer.validated_data.get('standard_delivery_item_count', 0)
            specialty_items_data = serializer.validated_data.get('specialty_items', [])
            is_same_day = serializer.validated_data.get('is_same_day_delivery', False)
            
            try:
                config = StandardDeliveryConfig.objects.filter(is_active=True).first()
                if config:
                    if item_count > 0:
                        item_total = config.price_per_item_cents * item_count
                        base_price_cents = max(item_total, config.minimum_charge_cents)
                        
                        details['item_count'] = item_count
                        details['per_item_rate'] = config.price_per_item_cents / 100
                        details['minimum_charge'] = config.minimum_charge_cents / 100
                    else:
                        base_price_cents = 0
                    
                    # Calculate specialty items with quantities
                    if specialty_items_data:
                        specialty_items_list = []
                        specialty_total_cents = 0
                        
                        for item_data in specialty_items_data:
                            item_id = item_data.get('item_id')
                            quantity = item_data.get('quantity', 1)
                            
                            try:
                                specialty_item = SpecialtyItem.objects.get(id=item_id, is_active=True)
                                item_total = specialty_item.price_cents * quantity
                                specialty_total_cents += item_total
                                
                                specialty_items_list.append({
                                    'name': specialty_item.name,
                                    'price_dollars': specialty_item.price_dollars,
                                    'quantity': quantity,
                                    'subtotal_dollars': item_total / 100
                                })
                            except SpecialtyItem.DoesNotExist:
                                logger.warning(f"Specialty item {item_id} not found")
                                continue
                        
                        base_price_cents += specialty_total_cents
                        details['specialty_items'] = specialty_items_list
                    
                    if is_same_day:
                        same_day_fee_cents = config.same_day_flat_rate_cents
                        details['is_same_day'] = True
                        details['same_day_rate'] = config.same_day_flat_rate_cents / 100
            
            except StandardDeliveryConfig.DoesNotExist:
                return Response({'error': 'Standard delivery not configured'}, status=status.HTTP_400_BAD_REQUEST)
            
            # Apply geographic surcharge for Standard Delivery
            is_outside_core_area = serializer.validated_data.get('is_outside_core_area', False)
            if is_outside_core_area:
                geographic_surcharge_cents = 17500
            
            # Apply COI fee for Standard Delivery
            coi_required = serializer.validated_data.get('coi_required', False)
            if coi_required:
                coi_fee_cents = 5000
        
        # ✅ FIXED: Specialty Item pricing with quantities
        elif service_type == 'specialty_item':
            if serializer.validated_data.get('include_packing') or serializer.validated_data.get('include_unpacking'):
                return Response({
                    'error': 'Organizing services are only available for Mini Move bookings'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            # ✅ Handle specialty_items with quantities
            specialty_items_data = serializer.validated_data.get('specialty_items', [])
            
            if specialty_items_data:
                specialty_items_list = []
                specialty_total_cents = 0
                
                for item_data in specialty_items_data:
                    item_id = item_data.get('item_id')
                    quantity = item_data.get('quantity', 1)
                    
                    try:
                        specialty_item = SpecialtyItem.objects.get(id=item_id, is_active=True)
                        item_total = specialty_item.price_cents * quantity
                        specialty_total_cents += item_total
                        
                        specialty_items_list.append({
                            'name': specialty_item.name,
                            'price_dollars': specialty_item.price_dollars,
                            'quantity': quantity,
                            'subtotal_dollars': item_total / 100
                        })
                    except SpecialtyItem.DoesNotExist:
                        logger.warning(f"Specialty item {item_id} not found")
                        continue
                
                base_price_cents = specialty_total_cents
                details['specialty_items'] = specialty_items_list
            
            # Apply same-day delivery for specialty items
            is_same_day = serializer.validated_data.get('is_same_day_delivery', False)
            if is_same_day:
                try:
                    config = StandardDeliveryConfig.objects.filter(is_active=True).first()
                    if config:
                        same_day_fee_cents = config.same_day_flat_rate_cents
                        details['is_same_day'] = True
                        details['same_day_rate'] = config.same_day_flat_rate_cents / 100
                except StandardDeliveryConfig.DoesNotExist:
                    pass
            
            # Apply geographic surcharge for Specialty Items
            is_outside_core_area = serializer.validated_data.get('is_outside_core_area', False)
            if is_outside_core_area:
                geographic_surcharge_cents = 17500
            
            # Apply COI fee for Specialty Items
            coi_required = serializer.validated_data.get('coi_required', False)
            if coi_required:
                coi_fee_cents = 5000
        
        # Apply surcharges (NOT for BLADE)
        if service_type != 'blade_transfer' and pickup_date and base_price_cents > 0:
            active_surcharges = SurchargeRule.objects.filter(is_active=True)
            surcharge_details = []
            
            for surcharge in active_surcharges:
                surcharge_amount = surcharge.calculate_surcharge(base_price_cents, pickup_date, service_type)
                if surcharge_amount > 0:
                    surcharge_cents += surcharge_amount
                    surcharge_details.append({
                        'name': surcharge.name,
                        'amount_dollars': surcharge_amount / 100,
                        'reason': surcharge.description
                    })
            
            if surcharge_details:
                details['surcharges'] = surcharge_details
        
        total_price_cents = (
            base_price_cents + 
            same_day_fee_cents + 
            surcharge_cents + 
            coi_fee_cents + 
            organizing_total_cents + 
            organizing_tax_cents + 
            geographic_surcharge_cents + 
            time_window_surcharge_cents
        )
        
        return Response({
            'service_type': service_type,
            'pricing': {
                'base_price_dollars': base_price_cents / 100,
                'same_day_delivery_dollars': same_day_fee_cents / 100,
                'surcharge_dollars': surcharge_cents / 100,
                'coi_fee_dollars': coi_fee_cents / 100,
                'organizing_total_dollars': organizing_total_cents / 100,
                'organizing_tax_dollars': organizing_tax_cents / 100,
                'geographic_surcharge_dollars': geographic_surcharge_cents / 100,
                'time_window_surcharge_dollars': time_window_surcharge_cents / 100,
                'total_price_dollars': total_price_cents / 100
            },
            'details': details,
            'pickup_date': pickup_date
        })


class CalendarAvailabilityView(APIView):
    """Calendar data with booking details - no capacity limits"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request):
        start_date = request.query_params.get('start_date', date.today())
        if isinstance(start_date, str):
            start_date = date.fromisoformat(start_date)
        
        end_date_param = request.query_params.get('end_date')
        if end_date_param:
            end_date = date.fromisoformat(end_date_param)
        else:
            end_date = start_date + timedelta(days=60)
        
        availability = []
        current_date = start_date
        
        while current_date <= end_date:
            # ✅ OPTIMIZED: Added select_related to avoid N+1 queries
            bookings_today = Booking.objects.filter(
                pickup_date=current_date,
                deleted_at__isnull=True
            ).select_related(
                'customer',
                'guest_checkout',
                'mini_move_package'
            )
            
            surcharges = []
            for rule in SurchargeRule.objects.filter(is_active=True):
                if rule.applies_to_date(current_date):
                    surcharges.append({
                        'name': rule.name,
                        'type': rule.surcharge_type,
                        'description': rule.description
                    })
            
            booking_list = []
            for booking in bookings_today:
                booking_list.append({
                    'id': str(booking.id),
                    'booking_number': booking.booking_number,
                    'customer_name': booking.get_customer_name(),
                    'service_type': booking.get_service_type_display(),
                    'pickup_time': booking.get_pickup_time_display(),
                    'status': booking.status,
                    'total_price_dollars': booking.total_price_dollars,
                    'coi_required': booking.coi_required
                })
            
            availability.append({
                'date': current_date.isoformat(),
                'available': True,
                'is_weekend': current_date.weekday() >= 5,
                'bookings': booking_list,
                'surcharges': surcharges
            })
            
            current_date += timedelta(days=1)
        
        return Response({
            'availability': availability,
            'start_date': start_date.isoformat(),
            'end_date': end_date.isoformat()
        })


class CreateGuestPaymentIntentView(APIView):
    """
    Create payment intent BEFORE guest booking
    This separates payment from booking creation to avoid pending bookings
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        logger.info("Guest payment intent request received")
        
        serializer = GuestPaymentIntentSerializer(data=request.data)
        
        if not serializer.is_valid():
            logger.warning(f"Guest payment intent validation failed: {serializer.errors}")
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        # Get calculated total from serializer
        validated_data = serializer.validated_data
        amount_cents = validated_data['calculated_total_cents']
        customer_email = validated_data.get('email')
        
        try:
            # Create Stripe payment intent
            payment_intent = stripe.PaymentIntent.create(
                amount=amount_cents,
                currency='usd',
                payment_method_types=['card'],
                metadata={
                    'service_type': validated_data['service_type'],
                    'customer_email': customer_email,
                }
            )
            
            logger.info(f"Payment intent created: {payment_intent.id} for ${amount_cents / 100}")
            
            return Response({
                'client_secret': payment_intent.client_secret,
                'payment_intent_id': payment_intent.id,
                'amount_dollars': amount_cents / 100
            }, status=status.HTTP_200_OK)
            
        except stripe.error.StripeError as e:
            logger.error(f"Stripe error creating payment intent: {str(e)}")
            return Response(
                {'error': f'Payment initialization failed: {str(e)}'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class GuestBookingCreateView(generics.CreateAPIView):
    """
    Create booking for guest AFTER payment succeeds
    Requires payment_intent_id and verifies payment before creating booking
    """
    serializer_class = GuestBookingCreateSerializer
    permission_classes = [permissions.AllowAny]
    
    def create(self, request, *args, **kwargs):
        logger.info(f"Guest booking create request - Service: {request.data.get('service_type')}, Email: {request.data.get('email')}")
        
        # Verify payment_intent_id is provided
        payment_intent_id = request.data.get('payment_intent_id')
        if not payment_intent_id:
            return Response(
                {'error': 'payment_intent_id is required'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Verify payment with Stripe
        try:
            payment_intent = stripe.PaymentIntent.retrieve(payment_intent_id)
            
            if payment_intent.status != 'succeeded':
                logger.warning(f"Payment not succeeded: {payment_intent.status}")
                return Response(
                    {'error': f'Payment has not succeeded. Status: {payment_intent.status}'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            logger.info(f"Payment verified: {payment_intent_id} - ${payment_intent.amount / 100}")
            
        except stripe.error.StripeError as e:
            logger.error(f"Stripe verification failed: {str(e)}")
            return Response(
                {'error': f'Payment verification failed: {str(e)}'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        booking = serializer.save()
        
        # Update booking status to paid since payment already succeeded
        booking.status = 'paid'
        booking.save()
        
        logger.info(f"Guest booking created: {booking.booking_number} - {booking.service_type} - ${booking.total_price_dollars}")
        
        response_data = {
            'message': 'Booking created successfully',
            'booking': {
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'total_price_dollars': booking.total_price_dollars,
                'service_type': booking.service_type,

                
                'status': booking.status,
            }
        }
        
        # Add BLADE-specific response data
        if booking.service_type == 'blade_transfer':
            response_data['booking']['blade_details'] = {
                'airport': booking.blade_airport,
                'bag_count': booking.blade_bag_count,
                'flight_date': booking.blade_flight_date.isoformat() if booking.blade_flight_date else None,
                'ready_time': booking.blade_ready_time.isoformat() if booking.blade_ready_time else None,
            }
        
        return Response(response_data, status=status.HTTP_201_CREATED)


class BookingStatusView(APIView):
    """Get booking status by booking number - no authentication required"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request, booking_number):
        try:
            booking = Booking.objects.get(booking_number=booking_number, deleted_at__isnull=True)
            serializer = BookingStatusSerializer(booking)
            return Response(serializer.data)
        except Booking.DoesNotExist:
            return Response(
                {'error': 'Booking not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )


class OrganizingServiceDetailView(APIView):
    """Get detailed info about a specific organizing service - no authentication required"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request, service_id):
        try:
            organizing_service = OrganizingService.objects.get(id=service_id, is_active=True)
            serializer = OrganizingServiceSerializer(organizing_service)
            return Response(serializer.data)
        except OrganizingService.DoesNotExist:
            return Response(
                {'error': 'Organizing service not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )


class ValidateZipCodeView(APIView):
    """
    Public endpoint to validate a single ZIP code.
    Returns service area information without requiring authentication.
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        from .zip_codes import validate_service_area
        
        zip_code = request.data.get('zip_code')
        
        if not zip_code:
            return Response(
                {'error': 'ZIP code is required'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        is_serviceable, requires_surcharge, zone, error = validate_service_area(zip_code)
        
        return Response({
            'is_serviceable': is_serviceable,
            'requires_surcharge': requires_surcharge,
            'zone': zone,
            'error': error,
            'zip_code': zip_code.split('-')[0].strip()
        })
```

# ==== apps/bookings/zip_codes.py ====

```python
# apps/bookings/zip_codes.py
"""
ToteTaxi Geographic ZIP Code System
Validates service areas and determines surcharge requirements
"""

# Zone 1: CORE AREA (Standard Pricing - No Surcharge)
CORE_AREA_ZIPS = {
    'manhattan': [
        '10001', '10002', '10003', '10004', '10005', '10006', '10007', '10009', '10010', '10011',
        '10012', '10013', '10014', '10016', '10017', '10018', '10019', '10020', '10021', '10022',
        '10023', '10024', '10025', '10026', '10027', '10028', '10029', '10030', '10031', '10032',
        '10033', '10034', '10035', '10036', '10038', '10039', '10040', '10044', '10065', '10069',
        '10075', '10103', '10110', '10111', '10112', '10115', '10119', '10128', '10152', '10153',
        '10154', '10162', '10165', '10167', '10168', '10169', '10170', '10171', '10172', '10173',
        '10174', '10177', '10199', '10271', '10278', '10279', '10280', '10281', '10282'
    ],
    
    'hamptons_west': [
        '11972',  # Speonk
        '11946',  # Hampton Bays
        '11959',  # Quogue
        '11977',  # Westhampton
        '11978',  # Westhampton Beach
        '11968',  # Southampton
        '11976',  # Water Mill
        '11932',  # Bridgehampton
        '11962',  # Sagaponack
        '11963',  # Sag Harbor
        '11975',  # Wainscott
    ],
    
    'brooklyn': [
        '11201', '11203', '11204', '11205', '11206', '11207', '11208', '11209', '11210', '11211',
        '11212', '11213', '11214', '11215', '11216', '11217', '11218', '11219', '11220', '11221',
        '11222', '11223', '11224', '11225', '11226', '11228', '11229', '11230', '11231', '11232',
        '11233', '11234', '11235', '11236', '11237', '11238', '11239', '11241', '11242', '11243',
        '11245', '11247', '11249', '11251', '11252', '11256'
    ]
}

# Zone 2: SURCHARGE AREA (+$175 Distance Fee)
SURCHARGE_AREA_ZIPS = {
    'essex_county_nj': [
        '07003', '07004', '07006', '07007', '07009', '07017', '07018', '07019', '07021', '07028',
        '07039', '07040', '07041', '07042', '07043', '07044', '07050', '07051', '07052', '07068',
        '07078', '07079', '07101', '07102', '07103', '07104', '07105', '07106', '07107', '07108',
        '07109', '07110', '07111', '07112', '07114', '07175', '07184', '07188', '07189', '07191',
        '07192', '07193', '07195', '07198', '07199'
    ],
    
    'union_county_nj': [
        '07016', '07023', '07027', '07033', '07036', '07060', '07062', '07063', '07065', '07066',
        '07076', '07081', '07083', '07088', '07090', '07092', '07201', '07202', '07203', '07204',
        '07205', '07206', '07208', '07901', '07974'
    ],
    
    'morris_county_nj': [
        '07005', '07035', '07054', '07801', '07834', '07856', '07866', '07869', '07928', '07932',
        '07936', '07940', '07950', '07960', '07981'
    ],
    
    'hudson_county_nj': [
        '07002', '07030', '07032', '07047', '07086', '07087', '07093', '07094', '07302', '07304',
        '07305', '07306', '07307', '07310'
    ],
    
    'fairfield_county_ct': [
        '06604', '06605', '06606', '06607', '06608', '06610', '06611', '06612', '06614', '06615',
        '06807', '06820', '06824', '06825', '06830', '06831', '06840', '06850', '06851', '06853',
        '06854', '06855', '06877', '06880', '06883', '06897', '06901', '06902', '06903', '06905',
        '06906', '06907'
    ],
    
    'new_haven_county_ct': [
        '06401', '06418', '06460', '06477', '06484', '06510', '06511', '06512', '06513', '06515',
        '06516', '06519'
    ],
    
    'hamptons_east': [
        '11930',  # Amagansett
        '11954',  # Montauk
        '11964',  # Shelter Island
    ]
}

# Flatten for fast lookup (O(1) set operations)
CORE_AREA_ZIPS_FLAT = set()
for region_zips in CORE_AREA_ZIPS.values():
    CORE_AREA_ZIPS_FLAT.update(region_zips)

SURCHARGE_AREA_ZIPS_FLAT = set()
for region_zips in SURCHARGE_AREA_ZIPS.values():
    SURCHARGE_AREA_ZIPS_FLAT.update(region_zips)


def validate_service_area(zip_code):
    """
    Validate ZIP code and determine surcharge requirement.
    
    Args:
        zip_code (str): ZIP code to validate (can include -XXXX extension)
    
    Returns:
        tuple: (is_serviceable, requires_surcharge, zone_name, error_message)
        
    Examples:
        >>> validate_service_area('10001')
        (True, False, 'core', None)
        
        >>> validate_service_area('07101')
        (True, True, 'surcharge', None)
        
        >>> validate_service_area('11354')
        (False, False, None, 'Sorry, we don\'t service ZIP code 11354...')
    """
    if not zip_code:
        return False, False, None, "ZIP code is required"
    
    # Clean ZIP (remove -XXXX extension if present)
    clean_zip = zip_code.split('-')[0].strip()
    
    # Check core area (no surcharge)
    if clean_zip in CORE_AREA_ZIPS_FLAT:
        return True, False, "core", None
    
    # Check surcharge area (+$175)
    if clean_zip in SURCHARGE_AREA_ZIPS_FLAT:
        return True, True, "surcharge", None
    
    # Not serviceable
    error_msg = (
        f"Sorry, we don't currently service ZIP code {clean_zip}. "
        f"We serve Manhattan, the Hamptons, Brooklyn, and select areas in NJ and CT."
    )
    return False, False, None, error_msg


def get_service_areas():
    """
    Return all service areas for frontend display or admin reference.
    
    Returns:
        dict: Dictionary with core and surcharge area ZIP codes
    """
    return {
        'core_areas': CORE_AREA_ZIPS,
        'surcharge_areas': SURCHARGE_AREA_ZIPS,
        'stats': {
            'core_count': len(CORE_AREA_ZIPS_FLAT),
            'surcharge_count': len(SURCHARGE_AREA_ZIPS_FLAT),
            'total_serviceable': len(CORE_AREA_ZIPS_FLAT) + len(SURCHARGE_AREA_ZIPS_FLAT)
        }
    }
```

# ==== apps/customers/__init__.py ====

```python

```

# ==== apps/customers/admin.py ====

```python
from django.contrib import admin
from django.contrib.auth.models import User
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.core.exceptions import ValidationError
from django.contrib import messages
from .models import CustomerProfile, SavedAddress, CustomerPaymentMethod


class CustomerProfileInline(admin.StackedInline):
    model = CustomerProfile
    can_delete = False
    verbose_name_plural = 'Customer Profile'
    readonly_fields = ('total_bookings', 'total_spent_cents', 'last_booking_at', 'created_at', 'updated_at')
    
    def save_model(self, request, obj, form, change):
        try:
            super().save_model(request, obj, form, change)
        except ValidationError as e:
            messages.error(request, f"Cannot save customer profile: {e}")
            raise


class CustomUserAdmin(BaseUserAdmin):
    inlines = (CustomerProfileInline,)
    
    def get_inline_instances(self, request, obj=None):
        """Only show CustomerProfile inline for users without staff profiles"""
        if obj and hasattr(obj, 'staff_profile'):
            return []
        return super().get_inline_instances(request, obj)


# Re-register UserAdmin
admin.site.unregister(User)
admin.site.register(User, CustomUserAdmin)


@admin.register(CustomerProfile)
class CustomerProfileAdmin(admin.ModelAdmin):
    list_display = ('user', 'user_email', 'total_bookings', 'total_spent_dollars', 'is_vip', 'last_booking_at', 'created_at')
    list_filter = ('is_vip', 'preferred_pickup_time', 'email_notifications', 'created_at')
    search_fields = ('user__email', 'user__first_name', 'user__last_name', 'phone')
    readonly_fields = ('total_bookings', 'total_spent_cents', 'last_booking_at', 'created_at', 'updated_at')
    
    def user_email(self, obj):
        return obj.user.email
    user_email.short_description = 'Email'
    user_email.admin_order_field = 'user__email'
    
    def save_model(self, request, obj, form, change):
        try:
            super().save_model(request, obj, form, change)
        except ValidationError as e:
            messages.error(request, f"Cannot save: {e}")
            raise


@admin.register(SavedAddress)
class SavedAddressAdmin(admin.ModelAdmin):
    list_display = ('user', 'nickname', 'city', 'state', 'times_used', 'is_active', 'created_at')
    list_filter = ('state', 'is_active', 'city', 'created_at')
    search_fields = ('user__email', 'nickname', 'city', 'address_line_1')
    readonly_fields = ('times_used', 'last_used_at', 'created_at', 'updated_at')
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related('user')


@admin.register(CustomerPaymentMethod)
class CustomerPaymentMethodAdmin(admin.ModelAdmin):
    list_display = ('user', 'display_name', 'is_default', 'is_active', 'created_at')
    list_filter = ('card_brand', 'is_default', 'is_active', 'created_at')
    search_fields = ('user__email', 'card_last_four')
    readonly_fields = ('stripe_payment_method_id', 'created_at')
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related('user')
```

# ==== apps/customers/apps.py ====

```python
# apps/customers/apps.py
from django.apps import AppConfig

class CustomersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.customers'  # Change this from 'customers' to 'apps.customers'
```

# ==== apps/customers/authentication.py ====

```python
from rest_framework.authentication import SessionAuthentication
from django.contrib.auth.models import User
from django.contrib.sessions.backends.db import SessionStore
import logging

logger = logging.getLogger(__name__)

class HybridAuthentication(SessionAuthentication):
    """
    Hybrid authentication for mobile compatibility.
    Tries session cookie first (desktop), falls back to X-Session-Id header (mobile).
    """
    
    def authenticate(self, request):
        # Try standard cookie-based session authentication
        user = getattr(request._request, 'user', None)
        
        if user and user.is_authenticated:
            # 🔧 FIX: Ensure related profiles are loaded
            try:
                user = User.objects.select_related('staff_profile', 'customer_profile').get(pk=user.pk)
            except User.DoesNotExist:
                return None
            return (user, None)
        
        # Mobile fallback: check for session ID in custom header
        session_key = request.META.get('HTTP_X_SESSION_ID')
        
        if not session_key:
            return None
        
        logger.info(f"Mobile auth attempt with session: {session_key[:10]}...")
        
        try:
            # Validate session exists and get user
            session = SessionStore(session_key=session_key)
            
            if not session.exists(session_key):
                logger.warning(f"Session does not exist: {session_key[:10]}...")
                return None
            
            user_id = session.get('_auth_user_id')
            
            if not user_id:
                logger.warning(f"No user_id in session: {session_key[:10]}...")
                return None
            
            # 🔧 FIX: Load user with related profiles
            user = User.objects.select_related('staff_profile', 'customer_profile').get(pk=user_id)
            logger.info(f"Mobile auth successful for user: {user.email}")
            return (user, None)
            
        except User.DoesNotExist:
            logger.error(f"User not found for session: {session_key[:10]}...")
            return None
        except Exception as e:
            logger.error(f"Mobile auth error: {str(e)}")
            return None
```

# ==== apps/customers/booking_serializers.py ====

```python
# backend/apps/customers/booking_serializers.py
from rest_framework import serializers
from django.contrib.auth.models import User
from django.utils import timezone
from datetime import timedelta, time as dt_time
from apps.bookings.models import Booking, Address, BookingSpecialtyItem
from apps.payments.models import Payment
from apps.payments.services import StripePaymentService
from .models import CustomerProfile, SavedAddress, CustomerPaymentMethod
import logging
from .serializers import SavedAddressSerializer
from apps.services.models import MiniMovePackage, SpecialtyItem, StandardDeliveryConfig, SurchargeRule

logger = logging.getLogger(__name__)


class OnfleetTaskSerializer(serializers.Serializer):
    """Minimal Onfleet task info for customer delivery tracking"""
    task_type = serializers.CharField()
    tracking_url = serializers.URLField()
    status = serializers.CharField()
    worker_name = serializers.CharField(allow_blank=True)
    completed_at = serializers.DateTimeField(allow_null=True)
    started_at = serializers.DateTimeField(allow_null=True)


class PaymentIntentCreateSerializer(serializers.Serializer):
    """
    Serializer for creating payment intent BEFORE booking
    ✅ NOW SUPPORTS QUANTITIES
    """
    
    service_type = serializers.ChoiceField(choices=[
        ('mini_move', 'Mini Move'),
        ('standard_delivery', 'Standard Delivery'),
        ('specialty_item', 'Specialty Item'),
        ('blade_transfer', 'BLADE Airport Transfer'),
    ])
    
    # Service-specific fields
    mini_move_package_id = serializers.UUIDField(required=False, allow_null=True)
    include_packing = serializers.BooleanField(default=False)
    include_unpacking = serializers.BooleanField(default=False)
    standard_delivery_item_count = serializers.IntegerField(required=False, min_value=0)
    is_same_day_delivery = serializers.BooleanField(default=False)
    
    # ✅ NEW: Specialty items with quantities
    specialty_items = serializers.ListField(
        child=serializers.DictField(),
        required=False,
        allow_empty=True,
        help_text="List of {item_id: UUID, quantity: int}"
    )
    
    # BLADE fields
    blade_airport = serializers.ChoiceField(choices=[('JFK', 'JFK'), ('EWR', 'EWR')], required=False)
    blade_flight_date = serializers.DateField(required=False)
    blade_flight_time = serializers.TimeField(required=False)
    blade_bag_count = serializers.IntegerField(required=False, min_value=2)
    
    pickup_date = serializers.DateField()
    pickup_time = serializers.ChoiceField(choices=[
        ('morning', '8 AM - 11 AM'),
        ('morning_specific', 'Specific 1-hour window'),
        ('no_time_preference', 'No time preference'),
    ], required=False)
    specific_pickup_hour = serializers.IntegerField(required=False, allow_null=True)
    
    customer_email = serializers.EmailField(required=False)
    
    coi_required = serializers.BooleanField(default=False)
    is_outside_core_area = serializers.BooleanField(default=False)
    
    def validate_specialty_items(self, value):
        """Validate specialty items with quantities"""
        if not value:
            return []
        
        for item in value:
            if 'item_id' not in item or 'quantity' not in item:
                raise serializers.ValidationError(
                    "Each specialty item must have 'item_id' and 'quantity'"
                )
            if item['quantity'] < 1:
                raise serializers.ValidationError("Quantity must be at least 1")
        
        return value
    
    def validate(self, attrs):
        service_type = attrs['service_type']
        
        if service_type == 'blade_transfer':
            if not all([attrs.get('blade_airport'), attrs.get('blade_flight_date'), 
                       attrs.get('blade_flight_time'), attrs.get('blade_bag_count')]):
                raise serializers.ValidationError("All BLADE fields are required")
            
            if attrs.get('blade_bag_count', 0) < 2:
                raise serializers.ValidationError("BLADE service requires minimum 2 bags")
        
        elif service_type == 'mini_move':
            if not attrs.get('mini_move_package_id'):
                raise serializers.ValidationError("mini_move_package_id is required")
        
        elif service_type == 'standard_delivery':
            item_count = attrs.get('standard_delivery_item_count', 0)
            specialty_items = attrs.get('specialty_items', [])
            
            if item_count == 0 and len(specialty_items) == 0:
                raise serializers.ValidationError("At least one item required")
        
        elif service_type == 'specialty_item':
            if not attrs.get('specialty_items'):
                raise serializers.ValidationError("specialty_items is required")
        
        # Calculate pricing
        attrs['calculated_total_cents'] = self._calculate_total_price(attrs)
        
        return attrs
    
    def _calculate_total_price(self, data):
        """Calculate total price in cents WITH QUANTITIES"""
        service_type = data['service_type']
        total_cents = 0
        
        # BLADE pricing
        if service_type == 'blade_transfer':
            bag_count = data.get('blade_bag_count', 0)
            per_bag_price = 7500  # $75
            total_cents = max(bag_count * per_bag_price, 15000)  # $150 min
            return total_cents
        
        # Mini Move pricing
        elif service_type == 'mini_move':
            try:
                package = MiniMovePackage.objects.get(id=data['mini_move_package_id'])
                total_cents = package.base_price_cents
                
                if data.get('coi_required') and not package.coi_included:
                    total_cents += package.coi_fee_cents
                
                # Organizing services
                if data.get('include_packing') or data.get('include_unpacking'):
                    from apps.services.models import OrganizingService
                    organizing_total = 0
                    
                    if data.get('include_packing'):
                        packing = OrganizingService.objects.filter(
                            mini_move_tier=package.package_type,
                            is_packing_service=True,
                            is_active=True
                        ).first()
                        if packing:
                            organizing_total += packing.price_cents
                    
                    if data.get('include_unpacking'):
                        unpacking = OrganizingService.objects.filter(
                            mini_move_tier=package.package_type,
                            is_packing_service=False,
                            is_active=True
                        ).first()
                        if unpacking:
                            organizing_total += unpacking.price_cents
                    
                    if organizing_total > 0:
                        total_cents += organizing_total + int(organizing_total * 0.0825)
                
                if data.get('is_outside_core_area'):
                    total_cents += 17500
                
                if data.get('pickup_time') == 'morning_specific' and package.package_type == 'standard':
                    total_cents += 17500
                
            except MiniMovePackage.DoesNotExist:
                raise serializers.ValidationError("Invalid package")
        
        # Standard Delivery pricing - ✅ WITH QUANTITIES
        elif service_type == 'standard_delivery':
            try:
                config = StandardDeliveryConfig.objects.filter(is_active=True).first()
                if config:
                    item_count = data.get('standard_delivery_item_count', 0)
                    if item_count > 0:
                        item_total = config.price_per_item_cents * item_count
                        total_cents = max(item_total, config.minimum_charge_cents)
                    
                    # ✅ Specialty items WITH QUANTITIES
                    specialty_items_data = data.get('specialty_items', [])
                    if specialty_items_data:
                        for item_data in specialty_items_data:
                            try:
                                item = SpecialtyItem.objects.get(id=item_data['item_id'])
                                quantity = item_data['quantity']
                                total_cents += item.price_cents * quantity
                            except SpecialtyItem.DoesNotExist:
                                pass
                    
                    if data.get('is_same_day_delivery'):
                        total_cents += config.same_day_flat_rate_cents
                    
                    if data.get('coi_required'):
                        total_cents += 5000
                    
                    if data.get('is_outside_core_area'):
                        total_cents += 17500
                        
            except StandardDeliveryConfig.DoesNotExist:
                raise serializers.ValidationError("Standard delivery not configured")
        
        # Specialty Item pricing - ✅ WITH QUANTITIES
        elif service_type == 'specialty_item':
            specialty_items_data = data.get('specialty_items', [])
            for item_data in specialty_items_data:
                try:
                    item = SpecialtyItem.objects.get(id=item_data['item_id'])
                    quantity = item_data['quantity']
                    total_cents += item.price_cents * quantity
                except SpecialtyItem.DoesNotExist:
                    pass
            
            if data.get('is_same_day_delivery'):
                try:
                    config = StandardDeliveryConfig.objects.filter(is_active=True).first()
                    if config:
                        total_cents += config.same_day_flat_rate_cents
                except StandardDeliveryConfig.DoesNotExist:
                    pass
            
            if data.get('coi_required'):
                total_cents += 5000
            
            if data.get('is_outside_core_area'):
                total_cents += 17500
        
        # Weekend surcharges (not for BLADE)
        if service_type != 'blade_transfer' and data.get('pickup_date'):
            active_surcharges = SurchargeRule.objects.filter(is_active=True)
            for surcharge in active_surcharges:
                surcharge_amount = surcharge.calculate_surcharge(
                    total_cents,
                    data['pickup_date'],
                    service_type
                )
                total_cents += surcharge_amount
        
        return total_cents


class AuthenticatedBookingCreateSerializer(serializers.Serializer):
    """
    Create booking AFTER payment succeeds
    ✅ NOW SUPPORTS QUANTITIES
    """
    
    payment_intent_id = serializers.CharField(required=True)
    
    service_type = serializers.ChoiceField(choices=[
        ('mini_move', 'Mini Move'),
        ('standard_delivery', 'Standard Delivery'),
        ('specialty_item', 'Specialty Item'),
        ('blade_transfer', 'BLADE Airport Transfer'),
    ])
    
    mini_move_package_id = serializers.UUIDField(required=False, allow_null=True)
    include_packing = serializers.BooleanField(default=False)
    include_unpacking = serializers.BooleanField(default=False)
    standard_delivery_item_count = serializers.IntegerField(required=False, min_value=0)
    is_same_day_delivery = serializers.BooleanField(default=False)
    
    # ✅ NEW: Specialty items with quantities
    specialty_items = serializers.ListField(
        child=serializers.DictField(),
        required=False,
        allow_empty=True
    )
    
    # BLADE fields
    blade_airport = serializers.ChoiceField(choices=[('JFK', 'JFK'), ('EWR', 'EWR')], required=False)
    blade_flight_date = serializers.DateField(required=False)
    blade_flight_time = serializers.TimeField(required=False)
    blade_bag_count = serializers.IntegerField(required=False, min_value=2)
    
    pickup_date = serializers.DateField()
    pickup_time = serializers.ChoiceField(choices=[
        ('morning', '8 AM - 11 AM'),
        ('morning_specific', 'Specific 1-hour window'),
        ('no_time_preference', 'No time preference'),
    ], required=False)
    specific_pickup_hour = serializers.IntegerField(required=False, allow_null=True)
    
    # Address selection
    pickup_address_id = serializers.UUIDField(required=False)
    delivery_address_id = serializers.UUIDField(required=False)
    new_pickup_address = serializers.DictField(required=False)
    new_delivery_address = serializers.DictField(required=False)
    
    # Save addresses
    save_pickup_address = serializers.BooleanField(default=False)
    save_delivery_address = serializers.BooleanField(default=False)
    pickup_address_nickname = serializers.CharField(required=False, max_length=50)
    delivery_address_nickname = serializers.CharField(required=False, max_length=50)
    
    special_instructions = serializers.CharField(required=False, allow_blank=True)
    coi_required = serializers.BooleanField(default=False)
    
    def validate_specialty_items(self, value):
        if not value:
            return []
        
        for item in value:
            if 'item_id' not in item or 'quantity' not in item:
                raise serializers.ValidationError(
                    "Each item needs 'item_id' and 'quantity'"
                )
            if item['quantity'] < 1:
                raise serializers.ValidationError("Quantity must be >= 1")
        
        return value
    
    def validate(self, attrs):
        user = self.context['user']
        service_type = attrs['service_type']
        
        # BLADE validation
        if service_type == 'blade_transfer':
            if not all([attrs.get('blade_airport'), attrs.get('blade_flight_date'), 
                       attrs.get('blade_flight_time'), attrs.get('blade_bag_count')]):
                raise serializers.ValidationError("All BLADE fields required")
            
            if attrs.get('blade_bag_count', 0) < 2:
                raise serializers.ValidationError("Minimum 2 bags")
        
        # Mini Move validation
        elif service_type == 'mini_move':
            if not attrs.get('mini_move_package_id'):
                raise serializers.ValidationError("Package ID required")
        
        # Standard Delivery validation
        elif service_type == 'standard_delivery':
            item_count = attrs.get('standard_delivery_item_count', 0)
            specialty_items = attrs.get('specialty_items', [])
            
            if item_count == 0 and len(specialty_items) == 0:
                raise serializers.ValidationError("At least one item required")
        
        elif service_type == 'specialty_item':
            if not attrs.get('specialty_items'):
                raise serializers.ValidationError("Specialty items required")
        
        # Address validation
        if not (attrs.get('pickup_address_id') or attrs.get('new_pickup_address')):
            raise serializers.ValidationError("pickup address required")
        
        if not (attrs.get('delivery_address_id') or attrs.get('new_delivery_address')):
            raise serializers.ValidationError("delivery address required")
        
        # Validate saved addresses belong to user
        if attrs.get('pickup_address_id'):
            if not user.saved_addresses.filter(id=attrs['pickup_address_id'], is_active=True).exists():
                raise serializers.ValidationError("Invalid pickup address")
        
        if attrs.get('delivery_address_id'):
            if not user.saved_addresses.filter(id=attrs['delivery_address_id'], is_active=True).exists():
                raise serializers.ValidationError("Invalid delivery address")
        
        # Use customer's preferred pickup time if not specified
        if not attrs.get('pickup_time'):
            attrs['pickup_time'] = user.customer_profile.preferred_pickup_time
        
        return attrs
    
    def create(self, validated_data):
        user = self.context['user']
        
        payment_intent_id = validated_data.pop('payment_intent_id')
        
        # Handle addresses
        pickup_address = self._get_or_create_address(
            user,
            validated_data.get('pickup_address_id'),
            validated_data.get('new_pickup_address'),
            validated_data.get('save_pickup_address', False),
            validated_data.get('pickup_address_nickname')
        )
        
        delivery_address = self._get_or_create_address(
            user,
            validated_data.get('delivery_address_id'),
            validated_data.get('new_delivery_address'),
            validated_data.get('save_delivery_address', False),
            validated_data.get('delivery_address_nickname')
        )
        
        # Extract specialty items BEFORE creating booking
        specialty_items_data = validated_data.pop('specialty_items', [])
        
        # Create booking
        booking = Booking.objects.create(
            customer=user,
            service_type=validated_data['service_type'],
            pickup_date=validated_data['pickup_date'],
            pickup_time=validated_data.get('pickup_time', 'morning'),
            specific_pickup_hour=validated_data.get('specific_pickup_hour'),
            pickup_address=pickup_address,
            delivery_address=delivery_address,
            special_instructions=validated_data.get('special_instructions', ''),
            coi_required=validated_data.get('coi_required', False),
            include_packing=validated_data.get('include_packing', False),
            include_unpacking=validated_data.get('include_unpacking', False),
            standard_delivery_item_count=validated_data.get('standard_delivery_item_count'),
            is_same_day_delivery=validated_data.get('is_same_day_delivery', False),
            blade_airport=validated_data.get('blade_airport'),
            blade_flight_date=validated_data.get('blade_flight_date'),
            blade_flight_time=validated_data.get('blade_flight_time'),
            blade_bag_count=validated_data.get('blade_bag_count'),
            status='pending',
        )
        
        # Handle mini move package
        if validated_data['service_type'] == 'mini_move':
            try:
                package = MiniMovePackage.objects.get(id=validated_data['mini_move_package_id'])
                booking.mini_move_package = package
            except MiniMovePackage.DoesNotExist:
                raise serializers.ValidationError("Invalid package")
        
        # ✅ Handle specialty items WITH QUANTITIES
        if specialty_items_data:
            booking.save()  # Save first to get ID
            for item_data in specialty_items_data:
                try:
                    item = SpecialtyItem.objects.get(id=item_data['item_id'])
                    BookingSpecialtyItem.objects.create(
                        booking=booking,
                        specialty_item=item,
                        quantity=item_data['quantity']
                    )
                except SpecialtyItem.DoesNotExist:
                    pass
        
        booking.save()
        return booking
    
    def _get_or_create_address(self, user, address_id, new_address_data, save_address, nickname):
        """Get existing saved address or create new one"""
        if address_id:
            saved_address = user.saved_addresses.get(id=address_id, is_active=True)
            
            address = Address.objects.create(
                customer=user,
                address_line_1=saved_address.address_line_1,
                address_line_2=saved_address.address_line_2,
                city=saved_address.city,
                state=saved_address.state,
                zip_code=saved_address.zip_code
            )
            
            saved_address.mark_used()
            return address
        
        elif new_address_data:
            address = Address.objects.create(
                customer=user,
                **new_address_data
            )
            
            if save_address:
                import uuid
                unique_nickname = nickname or f"Address {str(uuid.uuid4())[:8]}"
                
                SavedAddress.objects.create(
                    user=user,
                    nickname=unique_nickname,
                    address_line_1=new_address_data['address_line_1'],
                    address_line_2=new_address_data.get('address_line_2', ''),
                    city=new_address_data['city'],
                    state=new_address_data['state'],
                    zip_code=new_address_data['zip_code'],
                    delivery_instructions=new_address_data.get('delivery_instructions', ''),
                    times_used=1
                )
            
            return address


class CustomerBookingDetailSerializer(serializers.ModelSerializer):
    """Detailed booking information for authenticated customers"""
    
    customer_name = serializers.SerializerMethodField()
    pickup_address = serializers.SerializerMethodField()
    delivery_address = serializers.SerializerMethodField()
    total_price_dollars = serializers.ReadOnlyField()
    pricing_breakdown = serializers.SerializerMethodField()
    payment_status = serializers.SerializerMethodField()
    can_rebook = serializers.SerializerMethodField()
    onfleet_tasks = serializers.SerializerMethodField()
    
    pickup_date = serializers.DateField(format='%Y-%m-%d')
    blade_flight_date = serializers.DateField(format='%Y-%m-%d', allow_null=True)
    
    class Meta:
        model = Booking
        fields = (
            'id', 'booking_number', 'customer_name', 
            'service_type', 'pickup_date', 'pickup_time', 'status',
            'pickup_address', 'delivery_address',
            'special_instructions', 'coi_required',
            'blade_airport', 'blade_flight_date', 'blade_flight_time', 
            'blade_bag_count', 'blade_ready_time',
            'total_price_dollars', 'pricing_breakdown',
            'payment_status', 'can_rebook', 
            'onfleet_tasks',
            'created_at', 'updated_at'
        )
    
    def get_customer_name(self, obj):
        return obj.get_customer_name()
    
    def get_pickup_address(self, obj):
        return {
            'address_line_1': obj.pickup_address.address_line_1,
            'address_line_2': obj.pickup_address.address_line_2,
            'city': obj.pickup_address.city,
            'state': obj.pickup_address.state,
            'zip_code': obj.pickup_address.zip_code
        }
    
    def get_delivery_address(self, obj):
        return {
            'address_line_1': obj.delivery_address.address_line_1,
            'address_line_2': obj.delivery_address.address_line_2,
            'city': obj.delivery_address.city,
            'state': obj.delivery_address.state,
            'zip_code': obj.delivery_address.zip_code
        }
    
    def get_pricing_breakdown(self, obj):
        return obj.get_pricing_breakdown()
    
    def get_payment_status(self, obj):
        payment = obj.payments.first()
        return payment.status if payment else 'not_created'
    
    def get_can_rebook(self, obj):
        return obj.status in ['completed', 'paid']
    
    def get_onfleet_tasks(self, obj):
        """Return onfleet tasks for delivery tracking"""
        tasks = obj.onfleet_tasks.all().order_by('task_type')
        return OnfleetTaskSerializer(tasks, many=True).data


class QuickBookingSerializer(serializers.Serializer):
    """Serializer for quickly rebooking with minimal changes"""
    pickup_date = serializers.DateField()
    pickup_time = serializers.ChoiceField(
        choices=[
            ('morning', '8 AM - 11 AM'),
            ('morning_specific', 'Specific 1-hour window'),
            ('no_time_preference', 'No time preference'),
        ],
        required=False
    )
    is_same_day_delivery = serializers.BooleanField(default=False)
    special_instructions = serializers.CharField(required=False, allow_blank=True)
    coi_required = serializers.BooleanField(required=False)
```

# ==== apps/customers/booking_views.py ====

```python
# backend/apps/customers/booking_views.py
from rest_framework import generics, status, permissions
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.shortcuts import get_object_or_404
from django.utils import timezone
from django.conf import settings
import logging
import json
import stripe

from .models import CustomerProfile, SavedAddress, CustomerPaymentMethod
from apps.bookings.models import Booking, Address
from apps.payments.models import Payment
from apps.payments.services import StripePaymentService
from .emails import send_booking_confirmation_email
from .serializers import SavedAddressSerializer
from .booking_serializers import (
    AuthenticatedBookingCreateSerializer,
    CustomerBookingDetailSerializer,
    QuickBookingSerializer,
    PaymentIntentCreateSerializer
)

logger = logging.getLogger(__name__)

# Initialize Stripe
stripe.api_key = settings.STRIPE_SECRET_KEY


class CreatePaymentIntentView(APIView):
    """
    Create payment intent BEFORE booking
    This separates payment from booking creation to avoid pending bookings
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        logger.info("Payment intent request received")
        
        serializer = PaymentIntentCreateSerializer(
            data=request.data,
            context={'user': request.user if request.user.is_authenticated else None}
        )
        
        if not serializer.is_valid():
            logger.warning(f"Payment intent validation failed: {serializer.errors}")
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        # Calculate total amount from validated data
        validated_data = serializer.validated_data
        amount_cents = validated_data['calculated_total_cents']
        customer_email = validated_data.get('customer_email')
        
        try:
            # Create Stripe payment intent
            payment_intent = stripe.PaymentIntent.create(
                amount=amount_cents,
                currency='usd',
                payment_method_types=['card'],
                metadata={
                    'service_type': validated_data['service_type'],
                    'customer_email': customer_email,
                }
            )
            
            logger.info(f"Payment intent created: {payment_intent.id} for ${amount_cents / 100}")
            
            return Response({
                'client_secret': payment_intent.client_secret,
                'payment_intent_id': payment_intent.id,
                'amount_dollars': amount_cents / 100
            }, status=status.HTTP_200_OK)
            
        except stripe.error.StripeError as e:
            logger.error(f"Stripe error creating payment intent: {str(e)}")
            return Response(
                {'error': f'Payment initialization failed: {str(e)}'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class CustomerBookingCreateView(APIView):
    """
    Create booking AFTER payment succeeds
    Requires payment_intent_id and verifies payment before creating booking
    """
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        logger.info(f"Booking create request from user: {request.user.email}")
        
        # Ensure user has customer profile
        if not hasattr(request.user, 'customer_profile'):
            logger.warning(f"User {request.user.email} has no customer profile")
            return Response(
                {'error': 'This is not a customer account'}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        # Verify payment_intent_id is provided
        payment_intent_id = request.data.get('payment_intent_id')
        if not payment_intent_id:
            return Response(
                {'error': 'payment_intent_id is required'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Verify payment with Stripe
        try:
            payment_intent = stripe.PaymentIntent.retrieve(payment_intent_id)
            
            if payment_intent.status != 'succeeded':
                logger.warning(f"Payment not succeeded for {request.user.email}: {payment_intent.status}")
                return Response(
                    {'error': f'Payment has not succeeded. Status: {payment_intent.status}'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            logger.info(f"Payment verified: {payment_intent_id} - ${payment_intent.amount / 100}")
            
        except stripe.error.StripeError as e:
            logger.error(f"Stripe verification failed: {str(e)}")
            return Response(
                {'error': f'Payment verification failed: {str(e)}'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        serializer = AuthenticatedBookingCreateSerializer(
            data=request.data,
            context={'user': request.user}
        )
        
        if not serializer.is_valid():
            logger.warning(f"Booking validation failed for {request.user.email}: {serializer.errors}")
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            booking = serializer.save()
            logger.info(f"Booking created: {booking.booking_number} by {request.user.email}")
            
            # Create payment record immediately
            payment, created = Payment.objects.get_or_create(
                stripe_payment_intent_id=payment_intent_id,
                defaults={
                    'booking': booking,
                    'amount_cents': payment_intent.amount,
                    'status': 'succeeded',
                    'stripe_charge_id': payment_intent.get('latest_charge', ''),
                    'processed_at': timezone.now()
                }
            )
            
            if created:
                logger.info(f"Payment record created for booking {booking.booking_number}")
            else:
                logger.info(f"Payment record already exists for booking {booking.booking_number}")
            
            # Update booking status to paid since payment already succeeded
            booking.status = 'paid'
            booking.save()

            # REMOVED THESE 2 LINES:
            
        except Exception as e:
            logger.error(f"Error creating booking for {request.user.email}: {str(e)}", exc_info=True)
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
        response_data = {
            'message': 'Booking created successfully',
            'booking': CustomerBookingDetailSerializer(booking).data
        }
        
        return Response(response_data, status=status.HTTP_201_CREATED)


class QuickRebookView(APIView):
    """Quickly rebook a previous booking with minimal changes"""
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request, booking_id):
        try:
            original_booking = Booking.objects.get(
                id=booking_id,
                customer=request.user,
                deleted_at__isnull=True
            )
        except Booking.DoesNotExist:
            return Response(
                {'error': 'Original booking not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        
        serializer = QuickBookingSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        # Calculate pricing for payment intent
        new_booking_data = {
            'service_type': original_booking.service_type,
            'mini_move_package_id': str(original_booking.mini_move_package.id) if original_booking.mini_move_package else None,
            'standard_delivery_item_count': original_booking.standard_delivery_item_count,
            'is_same_day_delivery': serializer.validated_data.get('is_same_day_delivery', False),
            'pickup_date': serializer.validated_data['pickup_date'],
            'coi_required': serializer.validated_data.get('coi_required', original_booking.coi_required),
        }
        
        return Response({
            'message': 'Ready to create payment',
            'booking_data': new_booking_data
        }, status=status.HTTP_200_OK)


class CustomerBookingDetailView(generics.RetrieveAPIView):
    """Get detailed booking information for authenticated customer"""
    serializer_class = CustomerBookingDetailSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        # ✅ OPTIMIZED: Added select_related and prefetch_related
        return self.request.user.bookings.filter(
            deleted_at__isnull=True
        ).select_related(
            'mini_move_package',
            'pickup_address',
            'delivery_address',
            'guest_checkout'
        ).prefetch_related(
            'specialty_items',
            'onfleet_tasks'
        )
    
    def get_object(self):
        booking_id = self.kwargs.get('booking_id')
        return get_object_or_404(self.get_queryset(), id=booking_id)


class CustomerDashboardView(APIView):
    """Enhanced customer dashboard with booking insights"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        if not hasattr(request.user, 'customer_profile'):
            return Response(
                {'error': 'This is not a customer account'}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        customer_profile = request.user.customer_profile
        
        # ✅ OPTIMIZED: Added select_related and prefetch_related to avoid N+1 queries
        all_bookings = request.user.bookings.filter(
            deleted_at__isnull=True,
            status__in=['paid', 'confirmed', 'completed']
        ).select_related(
            'mini_move_package',
            'pickup_address',
            'delivery_address',
            'guest_checkout'
        ).prefetch_related(
            'specialty_items',
            'onfleet_tasks'
        ).order_by('-created_at')
        
        recent_bookings = all_bookings[:5]
        
        pending_bookings = all_bookings.filter(status__in=['confirmed']).count()
        completed_bookings = all_bookings.filter(status='completed').count()
        
        saved_addresses = request.user.saved_addresses.filter(is_active=True)
        payment_methods = request.user.payment_methods.filter(is_active=True)
        
        popular_addresses = saved_addresses.order_by('-times_used')[:3]
        
        return Response({
            'customer_profile': {
                'name': request.user.get_full_name(),
                'email': request.user.email,
                'phone': customer_profile.phone,
                'is_vip': customer_profile.is_vip,
                'total_bookings': customer_profile.total_bookings,
                'total_spent_dollars': customer_profile.total_spent_dollars,
                'last_booking_at': customer_profile.last_booking_at
            },
            'booking_summary': {
                'pending_bookings': pending_bookings,
                'completed_bookings': completed_bookings,
                'total_bookings': all_bookings.count()
            },
            'recent_bookings': CustomerBookingDetailSerializer(recent_bookings, many=True).data,
            'saved_addresses_count': saved_addresses.count(),
            'payment_methods_count': payment_methods.count(),
            'popular_addresses': SavedAddressSerializer(popular_addresses, many=True).data
        })


class BookingPreferencesView(APIView):
    """Manage customer booking preferences"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        customer_profile = request.user.customer_profile
        
        return Response({
            'preferred_pickup_time': customer_profile.preferred_pickup_time,
            'email_notifications': customer_profile.email_notifications,
            'sms_notifications': customer_profile.sms_notifications,
            'default_addresses': {
                'most_used_pickup': self._get_most_used_address('pickup'),
                'most_used_delivery': self._get_most_used_address('delivery')
            }
        })
    
    def _get_most_used_address(self, address_type):
        most_used = self.request.user.saved_addresses.filter(is_active=True).order_by('-times_used').first()
        return SavedAddressSerializer(most_used).data if most_used else None
```

# ==== apps/customers/emails.py ====

```python
import logging
from django.conf import settings
from django.core.mail import send_mail, EmailMessage
from django.template.loader import render_to_string
from django.utils import timezone

logger = logging.getLogger(__name__)


def send_welcome_email(user):
    """Send welcome email to newly registered customer"""
    try:
        subject = 'Welcome to Tote Taxi!'
        context = {
            'user_name': user.get_full_name() or user.email,
            'email': user.email,
        }
        message = render_to_string('emails/welcome.txt', context)

        send_mail(
            subject=subject,
            message=message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[user.email],
            fail_silently=False,
        )
        logger.info(f'Welcome email sent to {user.email}')
        return True
    except Exception as e:
        logger.error(f'Failed to send welcome email to {user.email}: {str(e)}', exc_info=True)
        return False


def send_password_reset_email(user, reset_token, reset_url):
    """Send password reset email"""
    try:
        subject = 'Reset Your Tote Taxi Password'
        context = {
            'user_name': user.get_full_name() or user.email,
            'reset_url': reset_url,
            'reset_token': reset_token,
        }
        message = render_to_string('emails/password_reset.txt', context)

        send_mail(
            subject=subject,
            message=message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[user.email],
            fail_silently=False,
        )
        logger.info(f'Password reset email sent to {user.email}')
        return True
    except Exception as e:
        logger.error(f'Failed to send password reset email to {user.email}: {str(e)}', exc_info=True)
        return False


def send_booking_confirmation_email(booking):
    """
    Send booking confirmation email:
    - To: customer
    - BCC: internal list (BOOKING_EMAIL_BCC)
    """
    try:
        subject = f'Booking Confirmation - {booking.booking_number}'
        context = {
            'booking': booking,
            'customer_name': booking.get_customer_name(),
            'customer_email': booking.get_customer_email(),
        }
        message = render_to_string('emails/booking_confirmation.txt', context)

        to_addr = [booking.get_customer_email()]
        bcc_list = getattr(settings, 'BOOKING_EMAIL_BCC', [])

        email = EmailMessage(
            subject=subject,
            body=message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            to=to_addr,
            bcc=bcc_list,
        )
        email.content_subtype = 'plain'
        email.send(fail_silently=False)

        logger.info(
            f'Booking confirmation sent for {booking.booking_number} '
            f"(bcc={','.join(bcc_list) if bcc_list else 'none'})"
        )
        return True
    except Exception as e:
        logger.error(
            f'Failed to send booking confirmation for {booking.booking_number}: {str(e)}',
            exc_info=True
        )
        return False


def send_booking_status_update_email(booking, old_status, new_status):
    """Send email when booking status changes"""
    try:
        subject = f'Booking Update - {booking.booking_number}'
        context = {
            'booking': booking,
            'customer_name': booking.get_customer_name(),
            'old_status': old_status,
            'new_status': new_status,
        }
        message = render_to_string('emails/booking_status_update.txt', context)

        send_mail(
            subject=subject,
            message=message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[booking.get_customer_email()],
            fail_silently=False,
        )
        logger.info(f'Status update email sent for {booking.booking_number}')
        return True
    except Exception as e:
        logger.error(f'Failed to send status update for {booking.booking_number}: {str(e)}', exc_info=True)
        return False


def send_email_verification(user, token, verify_url):
    """Send email verification link"""
    try:
        subject = 'Verify Your Tote Taxi Account'
        context = {
            'user_name': user.get_full_name() or user.email,
            'verify_url': verify_url,
        }
        message = render_to_string('emails/email_verification.txt', context)

        send_mail(
            subject=subject,
            message=message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[user.email],
            fail_silently=False,
        )
        logger.info(f'Verification email sent to {user.email}')
        return True
    except Exception as e:
        logger.error(f'Failed to send verification email to {user.email}: {str(e)}', exc_info=True)
        return False


def send_booking_reminder_email(booking):
    """Send 24-hour reminder email before pickup"""
    try:
        # Already sent?
        if booking.reminder_sent_at:
            logger.info(f'Reminder already sent for {booking.booking_number} at {booking.reminder_sent_at}')
            return False

        # Tracking if available
        has_tracking = False
        tracking_url = ''
        if hasattr(booking, 'onfleet_tasks'):
            pickup_task = booking.onfleet_tasks.filter(task_type='pickup').first()
            if pickup_task and pickup_task.tracking_url:
                has_tracking = True
                tracking_url = pickup_task.tracking_url

        subject = f'Reminder: Your Tote Taxi Pickup is Tomorrow! - {booking.booking_number}'
        context = {
            'booking': booking,
            'customer_name': booking.get_customer_name(),
            'has_tracking': has_tracking,
            'tracking_url': tracking_url,
        }
        message = render_to_string('emails/booking_reminder.txt', context)

        send_mail(
            subject=subject,
            message=message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[booking.get_customer_email()],
            fail_silently=False,
        )

        booking.reminder_sent_at = timezone.now()
        booking.save(update_fields=['reminder_sent_at'])

        logger.info(f'✓ Reminder email sent for {booking.booking_number}')
        return True

    except Exception as e:
        logger.error(f'Failed to send reminder for {booking.booking_number}: {str(e)}', exc_info=True)
        return False
```

# ==== apps/customers/management/__init__.py ====

```python

```

# ==== apps/customers/management/commands/__init__.py ====

```python

```

# ==== apps/customers/management/commands/clean_delete_user.py ====

```python
from django.core.management.base import BaseCommand
from django.contrib.auth.models import User
from apps.bookings.models import Booking, GuestCheckout
from apps.payments.models import Payment
from django.db import transaction


class Command(BaseCommand):
    help = 'Completely delete a user and all associated data for clean testing'
    
    def add_arguments(self, parser):
        parser.add_argument('email', type=str, help='Email of user to delete')
        parser.add_argument(
            '--dry-run', 
            action='store_true',
            help='Show what would be deleted without actually deleting'
        )
    
    def handle(self, *args, **options):
        email = options['email']
        dry_run = options['dry_run']
        
        if dry_run:
            self.stdout.write(self.style.WARNING(f"DRY RUN - No data will actually be deleted"))
        
        self.stdout.write(f"🔍 Searching for user: {email}")
        
        # Track what we'll delete
        deletion_summary = {
            'users': 0,
            'bookings': 0,
            'payments': 0,
            'guest_checkouts': 0,
            'saved_addresses': 0,
            'payment_methods': 0
        }
        
        with transaction.atomic():
            # Find authenticated user
            try:
                user = User.objects.get(email__iexact=email)
                self.stdout.write(f"✅ Found user: {user.get_full_name()} (ID: {user.id})")
                
                # Check profile type
                if hasattr(user, 'customer_profile'):
                    self.stdout.write("   👤 Customer Profile")
                    deletion_summary['saved_addresses'] = user.saved_addresses.count()
                    deletion_summary['payment_methods'] = user.payment_methods.count()
                
                if hasattr(user, 'staff_profile'):
                    self.stdout.write("   👮 Staff Profile")
                
                # Count bookings
                user_bookings = user.bookings.all()
                deletion_summary['bookings'] = user_bookings.count()
                
                # Count payments
                booking_ids = [str(b.id) for b in user_bookings]
                user_payments = Payment.objects.filter(booking_id__in=booking_ids)
                deletion_summary['payments'] = user_payments.count()
                
                if not dry_run:
                    # Delete user (cascades to profile, bookings, addresses, etc.)
                    user.delete()
                    deletion_summary['users'] = 1
                    self.stdout.write(self.style.SUCCESS(f"✅ Deleted authenticated user and cascaded data"))
                else:
                    self.stdout.write(f"   Would delete user and {deletion_summary['bookings']} bookings")
            
            except User.DoesNotExist:
                self.stdout.write("❌ No authenticated user found with that email")
            
            # Find guest checkout records
            guest_checkouts = GuestCheckout.objects.filter(email__iexact=email)
            deletion_summary['guest_checkouts'] = guest_checkouts.count()
            
            if guest_checkouts.exists():
                self.stdout.write(f"✅ Found {guest_checkouts.count()} guest checkout records")
                
                if not dry_run:
                    # Delete associated bookings first, then guest records
                    for guest in guest_checkouts:
                        if hasattr(guest, 'booking') and guest.booking:
                            guest.booking.delete()
                    guest_checkouts.delete()
                    self.stdout.write(self.style.SUCCESS("✅ Deleted guest checkout records"))
                else:
                    self.stdout.write(f"   Would delete {guest_checkouts.count()} guest records")
            
            # Raise exception to rollback if dry run
            if dry_run:
                self.stdout.write(self.style.WARNING("DRY RUN - Rolling back transaction"))
                raise transaction.TransactionManagementError("Dry run - rollback")
        
        # Print summary
        self.stdout.write("\n" + "="*50)
        if dry_run:
            self.stdout.write(self.style.WARNING("📋 WOULD DELETE:"))
        else:
            self.stdout.write(self.style.SUCCESS("📋 DELETED:"))
        
        self.stdout.write(f"   👤 Users: {deletion_summary['users']}")
        self.stdout.write(f"   📦 Bookings: {deletion_summary['bookings']}")  
        self.stdout.write(f"   💳 Payments: {deletion_summary['payments']}")
        self.stdout.write(f"   👻 Guest Checkouts: {deletion_summary['guest_checkouts']}")
        self.stdout.write(f"   📍 Saved Addresses: {deletion_summary['saved_addresses']}")
        self.stdout.write(f"   💰 Payment Methods: {deletion_summary['payment_methods']}")
        
        if not dry_run:
            self.stdout.write(self.style.SUCCESS(f"\n🧹 Email {email} completely cleaned from system"))
        else:
            self.stdout.write(self.style.WARNING(f"\n🔍 Run without --dry-run to actually delete"))
```

# ==== apps/customers/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.5 on 2025-09-02 20:54

import django.core.validators
import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='CustomerPaymentMethod',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('stripe_payment_method_id', models.CharField(max_length=100, unique=True)),
                ('card_brand', models.CharField(max_length=20)),
                ('card_last_four', models.CharField(max_length=4)),
                ('card_exp_month', models.PositiveSmallIntegerField()),
                ('card_exp_year', models.PositiveSmallIntegerField()),
                ('is_default', models.BooleanField(default=False)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='payment_methods', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'customers_payment_method',
            },
        ),
        migrations.CreateModel(
            name='CustomerProfile',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('phone', models.CharField(blank=True, max_length=20, validators=[django.core.validators.RegexValidator(regex='^\\+?1?\\d{9,15}$')])),
                ('stripe_customer_id', models.CharField(blank=True, max_length=100)),
                ('total_bookings', models.PositiveIntegerField(default=0)),
                ('total_spent_cents', models.PositiveBigIntegerField(default=0)),
                ('last_booking_at', models.DateTimeField(blank=True, null=True)),
                ('preferred_pickup_time', models.CharField(choices=[('morning', '8 AM - 11 AM'), ('afternoon', '12 PM - 3 PM'), ('evening', '4 PM - 7 PM')], default='morning', max_length=20)),
                ('email_notifications', models.BooleanField(default=True)),
                ('sms_notifications', models.BooleanField(default=False)),
                ('is_vip', models.BooleanField(default=False)),
                ('notes', models.TextField(blank=True, help_text='Internal notes for staff')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='customer_profile', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'customers_profile',
            },
        ),
        migrations.CreateModel(
            name='SavedAddress',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('nickname', models.CharField(max_length=50)),
                ('address_line_1', models.CharField(max_length=200)),
                ('address_line_2', models.CharField(blank=True, max_length=200)),
                ('city', models.CharField(max_length=100)),
                ('state', models.CharField(choices=[('NY', 'New York'), ('CT', 'Connecticut'), ('NJ', 'New Jersey')], max_length=2)),
                ('zip_code', models.CharField(max_length=10)),
                ('delivery_instructions', models.TextField(blank=True)),
                ('times_used', models.PositiveIntegerField(default=0)),
                ('last_used_at', models.DateTimeField(blank=True, null=True)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='saved_addresses', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'customers_saved_address',
                'constraints': [models.UniqueConstraint(fields=('user', 'nickname'), name='unique_customer_address_nickname')],
            },
        ),
    ]
```

# ==== apps/customers/migrations/0002_alter_customerprofile_preferred_pickup_time.py ====

```python
# Generated by Django 5.2.5 on 2025-09-19 23:12

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('customers', '0001_initial'),
    ]

    operations = [
        migrations.AlterField(
            model_name='customerprofile',
            name='preferred_pickup_time',
            field=models.CharField(choices=[('morning', '8 AM - 11 AM'), ('morning_specific', 'Specific 1-hour window'), ('no_time_preference', 'No time preference')], default='morning', max_length=30),
        ),
    ]
```

# ==== apps/customers/migrations/0003_passwordresettoken.py ====

```python
# Generated by Django 5.2.5 on 2025-10-04 17:36

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('customers', '0002_alter_customerprofile_preferred_pickup_time'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='PasswordResetToken',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('token', models.CharField(max_length=100, unique=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('expires_at', models.DateTimeField()),
                ('used', models.BooleanField(default=False)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='password_reset_tokens', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'ordering': ['-created_at'],
            },
        ),
    ]
```

# ==== apps/customers/migrations/0004_emailverificationtoken.py ====

```python
# Generated by Django 5.2.5 on 2025-10-04 18:04

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('customers', '0003_passwordresettoken'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='EmailVerificationToken',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('token', models.CharField(max_length=100, unique=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('expires_at', models.DateTimeField()),
                ('verified', models.BooleanField(default=False)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='email_verification', to=settings.AUTH_USER_MODEL)),
            ],
        ),
    ]
```

# ==== apps/customers/migrations/0005_customerpaymentmethod_payment_method_user_idx_and_more.py ====

```python
# Generated by Django 5.2.5 on 2025-10-20 18:33

from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('customers', '0004_emailverificationtoken'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AddIndex(
            model_name='customerpaymentmethod',
            index=models.Index(fields=['user', 'is_active'], name='payment_method_user_idx'),
        ),
        migrations.AddIndex(
            model_name='customerpaymentmethod',
            index=models.Index(fields=['stripe_payment_method_id'], name='payment_method_stripe_idx'),
        ),
        migrations.AddIndex(
            model_name='customerprofile',
            index=models.Index(fields=['user'], name='customer_profile_user_idx'),
        ),
        migrations.AddIndex(
            model_name='customerprofile',
            index=models.Index(fields=['stripe_customer_id'], name='customer_stripe_idx'),
        ),
        migrations.AddIndex(
            model_name='customerprofile',
            index=models.Index(fields=['is_vip'], name='customer_vip_idx'),
        ),
        migrations.AddIndex(
            model_name='emailverificationtoken',
            index=models.Index(fields=['token'], name='email_verify_token_idx'),
        ),
        migrations.AddIndex(
            model_name='emailverificationtoken',
            index=models.Index(fields=['verified', 'expires_at'], name='email_verify_status_idx'),
        ),
        migrations.AddIndex(
            model_name='passwordresettoken',
            index=models.Index(fields=['token'], name='password_reset_token_idx'),
        ),
        migrations.AddIndex(
            model_name='passwordresettoken',
            index=models.Index(fields=['user', 'used'], name='password_reset_user_idx'),
        ),
        migrations.AddIndex(
            model_name='savedaddress',
            index=models.Index(fields=['user', 'is_active'], name='saved_addr_user_active_idx'),
        ),
        migrations.AddIndex(
            model_name='savedaddress',
            index=models.Index(fields=['times_used'], name='saved_addr_usage_idx'),
        ),
        migrations.AddIndex(
            model_name='savedaddress',
            index=models.Index(fields=['user', 'last_used_at'], name='saved_addr_recent_idx'),
        ),
    ]
```

# ==== apps/customers/migrations/__init__.py ====

```python

```

# ==== apps/customers/models.py ====

```python
import uuid
from django.contrib.auth.models import User
from django.db import models
from django.core.validators import RegexValidator
from django.core.exceptions import ValidationError
from django.utils import timezone
import secrets
from datetime import timedelta

class EmailVerificationToken(models.Model):
    """Email verification tokens for new registrations"""
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='email_verification')
    token = models.CharField(max_length=100, unique=True)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField()
    verified = models.BooleanField(default=False)
    
    class Meta:
        # ✅ OPTIMIZED: Added indexes for token lookups
        indexes = [
            models.Index(fields=['token'], name='email_verify_token_idx'),
            models.Index(fields=['verified', 'expires_at'], name='email_verify_status_idx'),
        ]
    
    @classmethod
    def create_token(cls, user):
        """Create verification token"""
        token = secrets.token_urlsafe(32)
        expires_at = timezone.now() + timedelta(hours=48)
        return cls.objects.create(
            user=user,
            token=token,
            expires_at=expires_at
        )
    
    def is_valid(self):
        """Check if token is still valid"""
        from django.utils import timezone
        return not self.verified and timezone.now() < self.expires_at

class PasswordResetToken(models.Model):
    """Password reset tokens with expiry"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='password_reset_tokens')
    token = models.CharField(max_length=100, unique=True)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField()
    used = models.BooleanField(default=False)
    
    class Meta:
        ordering = ['-created_at']
        # ✅ OPTIMIZED: Added indexes for password reset
        indexes = [
            models.Index(fields=['token'], name='password_reset_token_idx'),
            models.Index(fields=['user', 'used'], name='password_reset_user_idx'),
        ]
    
    def __str__(self):
        return f'Reset token for {self.user.email}'
    
    @classmethod
    def create_token(cls, user):
        """Create a new password reset token"""
        token = secrets.token_urlsafe(32)
        expires_at = timezone.now() + timedelta(hours=24)
        return cls.objects.create(
            user=user,
            token=token,
            expires_at=expires_at
        )
    
    def is_valid(self):
        """Check if token is still valid"""
        return not self.used and timezone.now() < self.expires_at

class CustomerProfile(models.Model):
    """Customer profile linked to Django's User model"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='customer_profile')
    
    # Customer-specific fields
    phone = models.CharField(
        max_length=20, 
        validators=[RegexValidator(regex=r'^\+?1?\d{9,15}$')],
        blank=True
    )
    stripe_customer_id = models.CharField(max_length=100, blank=True)
    
    # Booking statistics
    total_bookings = models.PositiveIntegerField(default=0)
    total_spent_cents = models.PositiveBigIntegerField(default=0)
    last_booking_at = models.DateTimeField(null=True, blank=True)
    
    # Customer preferences - UPDATED: Only morning pickup time
    preferred_pickup_time = models.CharField(
        max_length=30,
        choices=[
            ('morning', '8 AM - 11 AM'),
            ('morning_specific', 'Specific 1-hour window'),
            ('no_time_preference', 'No time preference'),
        ],
        default='morning'
    )
    
    email_notifications = models.BooleanField(default=True)
    sms_notifications = models.BooleanField(default=False)
    is_vip = models.BooleanField(default=False)
    notes = models.TextField(blank=True, help_text="Internal notes for staff")
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'customers_profile'
        # ✅ OPTIMIZED: Added indexes for customer queries
        indexes = [
            models.Index(fields=['user'], name='customer_profile_user_idx'),
            models.Index(fields=['stripe_customer_id'], name='customer_stripe_idx'),
            models.Index(fields=['is_vip'], name='customer_vip_idx'),
        ]
    
    def clean(self):
        """Prevent hybrid accounts - users cannot have both staff and customer profiles"""
        if self.user and hasattr(self.user, 'staff_profile'):
            raise ValidationError(
                f"User {self.user.email} already has a staff profile. "
                "Users cannot have both staff and customer profiles."
            )
    
    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)
    
    def __str__(self):
        return f"Profile: {self.user.get_full_name()}"
    
    @property
    def total_spent_dollars(self):
        return self.total_spent_cents / 100
    
    def add_booking_stats(self, booking_total_cents):
        """Update customer statistics after booking completion"""
        self.total_bookings += 1
        self.total_spent_cents += booking_total_cents
        self.last_booking_at = timezone.now()
        self.save()

    @classmethod
    def ensure_single_profile_type(cls, user):
        """Ensure user only has one type of profile"""
        if hasattr(user, 'staff_profile') and hasattr(user, 'customer_profile'):
            raise ValidationError(
                f"User {user.email} cannot have both staff and customer profiles. "
                "Please remove one profile type."
            )


class SavedAddress(models.Model):
    """Customer's saved addresses"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='saved_addresses')
    
    nickname = models.CharField(max_length=50)
    address_line_1 = models.CharField(max_length=200)
    address_line_2 = models.CharField(max_length=200, blank=True)
    city = models.CharField(max_length=100)
    state = models.CharField(max_length=2, choices=[
        ('NY', 'New York'),
        ('CT', 'Connecticut'), 
        ('NJ', 'New Jersey'),
    ])
    zip_code = models.CharField(max_length=10)
    delivery_instructions = models.TextField(blank=True)
    
    times_used = models.PositiveIntegerField(default=0)
    last_used_at = models.DateTimeField(null=True, blank=True)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'customers_saved_address'
        constraints = [
            models.UniqueConstraint(
                fields=['user', 'nickname'], 
                name='unique_customer_address_nickname'
            )
        ]
        # ✅ OPTIMIZED: Added indexes for address queries
        indexes = [
            models.Index(fields=['user', 'is_active'], name='saved_addr_user_active_idx'),  # Booking flow
            models.Index(fields=['times_used'], name='saved_addr_usage_idx'),  # Popular addresses
            models.Index(fields=['user', 'last_used_at'], name='saved_addr_recent_idx'),  # Recent addresses
        ]
    
    def __str__(self):
        return f"{self.user.get_full_name()} - {self.nickname}"
    
    @property
    def formatted_address(self):
        parts = [
            self.address_line_1,
            self.address_line_2,
            f"{self.city}, {self.state} {self.zip_code}"
        ]
        return ', '.join(filter(None, parts))
    
    def mark_used(self):
        self.times_used += 1
        self.last_used_at = timezone.now()
        self.save()


class CustomerPaymentMethod(models.Model):
    """Customer's saved payment methods"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='payment_methods')
    
    stripe_payment_method_id = models.CharField(max_length=100, unique=True)
    card_brand = models.CharField(max_length=20)
    card_last_four = models.CharField(max_length=4)
    card_exp_month = models.PositiveSmallIntegerField()
    card_exp_year = models.PositiveSmallIntegerField()
    is_default = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'customers_payment_method'
        # ✅ OPTIMIZED: Added indexes for payment method queries
        indexes = [
            models.Index(fields=['user', 'is_active'], name='payment_method_user_idx'),
            models.Index(fields=['stripe_payment_method_id'], name='payment_method_stripe_idx'),
        ]
    
    def __str__(self):
        return f"{self.user.get_full_name()} - {self.card_brand} ****{self.card_last_four}"
    
    @property
    def display_name(self):
        return f"{self.card_brand.title()} ending in {self.card_last_four}"
    
    def save(self, *args, **kwargs):
        if self.is_default:
            CustomerPaymentMethod.objects.filter(
                user=self.user, 
                is_default=True
            ).exclude(id=self.id).update(is_default=False)
        super().save(*args, **kwargs)
```

# ==== apps/customers/serializers.py ====

```python
from rest_framework import serializers
from django.contrib.auth.models import User
from django.contrib.auth import authenticate
from django.core.exceptions import ValidationError
from .models import CustomerProfile, SavedAddress, CustomerPaymentMethod


class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ('id', 'username', 'email', 'first_name', 'last_name', 'date_joined')
        read_only_fields = ('id', 'username', 'date_joined')


class CustomerProfileSerializer(serializers.ModelSerializer):
    user = UserSerializer(read_only=True)
    total_spent_dollars = serializers.ReadOnlyField()
    
    class Meta:
        model = CustomerProfile
        fields = (
            'id', 'user', 'phone', 'total_bookings', 'total_spent_cents', 
            'total_spent_dollars', 'last_booking_at', 'preferred_pickup_time',
            'email_notifications', 'sms_notifications', 'is_vip'
        )
        read_only_fields = ('id', 'total_bookings', 'total_spent_cents', 'last_booking_at', 'is_vip')


class CustomerRegistrationSerializer(serializers.Serializer):
    email = serializers.EmailField()
    password = serializers.CharField(min_length=8, write_only=True)
    password_confirm = serializers.CharField(write_only=True)
    first_name = serializers.CharField(max_length=150)
    last_name = serializers.CharField(max_length=150)
    phone = serializers.CharField(max_length=20, required=False, allow_blank=True)
    
    def validate(self, attrs):
        if attrs['password'] != attrs['password_confirm']:
            raise serializers.ValidationError("Passwords don't match")
        
        # Check if email already exists
        if User.objects.filter(email__iexact=attrs['email']).exists():
            existing_user = User.objects.get(email__iexact=attrs['email'])
            if hasattr(existing_user, 'staff_profile'):
                raise serializers.ValidationError("This email is already registered as a staff account. Please use a different email.")
            else:
                raise serializers.ValidationError("User with this email already exists")
        
        return attrs
    
    def create(self, validated_data):
        # Remove password_confirm from validated_data
        validated_data.pop('password_confirm')
        phone = validated_data.pop('phone', '')
        
        try:
            # Create User (use email as username for customers)
            user = User.objects.create_user(
                username=validated_data['email'],
                email=validated_data['email'],
                password=validated_data['password'],
                first_name=validated_data['first_name'],
                last_name=validated_data['last_name']
            )
            
            # Create CustomerProfile with validation
            CustomerProfile.objects.create(
                user=user,
                phone=phone
            )
            
            return user
            
        except ValidationError as e:
            # Clean up user if profile creation fails
            if 'user' in locals():
                user.delete()
            raise serializers.ValidationError(str(e))


class CustomerLoginSerializer(serializers.Serializer):
    email = serializers.EmailField()
    password = serializers.CharField(write_only=True)
    
    def validate(self, attrs):
        email = attrs.get('email')
        password = attrs.get('password')
        
        if email and password:
            # Authenticate using email (stored as username for customers)
            user = authenticate(username=email, password=password)
            
            if user:
                if not user.is_active:
                    raise serializers.ValidationError("User account is disabled")
                
                # Ensure user has a customer profile (not staff)
                if not hasattr(user, 'customer_profile'):
                    if hasattr(user, 'staff_profile'):
                        raise serializers.ValidationError("This is a staff account. Please use the staff login.")
                    else:
                        raise serializers.ValidationError("This is not a customer account")
                
                # Additional hybrid account check
                try:
                    CustomerProfile.ensure_single_profile_type(user)
                except ValidationError as e:
                    raise serializers.ValidationError(str(e))
                
                attrs['user'] = user
                return attrs
            else:
                raise serializers.ValidationError("Invalid email or password")
        else:
            raise serializers.ValidationError("Must include email and password")


class SavedAddressSerializer(serializers.ModelSerializer):
    formatted_address = serializers.ReadOnlyField()
    
    class Meta:
        model = SavedAddress
        fields = (
            'id', 'nickname', 'address_line_1', 'address_line_2', 
            'city', 'state', 'zip_code', 'delivery_instructions',
            'formatted_address', 'times_used', 'last_used_at', 'is_active'
        )
        read_only_fields = ('id', 'times_used', 'last_used_at')


class CustomerPaymentMethodSerializer(serializers.ModelSerializer):
    display_name = serializers.ReadOnlyField()
    
    class Meta:
        model = CustomerPaymentMethod
        fields = (
            'id', 'stripe_payment_method_id', 'card_brand', 'card_last_four',
            'card_exp_month', 'card_exp_year', 'display_name', 'is_default', 'is_active'
        )
        read_only_fields = ('id', 'stripe_payment_method_id')
```

# ==== apps/customers/tests/__init__.py ====

```python

```

# ==== apps/customers/tests/test_api.py ====

```python
# backend/apps/customers/tests/test_api.py
import pytest
from django.contrib.auth.models import User
from rest_framework.test import APIClient
from apps.customers.models import CustomerProfile, EmailVerificationToken


@pytest.fixture
def api_client():
    return APIClient()


@pytest.fixture
def verified_user(db):
    """Create a verified user with customer profile"""
    user = User.objects.create_user(
        username='test@example.com',  # ← FIX: Use email as username
        email='test@example.com',
        password='testpass123',
        first_name='Test',
        last_name='User',
        is_active=True
    )
    CustomerProfile.objects.create(user=user, phone='5551234567')
    return user


@pytest.mark.django_db
class TestAuthenticationAPI:
    """Test authentication endpoints"""
    
    def test_registration_success(self, api_client):
        """Test successful registration"""
        response = api_client.post('/api/customer/auth/register/', {
            'first_name': 'New',
            'last_name': 'User',
            'email': 'newuser@example.com',
            'phone': '5559876543',
            'password': 'newpass123',
            'password_confirm': 'newpass123'
        })
        
        assert response.status_code == 201
        assert 'message' in response.data
        assert 'verify' in response.data['message'].lower()
        
        # User should exist but be inactive
        user = User.objects.get(email='newuser@example.com')
        assert not user.is_active
        assert hasattr(user, 'customer_profile')
    
    def test_registration_duplicate_email(self, api_client, verified_user):
        """Test registration with duplicate email fails"""
        response = api_client.post('/api/customer/auth/register/', {
            'first_name': 'Duplicate',
            'last_name': 'User',
            'email': verified_user.email,
            'phone': '5559876543',
            'password': 'newpass123',
            'password_confirm': 'newpass123'
        })
        
        assert response.status_code == 400
    
    def test_registration_password_mismatch(self, api_client):
        """Test password confirmation validation"""
        response = api_client.post('/api/customer/auth/register/', {
            'first_name': 'Test',
            'last_name': 'User',
            'email': 'test@example.com',
            'phone': '5551234567',
            'password': 'password123',
            'password_confirm': 'different123'
        })
        
        assert response.status_code == 400
        assert 'password' in str(response.data).lower()
    
    def test_login_success(self, api_client, verified_user):
        """Test successful login"""
        # Get CSRF token first
        csrf_response = api_client.get('/api/customer/csrf-token/')
        csrf_token = csrf_response.data['csrf_token']
        
        response = api_client.post('/api/customer/auth/login/', {
            'email': 'test@example.com',
            'password': 'testpass123'
        }, HTTP_X_CSRFTOKEN=csrf_token)
        
        assert response.status_code == 200
        assert 'user' in response.data
        assert 'customer_profile' in response.data
        assert 'csrf_token' in response.data
    
    def test_login_unverified_user(self, api_client, db):
        """Test login with unverified email fails"""
        user = User.objects.create_user(
            username='unverified',
            email='unverified@example.com',
            password='testpass123',
            is_active=False
        )
        CustomerProfile.objects.create(user=user, phone='5551234567')
        
        # Get CSRF token first
        csrf_response = api_client.get('/api/customer/csrf-token/')
        csrf_token = csrf_response.data['csrf_token']
        
        response = api_client.post('/api/customer/auth/login/', {
            'email': 'unverified@example.com',
            'password': 'testpass123'
        }, HTTP_X_CSRFTOKEN=csrf_token)
        
        assert response.status_code == 400
        # Check for error message (could be 'error' or 'non_field_errors')
        error_msg = str(response.data).lower()
        assert 'verify' in error_msg or 'email' in error_msg
    
    def test_login_invalid_credentials(self, api_client, verified_user):
        """Test login with wrong password fails"""
        # Get CSRF token first
        csrf_response = api_client.get('/api/customer/csrf-token/')
        csrf_token = csrf_response.data['csrf_token']
        
        response = api_client.post('/api/customer/auth/login/', {
            'email': 'test@example.com',
            'password': 'wrongpassword'
        }, HTTP_X_CSRFTOKEN=csrf_token)
        
        assert response.status_code == 400
    
    def test_password_reset_request(self, api_client, verified_user):
        """Test password reset request"""
        response = api_client.post('/api/customer/auth/password-reset/', {
            'email': 'test@example.com'
        })
        
        assert response.status_code == 200
        assert 'message' in response.data
        
        # Token should be created
        from apps.customers.models import PasswordResetToken
        token = PasswordResetToken.objects.filter(user=verified_user).first()
        assert token is not None
        assert token.is_valid()
    
    def test_password_reset_nonexistent_email(self, api_client):
        """Test password reset with non-existent email (security)"""
        response = api_client.post('/api/customer/auth/password-reset/', {
            'email': 'nonexistent@example.com'
        })
        
        # Should return 200 to not reveal if email exists
        assert response.status_code == 200
    
    def test_email_verification(self, api_client, db):
        """Test email verification endpoint"""
        user = User.objects.create_user(
            username='unverified',
            email='unverified@example.com',
            password='testpass123',
            is_active=False
        )
        CustomerProfile.objects.create(user=user, phone='5551234567')
        token = EmailVerificationToken.create_token(user)
        
        response = api_client.post('/api/customer/auth/verify-email/', {
            'token': token.token
        })
        
        assert response.status_code == 200
        user.refresh_from_db()
        assert user.is_active
    
    def test_current_user_authenticated(self, api_client, verified_user):
        """Test getting current user when authenticated"""
        api_client.force_authenticate(user=verified_user)
        
        response = api_client.get('/api/customer/auth/user/')
        
        assert response.status_code == 200
        assert response.data['user']['email'] == verified_user.email
    
    def test_current_user_unauthenticated(self, api_client):
        """Test getting current user when not authenticated"""
        response = api_client.get('/api/customer/auth/user/')
        
        assert response.status_code == 403


@pytest.mark.django_db
class TestProfileAPI:
    """Test customer profile endpoints"""
    
    def test_get_profile(self, api_client, verified_user):
        """Test getting customer profile"""
        api_client.force_authenticate(user=verified_user)
        
        response = api_client.get('/api/customer/profile/')
        
        assert response.status_code == 200
        assert response.data['phone'] == '5551234567'
    
    def test_update_profile(self, api_client, verified_user):
        """Test updating customer profile"""
        api_client.force_authenticate(user=verified_user)
        
        response = api_client.patch('/api/customer/profile/', {
            'phone': '5559999999',
            'email_notifications': False
        })
        
        assert response.status_code == 200
        verified_user.customer_profile.refresh_from_db()
        assert verified_user.customer_profile.phone == '5559999999'
        assert not verified_user.customer_profile.email_notifications
```

# ==== apps/customers/tests/test_emails.py ====

```python
# backend/apps/customers/tests/test_emails.py
import pytest
from django.core import mail
from django.contrib.auth.models import User
from django.utils import timezone
from datetime import timedelta
from apps.customers.emails import (
    send_welcome_email,
    send_password_reset_email,
    send_email_verification,
    send_booking_confirmation_email,
    send_booking_status_update_email,
    send_booking_reminder_email
)
from apps.customers.models import CustomerProfile, EmailVerificationToken, PasswordResetToken
from apps.bookings.models import Booking, Address, GuestCheckout
from unittest.mock import patch


@pytest.fixture
def test_user(db):
    """Create test user with customer profile"""
    user = User.objects.create_user(
        username='testuser',
        email='test@example.com',
        password='testpass123',
        first_name='Test',
        last_name='User'
    )
    CustomerProfile.objects.create(
        user=user,
        phone='5551234567'
    )
    return user


@pytest.fixture
def test_address(db):
    """Create test address"""
    return Address.objects.create(
        address_line_1='123 Test St',
        city='New York',
        state='NY',
        zip_code='10001'
    )


@pytest.fixture
def test_booking_with_guest(db, test_address):
    """Create test booking with guest checkout"""
    # Create second address for delivery
    delivery_address = Address.objects.create(
        address_line_1='456 Delivery Ave',
        city='New York',
        state='NY',
        zip_code='10002'
    )
    
    # Create guest checkout
    guest = GuestCheckout.objects.create(
        first_name='Guest',
        last_name='User',
        email='guest@example.com',
        phone='5559876543'
    )
    
    # Create booking
    booking = Booking.objects.create(
        guest_checkout=guest,
        service_type='mini_move',
        pickup_address=test_address,
        delivery_address=delivery_address,
        pickup_date=timezone.now().date() + timedelta(days=1),
        total_price_cents=99500,
        status='confirmed'
    )
    return booking


@pytest.mark.django_db
class TestEmailFunctions:
    """Test email sending functions"""
    
    def setup_method(self):
        """Clear mail outbox before each test"""
        mail.outbox = []
    
    def test_welcome_email_sent(self, test_user):
        """Test welcome email is sent with correct content"""
        result = send_welcome_email(test_user)
        
        assert result is True
        assert len(mail.outbox) == 1
        
        email = mail.outbox[0]
        assert email.subject == 'Welcome to Tote Taxi!'
        assert email.to == ['test@example.com']
        assert 'Test User' in email.body or 'test@example.com' in email.body
        assert 'Tote Taxi' in email.body
    
    def test_welcome_email_handles_no_name(self, db):
        """Test welcome email works when user has no full name"""
        user = User.objects.create_user(
            username='noname',
            email='noname@example.com',
            password='testpass123'
        )
        
        result = send_welcome_email(user)
        
        assert result is True
        assert len(mail.outbox) == 1
        assert 'noname@example.com' in mail.outbox[0].body
    
    def test_email_verification_sent(self, test_user):
        """Test verification email is sent with token"""
        token = EmailVerificationToken.create_token(test_user)
        verify_url = f"https://totetaxi.netlify.app/verify-email?token={token.token}"
        
        result = send_email_verification(test_user, token.token, verify_url)
        
        assert result is True
        assert len(mail.outbox) == 1
        
        email = mail.outbox[0]
        assert email.subject == 'Verify Your Tote Taxi Account'
        assert email.to == ['test@example.com']
        assert verify_url in email.body
        assert token.token in email.body
        assert '48 hours' in email.body
    
    def test_password_reset_email_sent(self, test_user):
        """Test password reset email with token"""
        token = PasswordResetToken.create_token(test_user)
        reset_url = f"https://totetaxi.netlify.app/reset-password?token={token.token}"
        
        result = send_password_reset_email(test_user, token.token, reset_url)
        
        assert result is True
        assert len(mail.outbox) == 1
        
        email = mail.outbox[0]
        assert email.subject == 'Reset Your Tote Taxi Password'
        assert email.to == ['test@example.com']
        assert reset_url in email.body
        assert '24 hours' in email.body
    
    def test_booking_confirmation_email(self, test_booking_with_guest):
        """Test booking confirmation email"""
        booking = test_booking_with_guest
        
        result = send_booking_confirmation_email(booking)
        
        assert result is True
        assert len(mail.outbox) == 1
        
        email = mail.outbox[0]
        assert booking.booking_number in email.subject
        assert email.to == ['guest@example.com']
        assert booking.booking_number in email.body
        assert '123 Test St' in email.body
        assert '456 Delivery Ave' in email.body
    
    def test_booking_status_update_email(self, test_booking_with_guest):
        """Test booking status update email"""
        booking = test_booking_with_guest
        
        result = send_booking_status_update_email(
            booking, 
            old_status='pending', 
            new_status='confirmed'
        )
        
        assert result is True
        assert len(mail.outbox) == 1
        
        email = mail.outbox[0]
        assert 'Update' in email.subject
        assert email.to == ['guest@example.com']
        assert 'pending' in email.body.lower()
        assert 'confirmed' in email.body.lower()
    
    def test_booking_reminder_email(self, test_booking_with_guest):
        """Test 24-hour reminder email"""
        booking = test_booking_with_guest
        
        result = send_booking_reminder_email(booking)
        
        assert result is True
        assert len(mail.outbox) == 1
        
        email = mail.outbox[0]
        assert 'Reminder' in email.subject
        assert 'Tomorrow' in email.subject or 'tomorrow' in email.body.lower()
        assert email.to == ['guest@example.com']
        
        # Check reminder timestamp was set
        booking.refresh_from_db()
        assert booking.reminder_sent_at is not None
    
    def test_reminder_not_sent_twice(self, db, test_address):
        """Test reminder email is not sent twice"""
        delivery_address = Address.objects.create(
            address_line_1='456 Delivery Ave',
            city='New York',
            state='NY',
            zip_code='10002'
        )
        
        guest = GuestCheckout.objects.create(
            first_name='Guest',
            last_name='User',
            email='guest@example.com',
            phone='5559876543'
        )
        
        booking = Booking.objects.create(
            guest_checkout=guest,
            service_type='mini_move',
            pickup_address=test_address,
            delivery_address=delivery_address,
            pickup_date=timezone.now().date() + timedelta(days=1),
            total_price_cents=99500,
            status='confirmed',
            reminder_sent_at=timezone.now()  # Already sent
        )
        
        result = send_booking_reminder_email(booking)
        
        assert result is False
        assert len(mail.outbox) == 0
    
    @patch('apps.customers.emails.send_mail')
    def test_email_failure_handling(self, mock_send_mail, test_user):
        """Test email failure is handled gracefully"""
        mock_send_mail.side_effect = Exception("SMTP Error")
        
        result = send_welcome_email(test_user)
        
        assert result is False


@pytest.mark.django_db
class TestEmailContent:
    """Test email content and formatting"""
    
    def setup_method(self):
        mail.outbox = []
    
    def test_email_has_from_address(self, test_user):
        """Test all emails have correct from address"""
        send_welcome_email(test_user)
        
        email = mail.outbox[0]
        assert 'totetaxi.com' in email.from_email.lower()
    
    def test_email_is_plain_text(self, test_user):
        """Test emails are plain text (not HTML)"""
        send_welcome_email(test_user)
        
        email = mail.outbox[0]
        assert email.content_subtype == 'plain'
    
    def test_verification_url_format(self, test_user):
        """Test verification URL is properly formatted"""
        token = EmailVerificationToken.create_token(test_user)
        verify_url = f"https://totetaxi.netlify.app/verify-email?token={token.token}"
        
        send_email_verification(test_user, token.token, verify_url)
        
        email = mail.outbox[0]
        assert 'https://' in email.body
        assert 'totetaxi.netlify.app' in email.body
        assert f'token={token.token}' in email.body
    
    def test_no_html_in_plain_text(self, test_user):
        """Test plain text emails don't contain HTML tags"""
        send_welcome_email(test_user)
        
        email = mail.outbox[0]
        assert '<html>' not in email.body.lower()
        assert '<body>' not in email.body.lower()
        assert '<p>' not in email.body
```

# ==== apps/customers/tests/test_security.py ====

```python
# backend/apps/customers/tests/test_security.py
import pytest
from rest_framework.test import APIClient
from django.contrib.auth.models import User
from apps.customers.models import CustomerProfile
from apps.accounts.models import StaffProfile


@pytest.fixture
def api_client():
    return APIClient()


@pytest.mark.django_db
class TestRateLimiting:
    """Test rate limiting on critical endpoints"""
    
    @pytest.mark.skip(reason="Rate limiting not configured in test environment")
    def test_password_reset_rate_limit(self, api_client):
        """Test password reset is rate limited (10/hour)"""
        # Make 11 requests
        for i in range(11):
            response = api_client.post('/api/customer/auth/password-reset/', {
                'email': f'test{i}@example.com'
            })
            
            if i < 10:
                assert response.status_code == 200
            else:
                # 11th request should be rate limited
                assert response.status_code == 429


@pytest.mark.django_db
class TestAuthenticationSecurity:
    """Test authentication security measures"""
    
    def test_cannot_have_both_customer_and_staff_profile(self, db):
        """Test hybrid accounts are prevented"""
        user = User.objects.create_user(
            username='hybrid@example.com',
            email='hybrid@example.com',
            password='testpass123'
        )
        
        # Create customer profile
        CustomerProfile.objects.create(user=user, phone='5551234567')
        
        # Trying to create staff profile should fail
        with pytest.raises(Exception):
            StaffProfile.objects.create(
                user=user,
                role='staff',
                phone='5559876543'
            )
    
    def test_staff_cannot_login_as_customer(self, api_client, db):
        """Test staff accounts cannot use customer login"""
        user = User.objects.create_user(
            username='staff@example.com',
            email='staff@example.com',
            password='testpass123',
            is_active=True
        )
        StaffProfile.objects.create(user=user, role='staff', phone='5551234567')
        
        # Get CSRF token
        csrf_response = api_client.get('/api/customer/csrf-token/')
        csrf_token = csrf_response.data['csrf_token']
        
        response = api_client.post('/api/customer/auth/login/', {
            'email': 'staff@example.com',
            'password': 'testpass123'
        }, HTTP_X_CSRFTOKEN=csrf_token)
        
        assert response.status_code == 400
        assert 'staff' in str(response.data).lower()
    
    def test_customer_profile_validation(self, db):
        """Test customer profile prevents hybrid accounts"""
        user = User.objects.create_user(
            username='test@example.com',
            email='test@example.com',
            password='testpass123'
        )
        
        # Create staff profile first
        StaffProfile.objects.create(user=user, role='staff', phone='5551234567')
        
        # Customer profile creation should fail
        with pytest.raises(Exception):
            CustomerProfile.objects.create(user=user, phone='5559876543')
```

# ==== apps/customers/tests/test_ses_integration.py ====

```python
# backend/apps/customers/tests/test_ses_integration.py
import pytest
from django.core import mail
from django.conf import settings
from django.contrib.auth.models import User
from apps.customers.emails import send_welcome_email
from apps.customers.models import CustomerProfile


@pytest.fixture
def test_user(db):
    """Create test user"""
    user = User.objects.create_user(
        username='testuser',
        email='test@example.com',
        password='testpass123',
        first_name='Test',
        last_name='User'
    )
    CustomerProfile.objects.create(
        user=user,
        phone='5551234567'
    )
    return user


@pytest.mark.django_db
@pytest.mark.skipif(
    settings.EMAIL_BACKEND == 'django.core.mail.backends.console.EmailBackend',
    reason="SES integration tests only run with SES backend"
)
class TestSESIntegration:
    """Test SES-specific email behavior"""
    
    def setup_method(self):
        """Clear mail outbox before each test"""
        mail.outbox = []
    
    def test_email_from_verified_sender(self, test_user):
        """Test emails are from verified SES sender"""
        send_welcome_email(test_user)
        
        email = mail.outbox[0]
        # In production, ensure from_email matches SES verified identity
        assert 'totetaxi.com' in email.from_email.lower()
    
    def test_email_headers_for_ses(self, test_user):
        """Test email has proper headers for SES"""
        send_welcome_email(test_user)
        
        email = mail.outbox[0]
        # Basic email structure required by SES
        assert email.subject
        assert email.body
        assert email.to
        assert email.from_email


@pytest.mark.django_db
class TestEmailValidation:
    """Test email addresses are valid before sending"""
    
    def setup_method(self):
        """Clear mail outbox before each test"""
        mail.outbox = []
    
    def test_invalid_email_format(self, db):
        """Test handling of invalid email addresses"""
        # Django's User model will validate email on save
        # This test ensures our email functions handle edge cases
        user = User.objects.create_user(
            username='invaliduser',
            email='test@example.com',  # Valid email (Django validates on create)
            password='testpass123'
        )
        
        # Change email to invalid after creation to test error handling
        user.email = 'invalid-email'
        
        # Test that send_welcome_email handles this gracefully
        result = send_welcome_email(user)
        
        # Depending on your email backend, this might:
        # - Return False (handled gracefully)
        # - Raise an exception (caught by logger)
        # Either way, it shouldn't crash
        assert isinstance(result, bool)
```

# ==== apps/customers/urls.py ====

```python
# backend/apps/customers/urls.py
from django.urls import path
from . import views, booking_views

# API patterns with both authentication and booking functionality
urlpatterns = [
    # CSRF token endpoint
    path('csrf-token/', views.CSRFTokenView.as_view(), name='csrf-token'),
    
    # Authentication endpoints
    path('auth/register/', views.CustomerRegistrationView.as_view(), name='customer-register'),
    path('auth/login/', views.CustomerLoginView.as_view(), name='customer-login'),
    path('auth/logout/', views.CustomerLogoutView.as_view(), name='customer-logout'),
    path('auth/user/', views.CurrentUserView.as_view(), name='current-user'),
    
    # Password reset endpoints
    path('auth/password-reset/', views.PasswordResetRequestView.as_view(), name='password-reset-request'),
    path('auth/password-reset/confirm/', views.PasswordResetConfirmView.as_view(), name='password-reset-confirm'),
    
    # Profile management
    path('profile/', views.CustomerProfileView.as_view(), name='customer-profile'),
    path('addresses/', views.SavedAddressListCreateView.as_view(), name='saved-addresses'),
    path('addresses/<uuid:pk>/', views.SavedAddressDetailView.as_view(), name='saved-address-detail'),
    
    # Enhanced customer dashboard and preferences
    path('dashboard/', booking_views.CustomerDashboardView.as_view(), name='customer-dashboard'),
    path('preferences/', booking_views.BookingPreferencesView.as_view(), name='booking-preferences'),
    
    # Authenticated booking management
    path('bookings/', views.CustomerBookingListView.as_view(), name='customer-bookings'),
    
    # ✅ NEW: Payment intent creation (BEFORE booking)
    path('bookings/create-payment-intent/', booking_views.CreatePaymentIntentView.as_view(), name='create-payment-intent'),
    
    # Booking creation (NOW requires payment_intent_id)
    path('bookings/create/', booking_views.CustomerBookingCreateView.as_view(), name='customer-booking-create'),
    path('bookings/<uuid:booking_id>/', booking_views.CustomerBookingDetailView.as_view(), name='customer-booking-detail'),
    path('bookings/<uuid:booking_id>/rebook/', booking_views.QuickRebookView.as_view(), name='quick-rebook'),
    
    # Staff-only customer notes management
    path('<int:customer_id>/notes/', views.CustomerNotesUpdateView.as_view(), name='customer-notes-update'),
    path('auth/verify-email/', views.EmailVerificationView.as_view(), name='email-verification'),
    path('auth/resend-verification/', views.ResendVerificationView.as_view(), name='resend-verification'),
    path('contact/', views.ContactFormView.as_view(), name='contact-form'),

]
```

# ==== apps/customers/views.py ====

```python
from rest_framework import generics, status, permissions
from django.conf import settings
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.contrib.auth import login, logout
from django.contrib.auth.models import User
from django.middleware.csrf import get_token
from django.views.decorators.csrf import ensure_csrf_cookie, csrf_exempt
from django.utils.decorators import method_decorator
from django.core.exceptions import ValidationError
from django_ratelimit.decorators import ratelimit
from django.core.mail import send_mail

from .emails import send_welcome_email, send_password_reset_email, send_email_verification
from .models import CustomerProfile, SavedAddress, PasswordResetToken, EmailVerificationToken
from .serializers import (
    CustomerRegistrationSerializer, 
    CustomerLoginSerializer,
    CustomerProfileSerializer,
    UserSerializer,
    SavedAddressSerializer
)


@method_decorator(ratelimit(key='ip', rate='5/m', method='POST', block=True), name='create')
@method_decorator(ratelimit(key='header:user-agent', rate='10/m', method='POST', block=True), name='create')
@method_decorator(ensure_csrf_cookie, name='dispatch')
class CustomerRegistrationView(generics.CreateAPIView):
    """Register new customer account - requires email verification"""
    serializer_class = CustomerRegistrationSerializer
    permission_classes = [permissions.AllowAny]
    
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        email = serializer.validated_data['email']
        try:
            existing_user = User.objects.get(email__iexact=email)
            if hasattr(existing_user, 'staff_profile'):
                return Response(
                    {'error': 'This email is already registered as a staff account. Please use a different email or contact support.'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            # If user exists but not verified, resend verification
            if not existing_user.is_active and hasattr(existing_user, 'email_verification'):
                verification_token = existing_user.email_verification
                if not verification_token.verified:
                    # Resend verification email
                    frontend_url = settings.FRONTEND_URL or 'https://totetaxi.netlify.app'
                    verify_url = f'{frontend_url}/verify-email?token={verification_token.token}'
                    send_email_verification(existing_user, verification_token.token, verify_url)
                    return Response({
                        'message': 'A verification email has been sent. Please check your inbox.'
                    }, status=status.HTTP_200_OK)
        except User.DoesNotExist:
            pass
        
        try:
            # Create inactive user
            user = serializer.save()
            user.is_active = False  # Inactive until email verified
            user.save()
            
            # Create verification token
            verification_token = EmailVerificationToken.create_token(user)
            
            # Send verification email
            frontend_url = settings.FRONTEND_URL or 'https://totetaxi.netlify.app'
            verify_url = f'{frontend_url}/verify-email?token={verification_token.token}'
            send_email_verification(user, verification_token.token, verify_url)
            
        except ValidationError as e:
            return Response(
                {'error': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        return Response({
            'message': 'Registration successful! Please check your email to verify your account.',
            'email': user.email
        }, status=status.HTTP_201_CREATED)
@method_decorator(ratelimit(key='ip', rate='10/m', method='POST', block=True), name='post')
@method_decorator(ratelimit(key='header:user-agent', rate='15/m', method='POST', block=True), name='post')
@method_decorator(ensure_csrf_cookie, name='dispatch')
class CustomerLoginView(APIView):
    """Customer login endpoint with profile type validation and rate limiting"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = CustomerLoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        user = serializer.validated_data['user']
        
        # Ensure user has customer profile (not staff)
        if not hasattr(user, 'customer_profile'):
            if hasattr(user, 'staff_profile'):
                return Response(
                    {'error': 'This is a staff account. Please use the staff login.'},
                    status=status.HTTP_403_FORBIDDEN
                )
            else:
                return Response(
                    {'error': 'Account does not have a customer profile.'},
                    status=status.HTTP_403_FORBIDDEN
                )
        
        # Additional security: Check for hybrid accounts
        try:
            CustomerProfile.ensure_single_profile_type(user)
        except ValidationError as e:
            return Response(
                {'error': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        login(request, user)
        
        return Response({
            'message': 'Login successful',
            'user': UserSerializer(user).data,
            'customer_profile': CustomerProfileSerializer(user.customer_profile).data,
            'session_id': request.session.session_key,
            'csrf_token': get_token(request)
        })
    
@method_decorator(ratelimit(key='ip', rate='10/h', method='POST', block=True), name='post')
class EmailVerificationView(APIView):
    """Verify email with token"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        token = request.data.get('token', '').strip()
        
        if not token:
            return Response(
                {'error': 'Verification token is required'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            verification = EmailVerificationToken.objects.get(token=token)
            
            if not verification.is_valid():
                return Response(
                    {'error': 'This verification link has expired. Please register again.'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Activate user
            user = verification.user
            user.is_active = True
            user.save()
            
            # Mark as verified
            verification.verified = True
            verification.save()
            
            # Send welcome email now
            send_welcome_email(user)
            
            return Response({
                'message': 'Email verified successfully! You can now log in.',
                'email': user.email
            })
            
        except EmailVerificationToken.DoesNotExist:
            return Response(
                {'error': 'Invalid verification link.'},
                status=status.HTTP_400_BAD_REQUEST
            )

@method_decorator(ratelimit(key='ip', rate='3/h', method='POST', block=True), name='post')
class ResendVerificationView(APIView):
    """Resend verification email - rate limited to prevent abuse"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        email = request.data.get('email', '').strip().lower()
        
        if not email:
            return Response(
                {'error': 'Email is required'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            user = User.objects.get(email__iexact=email)
            
            # Check if user is already active
            if user.is_active:
                return Response({
                    'message': 'This account is already verified. Please log in.'
                })
            
            # Check if user has staff profile (shouldn't happen but safety check)
            if hasattr(user, 'staff_profile'):
                return Response({
                    'message': 'If an unverified account exists with this email, a new verification link has been sent.'
                })
            
            # Check if verification token exists
            try:
                verification = user.email_verification
                
                # If still valid, resend same token
                if verification.is_valid():
                    frontend_url = settings.FRONTEND_URL or 'https://totetaxi.netlify.app'
                    verify_url = f'{frontend_url}/verify-email?token={verification.token}'
                    send_email_verification(user, verification.token, verify_url)
                else:
                    # Token expired, create new one
                    verification.delete()
                    new_verification = EmailVerificationToken.create_token(user)
                    frontend_url = settings.FRONTEND_URL or 'https://totetaxi.netlify.app'
                    verify_url = f'{frontend_url}/verify-email?token={new_verification.token}'
                    send_email_verification(user, new_verification.token, verify_url)
                    
            except EmailVerificationToken.DoesNotExist:
                # No verification token exists, create new one
                new_verification = EmailVerificationToken.create_token(user)
                frontend_url = settings.FRONTEND_URL or 'https://totetaxi.netlify.app'
                verify_url = f'{frontend_url}/verify-email?token={new_verification.token}'
                send_email_verification(user, new_verification.token, verify_url)
            
            return Response({
                'message': 'If an unverified account exists with this email, a new verification link has been sent.'
            })
            
        except User.DoesNotExist:
            # Don't reveal if user doesn't exist (security)
            return Response({
                'message': 'If an unverified account exists with this email, a new verification link has been sent.'
            })

@method_decorator(ratelimit(key='user_or_ip', rate='20/m', method='POST', block=True), name='post')
@method_decorator(csrf_exempt, name='dispatch')
class CustomerLogoutView(APIView):
    """Enhanced customer logout endpoint with complete session cleanup and rate limiting"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        # Always logout, even if not authenticated (cleanup)
        logout(request)
        
        # Force session cleanup
        if hasattr(request, 'session'):
            request.session.flush()
        
        response = Response({'message': 'Logout successful'})
        
        # Clear all possible auth cookies
        auth_cookies = ['sessionid', 'csrftoken']
        for cookie_name in auth_cookies:
            response.delete_cookie(cookie_name)
            # Also try with domain
            response.delete_cookie(cookie_name, domain='.totetaxi.com')
        
        return response


@method_decorator(ratelimit(key='user', rate='60/m', method='GET', block=True), name='get')
class CurrentUserView(APIView):
    """Get current authenticated user info with profile validation and rate limiting"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        # Ensure profile integrity
        try:
            CustomerProfile.ensure_single_profile_type(request.user)
        except ValidationError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        
        if hasattr(request.user, 'customer_profile'):
            return Response({
                'user': UserSerializer(request.user).data,
                'customer_profile': CustomerProfileSerializer(request.user.customer_profile).data,
                'csrf_token': get_token(request)
            })
        else:
            return Response({'error': 'Not a customer account'}, status=status.HTTP_403_FORBIDDEN)


@method_decorator(ratelimit(key='ip', rate='100/m', method='GET', block=True), name='get')
class CSRFTokenView(APIView):
    """Get CSRF token for authenticated requests with rate limiting"""
    permission_classes = [permissions.AllowAny]
    
    @method_decorator(ensure_csrf_cookie)
    def get(self, request):
        return Response({
            'csrf_token': get_token(request)
        })


@method_decorator(ratelimit(key='user', rate='30/m', method=['GET', 'PATCH'], block=True), name='dispatch')
class CustomerProfileView(generics.RetrieveUpdateAPIView):
    """Customer profile management with validation and rate limiting"""
    serializer_class = CustomerProfileSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_object(self):
        # Ensure profile integrity
        try:
            CustomerProfile.ensure_single_profile_type(self.request.user)
        except ValidationError as e:
            from django.http import Http404
            raise Http404(str(e))
        
        return self.request.user.customer_profile


@method_decorator(ratelimit(key='user', rate='20/m', method=['GET', 'POST'], block=True), name='dispatch')
class SavedAddressListCreateView(generics.ListCreateAPIView):
    """List and create saved addresses with rate limiting"""
    serializer_class = SavedAddressSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return self.request.user.saved_addresses.filter(is_active=True)
    
    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


@method_decorator(ratelimit(key='user', rate='15/m', method=['GET', 'PATCH', 'DELETE'], block=True), name='dispatch')
class SavedAddressDetailView(generics.RetrieveUpdateDestroyAPIView):
    """Retrieve, update, delete saved address with rate limiting"""
    serializer_class = SavedAddressSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return self.request.user.saved_addresses.all()


@method_decorator(ratelimit(key='user', rate='30/m', method='GET', block=True), name='get')
class CustomerBookingListView(generics.ListAPIView):
    """Customer booking history with rate limiting"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return self.request.user.bookings.all().order_by('-created_at')
    
    def get(self, request, *args, **kwargs):
        bookings = self.get_queryset()
        booking_data = []
        
        for booking in bookings:
            booking_data.append({
                'id': str(booking.id),
                'booking_number': booking.booking_number,
                'service_type': booking.get_service_type_display(),
                'status': booking.get_status_display(),
                'pickup_date': booking.pickup_date,
                'total_price': booking.total_price_dollars,
                'created_at': booking.created_at
            })
        
        return Response({
            'bookings': booking_data,
            'total_count': len(booking_data)
        })


@method_decorator(ratelimit(key='user', rate='5/m', method='PATCH', block=True), name='patch')
class CustomerNotesUpdateView(APIView):
    """Update customer notes with rate limiting - staff only"""
    permission_classes = [permissions.IsAuthenticated]
    
    def patch(self, request, customer_id):
        # Check if user is staff
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Staff access required'}, status=status.HTTP_403_FORBIDDEN)
        
        try:
            customer_user = User.objects.get(id=customer_id)
            customer_profile = customer_user.customer_profile
        except (User.DoesNotExist, CustomerProfile.DoesNotExist):
            return Response({'error': 'Customer not found'}, status=status.HTTP_404_NOT_FOUND)
        
        notes = request.data.get('notes', '')
        customer_profile.notes = notes
        customer_profile.save()
        
        return Response({
            'message': 'Customer notes updated successfully',
            'notes': customer_profile.notes
        })


@method_decorator(ratelimit(key='user', rate='20/m', method='GET', block=True), name='get')
class CustomerDashboardView(APIView):
    """Enhanced customer dashboard with booking insights and rate limiting"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        if not hasattr(request.user, 'customer_profile'):
            return Response(
                {'error': 'This is not a customer account'}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        customer_profile = request.user.customer_profile
        
        all_bookings = request.user.bookings.filter(deleted_at__isnull=True).order_by('-created_at')
        recent_bookings = all_bookings[:5]
        
        pending_bookings = all_bookings.filter(status__in=['pending', 'confirmed']).count()
        completed_bookings = all_bookings.filter(status='completed').count()
        
        saved_addresses = request.user.saved_addresses.filter(is_active=True)
        payment_methods = request.user.payment_methods.filter(is_active=True)
        
        popular_addresses = saved_addresses.order_by('-times_used')[:3]
        
        # ✅ FIX: Serialize the recent bookings properly
        from .booking_serializers import CustomerBookingDetailSerializer
        
        return Response({
            'customer_profile': {
                'name': request.user.get_full_name(),
                'email': request.user.email,
                'phone': customer_profile.phone,
                'is_vip': customer_profile.is_vip,
                'total_bookings': customer_profile.total_bookings,
                'total_spent_dollars': customer_profile.total_spent_dollars,
                'last_booking_at': customer_profile.last_booking_at
            },
            'booking_summary': {
                'pending_bookings': pending_bookings,
                'completed_bookings': completed_bookings,
                'total_bookings': all_bookings.count()
            },
            'recent_bookings': CustomerBookingDetailSerializer(recent_bookings, many=True).data,  # ✅ FIXED!
            'saved_addresses_count': saved_addresses.count(),
            'payment_methods_count': payment_methods.count(),
            'popular_addresses': SavedAddressSerializer(popular_addresses, many=True).data
        })

@method_decorator(ratelimit(key='user', rate='15/m', method='GET', block=True), name='get')
class BookingPreferencesView(APIView):
    """Manage customer booking preferences with rate limiting"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        customer_profile = request.user.customer_profile
        
        return Response({
            'preferred_pickup_time': customer_profile.preferred_pickup_time,
            'email_notifications': customer_profile.email_notifications,
            'sms_notifications': customer_profile.sms_notifications,
            'default_addresses': {
                'most_used_pickup': self._get_most_used_address('pickup'),
                'most_used_delivery': self._get_most_used_address('delivery')
            }
        })
    
    def _get_most_used_address(self, address_type):
        most_used = self.request.user.saved_addresses.filter(is_active=True).order_by('-times_used').first()
        return SavedAddressSerializer(most_used).data if most_used else None
    
# Add these imports at the top

# Add these new views at the end of the file

@method_decorator(csrf_exempt, name='dispatch')  # ← ADD THIS LINE
@method_decorator(ratelimit(key='ip', rate='10/h', method='POST', block=True), name='post')  # ← CHANGED from 3/h to 10/h
class PasswordResetRequestView(APIView):
    """Request password reset - sends email with reset link"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        email = request.data.get('email', '').strip().lower()
        
        if not email:
            return Response(
                {'error': 'Email is required'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            user = User.objects.get(email__iexact=email)
            
            # Only allow password reset for customer accounts
            if not hasattr(user, 'customer_profile'):
                # Don't reveal if account exists
                return Response({
                    'message': 'If an account exists with this email, you will receive password reset instructions.'
                })
            
            # Create reset token
            reset_token_obj = PasswordResetToken.create_token(user)
            
            # Build reset URL (frontend URL)
            frontend_url = settings.FRONTEND_URL or 'https://totetaxi.netlify.app'
            reset_url = f'{frontend_url}/reset-password?token={reset_token_obj.token}'
            
            # Send email
            send_password_reset_email(user, reset_token_obj.token, reset_url)
            
            return Response({
                'message': 'If an account exists with this email, you will receive password reset instructions.'
            })
            
        except User.DoesNotExist:
            # Don't reveal if account doesn't exist (security best practice)
            return Response({
                'message': 'If an account exists with this email, you will receive password reset instructions.'
            })
        
# 2. Password Reset Confirm View - Around line 405
@method_decorator(csrf_exempt, name='dispatch')  # ← ADD THIS LINE
@method_decorator(ratelimit(key='ip', rate='10/h', method='POST', block=True), name='post')  # ← CHANGED from 5/h to 10/h
class PasswordResetConfirmView(APIView):
    """Confirm password reset with token"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        token = request.data.get('token', '').strip()
        new_password = request.data.get('new_password', '')
        
        if not token or not new_password:
            return Response(
                {'error': 'Token and new password are required'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        if len(new_password) < 8:
            return Response(
                {'error': 'Password must be at least 8 characters'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            reset_token = PasswordResetToken.objects.get(token=token)
            
            if not reset_token.is_valid():
                return Response(
                    {'error': 'This reset link has expired or been used. Please request a new one.'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Reset the password
            user = reset_token.user
            user.set_password(new_password)
            user.save()
            
            # Mark token as used
            reset_token.used = True
            reset_token.save()
            
            # Invalidate all other sessions
            if hasattr(user, 'session_set'):
                user.session_set.all().delete()
            
            return Response({
                'message': 'Password reset successful. You can now log in with your new password.'
            })
            
        except PasswordResetToken.DoesNotExist:
            return Response(
                {'error': 'Invalid reset link. Please request a new one.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        


@method_decorator(ratelimit(key='ip', rate='5/h', method='POST', block=True), name='post')
@method_decorator(ensure_csrf_cookie, name='dispatch')
class ContactFormView(APIView):
    """
    Contact form endpoint - sends email to info@totetaxi.com
    Rate limited to 5 submissions per hour per IP to prevent spam
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        # Get form data
        name = request.data.get('name', '').strip()
        email = request.data.get('email', '').strip()
        phone = request.data.get('phone', '').strip()
        subject_type = request.data.get('subject', 'General')
        message = request.data.get('message', '').strip()
        
        # Validate required fields
        errors = {}
        if not name:
            errors['name'] = 'Name is required'
        if not email:
            errors['email'] = 'Email is required'
        if not message:
            errors['message'] = 'Message is required'
        
        if errors:
            return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)
        
        # Build email content
        email_subject = f'Contact Form: {subject_type} - {name}'
        email_body = f"""
New contact form submission from Tote Taxi website:

Name: {name}
Email: {email}
Phone: {phone or 'Not provided'}
Subject: {subject_type}

Message:
{message}

---
This message was sent from the Tote Taxi contact form.
Reply directly to: {email}
"""
        
        try:
            # Send email to info@totetaxi.com
            send_mail(
                subject=email_subject,
                message=email_body,
                from_email=settings.DEFAULT_FROM_EMAIL,
                recipient_list=['info@totetaxi.com'],
                fail_silently=False,
            )
            
            return Response({
                'message': 'Thank you for contacting us! We will respond within 24 hours.'
            }, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f'Failed to send contact form email: {str(e)}')
            return Response(
                {'error': 'Failed to send message. Please try again or email us directly at info@totetaxi.com'},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
```

# ==== apps/logistics/__init__.py ====

```python

```

# ==== apps/logistics/admin.py ====

```python

```

# ==== apps/logistics/apps.py ====

```python
# apps/logistics/apps.py
from django.apps import AppConfig


class LogisticsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.logistics'
    verbose_name = 'Logistics'
```

# ==== apps/logistics/conftest.py ====

```python
# apps/logistics/conftest.py
"""
Pytest fixtures for logistics app tests.
Ensures Onfleet always runs in mock mode during tests.
"""
import pytest
from django.conf import settings


@pytest.fixture(autouse=True)
def force_onfleet_mock_mode(settings):
    """
    Automatically force Onfleet mock mode for ALL logistics tests.
    
    This is a safety net that prevents accidental real API calls during testing,
    even if environment variables or settings.py are misconfigured.
    
    This fixture runs automatically for every test in the logistics app.
    """
    settings.ONFLEET_MOCK_MODE = True
    settings.ONFLEET_ENVIRONMENT = 'sandbox'
    yield


@pytest.fixture
def onfleet_service():
    """
    Provides a configured OnfleetService instance for testing.
    Always uses mock mode.
    """
    from apps.logistics.services import OnfleetService
    service = OnfleetService()
    assert service.mock_mode is True, "OnfleetService must be in mock mode for tests!"
    return service


@pytest.fixture
def onfleet_integration():
    """
    Provides a configured ToteTaxiOnfleetIntegration instance for testing.
    Always uses mock mode.
    """
    from apps.logistics.services import ToteTaxiOnfleetIntegration
    integration = ToteTaxiOnfleetIntegration()
    assert integration.onfleet.mock_mode is True, "Onfleet integration must be in mock mode for tests!"
    return integration
```

# ==== apps/logistics/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.5 on 2025-09-13 23:37

import django.db.models.deletion
import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('bookings', '0002_booking_include_packing_booking_include_unpacking_and_more'),
    ]

    operations = [
        migrations.CreateModel(
            name='OnfleetTask',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('onfleet_task_id', models.CharField(max_length=100, unique=True)),
                ('onfleet_short_id', models.CharField(blank=True, max_length=20)),
                ('tracking_url', models.URLField(blank=True)),
                ('status', models.CharField(choices=[('created', 'Created'), ('assigned', 'Assigned'), ('active', 'Active'), ('completed', 'Completed'), ('failed', 'Failed')], default='created', max_length=20)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('last_synced', models.DateTimeField(blank=True, null=True)),
                ('booking', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='onfleet_task', to='bookings.booking')),
            ],
            options={
                'verbose_name': 'Onfleet Task',
                'verbose_name_plural': 'Onfleet Tasks',
                'db_table': 'logistics_onfleet_task',
                'indexes': [models.Index(fields=['onfleet_task_id'], name='logistics_o_onfleet_7020df_idx'), models.Index(fields=['status'], name='logistics_o_status_f0c32e_idx')],
            },
        ),
    ]
```

# ==== apps/logistics/migrations/0002_alter_onfleettask_options_and_more.py ====

```python
# Generated by Django 5.2.5 on 2025-10-12 15:49

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('bookings', '0005_booking_same_day_surcharge_cents'),
        ('logistics', '0001_initial'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='onfleettask',
            options={'ordering': ['-created_at'], 'verbose_name': 'Onfleet Task', 'verbose_name_plural': 'Onfleet Tasks'},
        ),
        migrations.RemoveIndex(
            model_name='onfleettask',
            name='logistics_o_status_f0c32e_idx',
        ),
        migrations.AddField(
            model_name='onfleettask',
            name='completed_at',
            field=models.DateTimeField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name='onfleettask',
            name='delivery_notes',
            field=models.TextField(blank=True),
        ),
        migrations.AddField(
            model_name='onfleettask',
            name='environment',
            field=models.CharField(choices=[('sandbox', 'Sandbox'), ('production', 'Production')], default='sandbox', max_length=20),
        ),
        migrations.AddField(
            model_name='onfleettask',
            name='estimated_arrival',
            field=models.DateTimeField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name='onfleettask',
            name='failure_notes',
            field=models.TextField(blank=True),
        ),
        migrations.AddField(
            model_name='onfleettask',
            name='failure_reason',
            field=models.CharField(blank=True, max_length=100),
        ),
        migrations.AddField(
            model_name='onfleettask',
            name='linked_task',
            field=models.ForeignKey(blank=True, help_text='For dropoff tasks, links to the pickup task', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='dependent_tasks', to='logistics.onfleettask'),
        ),
        migrations.AddField(
            model_name='onfleettask',
            name='photo_urls',
            field=models.JSONField(blank=True, default=list),
        ),
        migrations.AddField(
            model_name='onfleettask',
            name='recipient_name',
            field=models.CharField(blank=True, max_length=255),
        ),
        migrations.AddField(
            model_name='onfleettask',
            name='recipient_phone',
            field=models.CharField(blank=True, max_length=20),
        ),
        migrations.AddField(
            model_name='onfleettask',
            name='signature_url',
            field=models.URLField(blank=True),
        ),
        migrations.AddField(
            model_name='onfleettask',
            name='started_at',
            field=models.DateTimeField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name='onfleettask',
            name='task_type',
            field=models.CharField(choices=[('pickup', 'Pickup'), ('dropoff', 'Dropoff')], default='dropoff', help_text='Pickup or Dropoff task', max_length=10),
            preserve_default=False,
        ),
        migrations.AddField(
            model_name='onfleettask',
            name='worker_id',
            field=models.CharField(blank=True, max_length=255),
        ),
        migrations.AddField(
            model_name='onfleettask',
            name='worker_name',
            field=models.CharField(blank=True, max_length=255),
        ),
        migrations.AlterField(
            model_name='onfleettask',
            name='booking',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='onfleet_tasks', to='bookings.booking'),
        ),
        migrations.AlterField(
            model_name='onfleettask',
            name='status',
            field=models.CharField(choices=[('created', 'Created'), ('assigned', 'Assigned to Driver'), ('active', 'Driver En Route'), ('completed', 'Completed'), ('failed', 'Failed'), ('deleted', 'Deleted')], default='created', max_length=20),
        ),
        migrations.AlterField(
            model_name='onfleettask',
            name='tracking_url',
            field=models.URLField(blank=True, max_length=500),
        ),
        migrations.AddIndex(
            model_name='onfleettask',
            index=models.Index(fields=['booking', 'task_type'], name='logistics_o_booking_981805_idx'),
        ),
        migrations.AddIndex(
            model_name='onfleettask',
            index=models.Index(fields=['status', 'environment'], name='logistics_o_status_5ed770_idx'),
        ),
        migrations.AddIndex(
            model_name='onfleettask',
            index=models.Index(fields=['created_at'], name='logistics_o_created_6f3156_idx'),
        ),
        migrations.AddConstraint(
            model_name='onfleettask',
            constraint=models.UniqueConstraint(fields=('booking', 'task_type'), name='unique_task_type_per_booking'),
        ),
    ]
```

# ==== apps/logistics/migrations/__init__.py ====

```python

```

# ==== apps/logistics/models.py ====

```python
# apps/logistics/models.py
import uuid
from django.db import models
from django.utils import timezone
import logging

logger = logging.getLogger(__name__)


class OnfleetTask(models.Model):
    """
    Onfleet task tracking - 2 tasks per booking (pickup + dropoff)
    Each task triggers separate SMS to recipient
    """
    
    TASK_TYPE_CHOICES = [
        ('pickup', 'Pickup'),
        ('dropoff', 'Dropoff'),
    ]
    
    STATUS_CHOICES = [
        ('created', 'Created'),
        ('assigned', 'Assigned to Driver'),
        ('active', 'Driver En Route'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
        ('deleted', 'Deleted'),
    ]
    
    ENVIRONMENT_CHOICES = [
        ('sandbox', 'Sandbox'),
        ('production', 'Production'),
    ]
    
    # Primary identifiers
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Core relationship - NOW supports multiple tasks per booking
    booking = models.ForeignKey(
        'bookings.Booking',
        on_delete=models.CASCADE,
        related_name='onfleet_tasks'  # Changed from onfleet_task (singular)
    )
    
    # NEW: Task type and linking
    task_type = models.CharField(
        max_length=10,
        choices=TASK_TYPE_CHOICES,
        help_text="Pickup or Dropoff task"
    )
    
    linked_task = models.ForeignKey(
        'self',
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name='dependent_tasks',
        help_text="For dropoff tasks, links to the pickup task"
    )
    
    # Onfleet identifiers
    onfleet_task_id = models.CharField(max_length=100, unique=True)
    onfleet_short_id = models.CharField(max_length=20, blank=True)
    tracking_url = models.URLField(max_length=500, blank=True)
    
    # NEW: Environment tracking
    environment = models.CharField(
        max_length=20,
        choices=ENVIRONMENT_CHOICES,
        default='sandbox'
    )
    
    # NEW: Recipient (who receives SMS for THIS task)
    recipient_name = models.CharField(max_length=255, blank=True)
    recipient_phone = models.CharField(max_length=20, blank=True)
    
    # Status tracking
    status = models.CharField(
        max_length=20,
        choices=STATUS_CHOICES,
        default='created'
    )
    
    # NEW: Worker/driver info
    worker_id = models.CharField(max_length=255, blank=True)
    worker_name = models.CharField(max_length=255, blank=True)
    
    # NEW: Timing
    estimated_arrival = models.DateTimeField(null=True, blank=True)
    started_at = models.DateTimeField(null=True, blank=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    
    # NEW: Proof of delivery
    signature_url = models.URLField(blank=True)
    photo_urls = models.JSONField(default=list, blank=True)
    delivery_notes = models.TextField(blank=True)
    
    # NEW: Failure tracking
    failure_reason = models.CharField(max_length=100, blank=True)
    failure_notes = models.TextField(blank=True)
    
    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    last_synced = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        db_table = 'logistics_onfleet_task'
        verbose_name = 'Onfleet Task'
        verbose_name_plural = 'Onfleet Tasks'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['booking', 'task_type']),
            models.Index(fields=['onfleet_task_id']),
            models.Index(fields=['status', 'environment']),
            models.Index(fields=['created_at']),
        ]
        # NEW: Ensure one pickup and one dropoff per booking
        constraints = [
            models.UniqueConstraint(
                fields=['booking', 'task_type'],
                name='unique_task_type_per_booking'
            )
        ]
    
    def __str__(self):
        return f"{self.task_type.upper()} - {self.booking.booking_number} ({self.status})"
    
    def is_pickup(self):
        return self.task_type == 'pickup'
    
    def is_dropoff(self):
        return self.task_type == 'dropoff'
    
    def sync_status_from_onfleet(self, onfleet_state):
        """Convert Onfleet state (0-3) to our status"""
        state_mapping = {
            0: 'created',    # unassigned
            1: 'assigned',   # assigned to driver
            2: 'active',     # driver started
            3: 'completed'   # delivery done
        }
        
        old_status = self.status
        self.status = state_mapping.get(onfleet_state, 'failed')
        self.last_synced = timezone.now()
        self.save()
        
        # ONLY mark booking complete when DROPOFF task completes
        if old_status != 'completed' and self.status == 'completed' and self.is_dropoff():
            self._mark_booking_completed()
    
    def _mark_booking_completed(self):
        """Update ToteTaxi booking when DROPOFF delivery completes"""
        try:
            if self.booking.status in ['confirmed', 'paid', 'in_progress']:
                self.booking.status = 'completed'
                self.booking.save()
                logger.info(f"✓ Booking {self.booking.booking_number} marked completed")
            
            # Update customer stats if authenticated user
            if self.booking.customer and hasattr(self.booking.customer, 'customer_profile'):
                profile = self.booking.customer.customer_profile
                profile.total_bookings += 1
                profile.total_spent_cents += self.booking.total_price_cents
                profile.last_booking_at = timezone.now()
                
                if not profile.is_vip and profile.total_spent_dollars >= 2000:
                    profile.is_vip = True
                
                profile.save()
                
        except Exception as e:
            logger.error(f"Error updating booking completion: {e}")


# UPDATED Signal - now creates 2 tasks instead of 1
from django.db.models.signals import post_save
from django.dispatch import receiver

@receiver(post_save, sender='bookings.Booking')
def create_onfleet_tasks_on_payment(sender, instance, created, **kwargs):
    """
    Auto-create Onfleet tasks when booking payment is confirmed
    Creates 2 tasks: pickup + dropoff
    """
    # Trigger on 'paid' or 'confirmed' status
    if instance.status in ['paid', 'confirmed']:
        # Check if tasks already exist
        if instance.onfleet_tasks.exists():
            logger.debug(f"Tasks already exist for booking {instance.booking_number}")
            return
        
        try:
            from .services import ToteTaxiOnfleetIntegration
            integration = ToteTaxiOnfleetIntegration()
            pickup, dropoff = integration.create_tasks_for_booking(instance)
            
            if pickup and dropoff:
                logger.info(f"✓ Created 2 Onfleet tasks for booking {instance.booking_number}")
            else:
                logger.error(f"✗ Failed to create tasks for booking {instance.booking_number}")
                
        except Exception as e:
            logger.error(f"Error in Onfleet signal: {e}", exc_info=True)
```

# ==== apps/logistics/services.py ====

```python
import logging
import re
from datetime import datetime, timedelta, time as dt_time
from typing import Dict, Optional, Tuple

import requests
from django.conf import settings
from django.utils import timezone

logger = logging.getLogger(__name__)


def parse_street_address(address_line_1: str) -> Tuple[str, str]:
    """Parse a full street address into street number and street name for Onfleet."""
    if not address_line_1:
        return "", ""
    
    address_line_1 = address_line_1.strip()
    pattern = r'^(\d+(?:[A-Z]|[-\s]*[A-Z]|[-\s]*\d+/\d+)?)\s+(.+)'
    match = re.match(pattern, address_line_1, re.IGNORECASE)
    
    if match:
        return match.group(1).strip(), match.group(2).strip()
    else:
        return "", address_line_1


class OnfleetService:
    """Low-level Onfleet API wrapper"""

    def __init__(self):
        self.api_key = getattr(settings, 'ONFLEET_API_KEY', '')
        self.base_url = 'https://onfleet.com/api/v2'
        self.mock_mode = getattr(settings, 'ONFLEET_MOCK_MODE', True)
        self.environment = getattr(settings, 'ONFLEET_ENVIRONMENT', 'sandbox')

    def _make_request(self, method: str, endpoint: str, data: dict = None) -> dict:
        """Make authenticated request to Onfleet API"""
        if self.mock_mode:
            return self._mock_response(method, endpoint, data)

        url = f"{self.base_url}/{endpoint}"
        auth = (self.api_key, '')
        headers = {'Content-Type': 'application/json'}

        try:
            if method == 'GET':
                response = requests.get(url, auth=auth, headers=headers)
            elif method == 'POST':
                response = requests.post(url, auth=auth, headers=headers, json=data)
            elif method == 'PUT':
                response = requests.put(url, auth=auth, headers=headers, json=data)
            elif method == 'DELETE':
                response = requests.delete(url, auth=auth, headers=headers)

            response.raise_for_status()
            return response.json()

        except requests.RequestException as e:
            error_detail = ''
            if hasattr(e, 'response') and e.response is not None:
                try:
                    error_detail = e.response.json()
                except Exception:
                    error_detail = e.response.text

            logger.error(f"Onfleet API error ({method} {endpoint}): {e}")
            logger.error(f"Error details: {error_detail}")
            logger.error(f"Request data: {data}")
            raise

    def _mock_response(self, method: str, endpoint: str, data: dict = None) -> dict:
        """Mock responses for development"""
        if endpoint == 'tasks' and method == 'POST':
            task_metadata = data.get('metadata', [])
            booking_number = next((m['value'] for m in task_metadata if m.get('name') == 'booking_number'), 'unknown')
            task_type = next((m['value'] for m in task_metadata if m.get('name') == 'task_type'), 'unknown')

            mock_id = f'mock_{task_type}_{hash(booking_number) % 10000:04d}'

            return {
                'id': mock_id,
                'shortId': f'mt{hash(booking_number) % 1000:03d}',
                'trackingURL': f'https://onf.lt/mock{hash(f"{booking_number}{task_type}") % 10000:04d}',
                'state': 0,  # 0 = unassigned
                'worker': None,
                'merchant': 'mock_org_id',
                'creator': 'mock_admin_id',
                'pickupTask': data.get('pickupTask', False),
                'dependencies': data.get('dependencies', [])
            }

        elif endpoint == 'organization':
            return {
                'id': 'mock_org_id',
                'name': f'ToteTaxi ({self.environment.upper()} - MOCK MODE)',
                'activeTasks': 5,
                'workers': [
                    {'id': 'mock_worker_1', 'name': 'Test Driver 1', 'onDuty': True},
                    {'id': 'mock_worker_2', 'name': 'Test Driver 2', 'onDuty': False}
                ]
            }

        elif endpoint.startswith('workers/'):
            return {
                'id': endpoint.split('/')[-1],
                'name': 'Test Driver',
                'onDuty': True
            }

        return {'success': True, 'mock': True}

    def create_task(self, task_data: dict) -> dict:
        return self._make_request('POST', 'tasks', task_data)

    def get_organization_info(self) -> dict:
        return self._make_request('GET', 'organization')

    def get_worker(self, worker_id: str) -> dict:
        return self._make_request('GET', f'workers/{worker_id}')


class ToteTaxiOnfleetIntegration:
    """High-level integration manager for ToteTaxi + Onfleet"""

    def __init__(self):
        self.onfleet = OnfleetService()

    def create_tasks_for_booking(self, booking) -> Tuple[Optional['OnfleetTask'], Optional['OnfleetTask']]:
        from .models import OnfleetTask

        try:
            existing = OnfleetTask.objects.filter(booking=booking)
            if existing.exists():
                logger.warning(f"Booking {booking.booking_number} already has Onfleet tasks")
                return existing.filter(task_type='pickup').first(), existing.filter(task_type='dropoff').first()

            logger.info(f"Creating Onfleet tasks for booking {booking.booking_number}")

            pickup_response = self._create_pickup_task(booking)
            logger.info(f"✓ Pickup task created: {pickup_response['id']}")

            dropoff_response = self._create_dropoff_task(booking, depends_on=pickup_response['id'])
            logger.info(f"✓ Dropoff task created: {dropoff_response['id']}")

            db_pickup = OnfleetTask.objects.create(
                booking=booking,
                task_type='pickup',
                environment=self.onfleet.environment,
                onfleet_task_id=pickup_response['id'],
                onfleet_short_id=pickup_response.get('shortId', ''),
                tracking_url=pickup_response.get('trackingURL', ''),
                recipient_name=booking.get_customer_name(),
                recipient_phone=self._get_customer_phone(booking),
                status=self._map_onfleet_state(pickup_response.get('state', 0)),
                worker_id=pickup_response.get('worker', '') or '',
                worker_name=self._get_worker_name(pickup_response.get('worker'))
            )

            db_dropoff = OnfleetTask.objects.create(
                booking=booking,
                task_type='dropoff',
                environment=self.onfleet.environment,
                onfleet_task_id=dropoff_response['id'],
                onfleet_short_id=dropoff_response.get('shortId', ''),
                tracking_url=dropoff_response.get('trackingURL', ''),
                recipient_name=self._get_dropoff_recipient_name(booking),
                recipient_phone=self._get_dropoff_recipient_phone(booking),
                linked_task=db_pickup,
                status=self._map_onfleet_state(dropoff_response.get('state', 0)),
                worker_id=dropoff_response.get('worker', '') or '',
                worker_name=self._get_worker_name(dropoff_response.get('worker'))
            )

            logger.info(f"✓ Onfleet tasks saved to database: {db_pickup.id}, {db_dropoff.id}")
            return db_pickup, db_dropoff

        except Exception as e:
            logger.error(f"Failed to create Onfleet tasks: {e}", exc_info=True)
            return None, None

    def _map_onfleet_state(self, state: int) -> str:
        return {
            0: 'created',
            1: 'assigned',
            2: 'active',
            3: 'completed',
        }.get(state, 'created')

    def _get_worker_name(self, worker_id_or_obj) -> str:
        if not worker_id_or_obj:
            return ''
        if isinstance(worker_id_or_obj, dict):
            return worker_id_or_obj.get('name', '')
        try:
            worker = self.onfleet.get_worker(worker_id_or_obj)
            return worker.get('name', '')
        except Exception as e:
            logger.warning(f"Could not fetch worker name for {worker_id_or_obj}: {e}")
            return ''

    def _create_pickup_task(self, booking) -> dict:
        pickup_datetime = self._get_pickup_datetime(booking)
        window_start = pickup_datetime - timedelta(minutes=30)
        window_end = pickup_datetime + timedelta(minutes=30)

        # ✅ FIX: Parse the street address properly
        street_number, street_name = parse_street_address(booking.pickup_address.address_line_1)

        task_data = {
            'destination': {
                'address': {
                    'number': street_number,
                    'street': street_name,
                    'apartment': getattr(booking.pickup_address, 'address_line_2', '') or '',
                    'city': booking.pickup_address.city,
                    'state': booking.pickup_address.state,
                    'postalCode': booking.pickup_address.zip_code,
                    'country': 'USA'
                }
            },
            'recipients': [{
                'name': booking.get_customer_name(),
                'phone': self._format_phone(self._get_customer_phone(booking)),
                'notes': booking.special_instructions or ''
            }],
            'completeAfter': int(window_start.timestamp() * 1000),
            'completeBefore': int(window_end.timestamp() * 1000),
            'pickupTask': True,
            'autoAssign': {'mode': 'distance'},
            'notes': self._format_task_notes(booking, 'pickup'),
            'metadata': [
                {'name': 'booking_number', 'type': 'string', 'value': booking.booking_number},
                {'name': 'task_type', 'type': 'string', 'value': 'pickup'},
                {'name': 'service_type', 'type': 'string', 'value': booking.service_type}
            ]
        }
        return self.onfleet.create_task(task_data)

    def _create_dropoff_task(self, booking, depends_on: str) -> dict:
        dropoff_datetime = self._get_dropoff_datetime(booking)
        window_start = dropoff_datetime - timedelta(minutes=30)
        window_end = dropoff_datetime + timedelta(hours=1)

        # ✅ FIX: Parse the delivery address properly
        street_number, street_name = parse_street_address(booking.delivery_address.address_line_1)

        task_data = {
            'destination': {
                'address': {
                    'number': street_number,
                    'street': street_name,
                    'apartment': getattr(booking.delivery_address, 'address_line_2', '') or '',
                    'city': booking.delivery_address.city,
                    'state': booking.delivery_address.state,
                    'postalCode': booking.delivery_address.zip_code,
                    'country': 'USA'
                }
            },
            'recipients': [{
                'name': self._get_dropoff_recipient_name(booking),
                'phone': self._format_phone(self._get_dropoff_recipient_phone(booking)),
                'notes': booking.special_instructions or ''
            }],
            'completeAfter': int(window_start.timestamp() * 1000),
            'completeBefore': int(window_end.timestamp() * 1000),
            'pickupTask': False,
            'dependencies': [depends_on],
            'autoAssign': {'mode': 'distance'},
            'notes': self._format_task_notes(booking, 'dropoff'),
            'metadata': [
                {'name': 'booking_number', 'type': 'string', 'value': booking.booking_number},
                {'name': 'task_type', 'type': 'string', 'value': 'dropoff'},
                {'name': 'service_type', 'type': 'string', 'value': booking.service_type}
            ]
        }
        return self.onfleet.create_task(task_data)

    def _get_pickup_datetime(self, booking) -> datetime:
        # Blade transfers use ready time
        if booking.service_type == 'blade_transfer' and getattr(booking, 'blade_ready_time', None):
            pickup_time_obj = booking.blade_ready_time
        elif booking.pickup_time == 'morning_specific' and getattr(booking, 'specific_pickup_hour', None):
            pickup_time_obj = dt_time(hour=booking.specific_pickup_hour, minute=0)
        else:
            pickup_times = {
                'morning': dt_time(8, 0),
                'afternoon': dt_time(14, 0),
                'evening': dt_time(18, 0),
                'night': dt_time(22, 0)
            }
            pickup_time_obj = pickup_times.get(booking.pickup_time, dt_time(8, 0))

        return timezone.make_aware(
            datetime.combine(booking.pickup_date, pickup_time_obj),
            timezone.get_current_timezone()
        )

    def _get_dropoff_datetime(self, booking) -> datetime:
        pickup = self._get_pickup_datetime(booking)
        return pickup + timedelta(hours=2)

    def _format_task_notes(self, booking, task_type: str) -> str:
        base_notes = f"ToteTaxi Booking: {booking.booking_number}\n"
        base_notes += f"Service: {booking.get_service_type_display()}\n"
        base_notes += f"Task: {task_type.upper()}\n"

        if booking.service_type == 'blade_transfer':
            if task_type == 'pickup':
                base_notes += f"Origin: Customer Location\n"
                base_notes += f"Destination: {booking.blade_airport} ({booking.blade_flight_time})\n"
                base_notes += f"Bags: {booking.blade_bag_count}\n"
                base_notes += f"Flight Date: {booking.blade_flight_date}\n"
            else:
                base_notes += f"Airport: {booking.blade_airport}\n"
                base_notes += f"Flight Time: {booking.blade_flight_time}\n"
                base_notes += f"Bags: {booking.blade_bag_count}\n"
        else:
            base_notes += f"Item: {getattr(booking, 'item_description', 'See details')}"

        return base_notes

    def _get_blade_contact(self, airport_code: str) -> Tuple[str, str]:
        blade_contacts = {
            'JFK': ('JFK Terminal', '+17184569876'),
            'EWR': ('Newark Terminal', '+19739876543'),
            'LGA': ('LaGuardia Terminal', '+17185551234')
        }
        return blade_contacts.get(airport_code, ('BLADE Terminal', '+12125551234'))

    def _get_customer_phone(self, booking) -> str:
        try:
            if getattr(booking, 'customer', None) and getattr(booking.customer, 'profile', None):
                return booking.customer.profile.phone or ''
            if getattr(booking, 'guest_checkout', None):
                return booking.guest_checkout.phone or ''
            return ''
        except Exception as e:
            logger.warning(f"Could not get customer phone: {e}")
            return ''

    def _format_phone(self, phone_str: str) -> str:
        if not phone_str:
            return '+1234567890'
        digits = ''.join(c for c in phone_str if c.isdigit())
        if len(digits) == 10:
            return f'+1{digits}'
        if len(digits) == 11 and digits[0] == '1':
            return f'+{digits}'
        return f'+{digits}' if not phone_str.startswith('+') else phone_str

    def _get_dropoff_recipient_phone(self, booking) -> str:
        if booking.service_type == 'blade_transfer':
            _, blade_phone = self._get_blade_contact(booking.blade_airport)
            return blade_phone
        return self._get_customer_phone(booking)

    def _get_dropoff_recipient_name(self, booking) -> str:
        if booking.service_type == 'blade_transfer':
            blade_name, _ = self._get_blade_contact(booking.blade_airport)
            return f"BLADE Team - {blade_name}"
        return booking.get_customer_name()

    def handle_webhook(self, webhook_data: dict) -> bool:
        from .models import OnfleetTask

        try:
            task_id = webhook_data.get('taskId') or webhook_data.get('data', {}).get('task', {}).get('id')
            if not task_id:
                logger.warning("Webhook received without task ID")
                logger.debug(f"Webhook payload: {webhook_data}")
                return False

            try:
                onfleet_task = OnfleetTask.objects.get(onfleet_task_id=task_id)
            except OnfleetTask.DoesNotExist:
                logger.warning(f"Task not found in database: {task_id}")
                return False

            trigger_id = webhook_data.get('triggerId')
            task_obj = webhook_data.get('data', {}).get('task', {})

            if trigger_id == 0:  # started
                onfleet_task.status = 'active'
                onfleet_task.started_at = timezone.now()
                worker = task_obj.get('worker')
                if worker:
                    if isinstance(worker, dict):
                        onfleet_task.worker_id = worker.get('id', '')
                        onfleet_task.worker_name = worker.get('name', '')
                    else:
                        onfleet_task.worker_id = worker
                        onfleet_task.worker_name = self._get_worker_name(worker)
                onfleet_task.save()
                logger.info(f"Task started: {task_id} ({onfleet_task.task_type})")

            elif trigger_id == 3:  # completed
                onfleet_task.status = 'completed'
                onfleet_task.completed_at = timezone.now()
                completion = task_obj.get('completionDetails', {})
                onfleet_task.signature_url = completion.get('signatureUploadId', '')
                onfleet_task.photo_urls = [p.get('uploadId', '') for p in completion.get('photoUploadIds', [])]
                onfleet_task.delivery_notes = completion.get('notes', '')
                onfleet_task.save()

                if onfleet_task.task_type == 'dropoff':
                    booking = onfleet_task.booking
                    booking.status = 'completed'
                    booking.save()
                    logger.info(f"✓ Booking {booking.booking_number} completed")

                logger.info(f"Task completed: {task_id} ({onfleet_task.task_type})")

            elif trigger_id == 4:  # failed
                onfleet_task.status = 'failed'
                completion = task_obj.get('completionDetails', {})
                onfleet_task.failure_reason = completion.get('failureReason', '')
                onfleet_task.failure_notes = completion.get('failureNotes', '')
                onfleet_task.save()
                logger.error(f"Task failed: {task_id} - {onfleet_task.failure_reason}")

            elif trigger_id == 8:  # deleted
                onfleet_task.status = 'deleted'
                onfleet_task.save()
                logger.warning(f"Task deleted: {task_id}")

            elif trigger_id == 1:  # ETA changed
                eta_ts = task_obj.get('estimatedCompletionTime')
                if eta_ts:
                    onfleet_task.estimated_arrival = datetime.fromtimestamp(eta_ts / 1000, tz=timezone.get_current_timezone())
                    onfleet_task.save()
                    logger.info(f"Task ETA updated: {task_id}")

            elif trigger_id == 9:  # assigned
                onfleet_task.status = 'assigned'
                worker = task_obj.get('worker') or webhook_data.get('data', {}).get('worker')
                if worker:
                    if isinstance(worker, dict):
                        onfleet_task.worker_id = worker.get('id', '')
                        onfleet_task.worker_name = worker.get('name', '')
                    else:
                        onfleet_task.worker_id = worker
                        onfleet_task.worker_name = self._get_worker_name(worker)
                onfleet_task.save()
                logger.info(f"Task assigned: {task_id} to {onfleet_task.worker_name}")

            elif trigger_id == 10:  # unassigned
                onfleet_task.status = 'created'
                onfleet_task.worker_id = ''
                onfleet_task.worker_name = ''
                onfleet_task.save()
                logger.info(f"Task unassigned: {task_id}")

            else:
                logger.info(f"Unhandled webhook trigger: {trigger_id} for task {task_id}")

            return True

        except Exception as e:
            logger.error(f"Webhook processing error: {e}", exc_info=True)
            logger.error(f"Webhook data: {webhook_data}")
            return False

    def get_dashboard_summary(self) -> dict:
        from .models import OnfleetTask
        from apps.bookings.models import Booking
        from datetime import date

        try:
            today = date.today()
            todays_bookings = Booking.objects.filter(pickup_date=today, deleted_at__isnull=True)
            onfleet_tasks = OnfleetTask.objects.filter(created_at__date=today, environment=self.onfleet.environment)
            onfleet_org = self.onfleet.get_organization_info()

            return {
                'totetaxi_stats': {
                    'total_bookings': todays_bookings.count(),
                    'confirmed_bookings': todays_bookings.filter(status='confirmed').count(),
                    'completed_bookings': todays_bookings.filter(status='completed').count(),
                },
                'onfleet_stats': {
                    'active_tasks': onfleet_org.get('activeTasks', 0),
                    'available_workers': len([w for w in onfleet_org.get('workers', []) if w.get('onDuty')]),
                    'organization_name': onfleet_org.get('name', 'Unknown')
                },
                'integration_stats': {
                    'tasks_created_today': onfleet_tasks.count(),
                    'pickup_tasks': onfleet_tasks.filter(task_type='pickup').count(),
                    'dropoff_tasks': onfleet_tasks.filter(task_type='dropoff').count(),
                    'tasks_completed_today': onfleet_tasks.filter(status='completed').count(),
                    'tasks_active': onfleet_tasks.filter(status__in=['assigned', 'active']).count(),
                },
                'environment': self.onfleet.environment,
                'mock_mode': self.onfleet.mock_mode
            }

        except Exception as e:
            logger.error(f"Error getting dashboard summary: {e}")
            return {
                'error': 'Failed to fetch logistics data',
                'environment': self.onfleet.environment,
                'mock_mode': self.onfleet.mock_mode
            }

    # Legacy compatibility
    def create_delivery_task(self, booking):
        pickup, dropoff = self.create_tasks_for_booking(booking)
        return pickup
```

# ==== apps/logistics/tests/__init__.py ====

```python

```

# ==== apps/logistics/tests/conftest.py ====

```python
# apps/logistics/tests/conftest.py
"""
Test configuration for logistics app.
Ensures Onfleet integration always uses mock mode during tests.
"""
import pytest
from django.conf import settings


@pytest.fixture(scope='session', autouse=True)
def force_onfleet_mock_mode():
    """
    Force ONFLEET_MOCK_MODE to True for all tests in this module.

    This prevents tests from accidentally hitting the real Onfleet API,
    which would cause:
    - Geocoding errors with test addresses like "123 Main St"
    - Unnecessary API calls that slow down tests
    - Potential API quota usage
    """
    # Store original value
    original_value = getattr(settings, 'ONFLEET_MOCK_MODE', True)

    # Force mock mode ON for all tests
    settings.ONFLEET_MOCK_MODE = True

    yield

    # Restore original value after all tests
    settings.ONFLEET_MOCK_MODE = original_value


@pytest.fixture(autouse=True)
def ensure_mock_mode(force_onfleet_mock_mode):
    """
    Ensure each test runs with mock mode enabled.
    This is a safety check that runs before every test.
    """
    assert settings.ONFLEET_MOCK_MODE is True, \
        "ONFLEET_MOCK_MODE must be True during tests to prevent real API calls"
```

# ==== apps/logistics/tests/test_task_creation.py ====

```python
# backend/apps/logistics/tests/test_task_creation.py
"""
Test Onfleet task creation for ToteTaxi bookings
CRITICAL: Task creation bugs = failed deliveries + customer complaints
"""
import pytest
from unittest.mock import patch, MagicMock
from datetime import date, timedelta, time as dt_time
from django.test import TestCase
from django.contrib.auth.models import User
from django.utils import timezone

from apps.logistics.services import ToteTaxiOnfleetIntegration, OnfleetService
from apps.logistics.models import OnfleetTask
from apps.bookings.models import Booking, Address, GuestCheckout
from apps.services.models import MiniMovePackage


@pytest.fixture
def test_booking(db):
    """Create test booking with guest checkout"""
    package = MiniMovePackage.objects.create(
        package_type='petite',
        name='Petite Move',
        base_price_cents=15000,
        max_items=10,
        is_active=True
    )
    
    pickup = Address.objects.create(
        address_line_1='123 Main St',
        city='New York',
        state='NY',
        zip_code='10001'
    )
    
    delivery = Address.objects.create(
        address_line_1='456 Park Ave',
        city='New York',
        state='NY',
        zip_code='10002'
    )
    
    guest = GuestCheckout.objects.create(
        first_name='Test',
        last_name='Customer',
        email='test@example.com',
        phone='5551234567'
    )
    
    booking = Booking.objects.create(
        service_type='mini_move',
        mini_move_package=package,
        guest_checkout=guest,
        pickup_address=pickup,
        delivery_address=delivery,
        pickup_date=timezone.now().date() + timedelta(days=2),
        pickup_time='morning',
        total_price_cents=15000,
        status='paid'
    )
    
    return booking


@pytest.fixture
def blade_booking(db):
    """Create BLADE transfer booking"""
    pickup = Address.objects.create(
        address_line_1='123 Main St',
        city='New York',
        state='NY',
        zip_code='10001'
    )
    
    delivery = Address.objects.create(
        address_line_1='JFK Airport',
        city='New York',
        state='NY',
        zip_code='11430'
    )
    
    guest = GuestCheckout.objects.create(
        first_name='Blade',
        last_name='Customer',
        email='blade@example.com',
        phone='5559876543'
    )
    
    booking = Booking.objects.create(
        service_type='blade_transfer',
        guest_checkout=guest,
        pickup_address=pickup,
        delivery_address=delivery,
        pickup_date=timezone.now().date() + timedelta(days=2),
        blade_airport='JFK',
        blade_bag_count=3,
        blade_flight_date=timezone.now().date() + timedelta(days=2),
        blade_flight_time=dt_time(14, 0),
        total_price_cents=22500,
        status='paid'
    )
    
    return booking


@pytest.mark.django_db
class TestOnfleetTaskCreation:
    """Test creating pickup + dropoff tasks for bookings"""
    
    def test_creates_two_tasks_for_booking(self, test_booking):
        """Test that two tasks (pickup + dropoff) are created"""
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(test_booking)
        
        assert pickup is not None
        assert dropoff is not None
        assert pickup.task_type == 'pickup'
        assert dropoff.task_type == 'dropoff'
        assert pickup.booking == test_booking
        assert dropoff.booking == test_booking
    
    def test_tasks_are_linked(self, test_booking):
        """Test that dropoff task is linked to pickup task"""
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(test_booking)
        
        assert dropoff.linked_task == pickup
        assert pickup.linked_task is None  # Pickup not linked to anything
    
    def test_prevents_duplicate_task_creation(self, test_booking):
        """Test that creating tasks twice returns existing tasks"""
        integration = ToteTaxiOnfleetIntegration()
        
        # Create tasks first time
        pickup1, dropoff1 = integration.create_tasks_for_booking(test_booking)
        
        # Try to create again
        pickup2, dropoff2 = integration.create_tasks_for_booking(test_booking)
        
        # Should return same tasks
        assert pickup1.id == pickup2.id
        assert dropoff1.id == dropoff2.id
        
        # Should only have 2 tasks total
        assert OnfleetTask.objects.filter(booking=test_booking).count() == 2
    
    def test_pickup_task_has_correct_recipient(self, test_booking):
        """Test pickup task recipient is the customer"""
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(test_booking)
        
        assert pickup.recipient_name == 'Test Customer'
        assert pickup.recipient_phone == '+15551234567' or '5551234567' in pickup.recipient_phone
    
    def test_dropoff_task_has_correct_recipient(self, test_booking):
        """Test dropoff task recipient is the customer (normal delivery)"""
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(test_booking)
        
        assert dropoff.recipient_name == 'Test Customer'
        assert dropoff.recipient_phone == '+15551234567' or '5551234567' in dropoff.recipient_phone
    
    def test_tasks_have_tracking_urls(self, test_booking):
        """Test that both tasks have tracking URLs"""
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(test_booking)
        
        assert pickup.tracking_url
        assert dropoff.tracking_url
        assert 'onf.lt' in pickup.tracking_url or 'mock' in pickup.tracking_url
        assert 'onf.lt' in dropoff.tracking_url or 'mock' in dropoff.tracking_url
    
    def test_tasks_have_onfleet_task_ids(self, test_booking):
        """Test that both tasks have Onfleet task IDs"""
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(test_booking)
        
        assert pickup.onfleet_task_id
        assert dropoff.onfleet_task_id
        assert pickup.onfleet_task_id != dropoff.onfleet_task_id
    
    def test_tasks_default_to_created_status(self, test_booking):
        """Test tasks are created with 'created' status in mock mode"""
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(test_booking)
        
        assert pickup.status == 'created'
        assert dropoff.status == 'created'
    
    def test_tasks_have_environment_set(self, test_booking):
        """Test tasks have environment field set"""
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(test_booking)
        
        assert pickup.environment in ['sandbox', 'production']
        assert dropoff.environment in ['sandbox', 'production']


@pytest.mark.django_db
class TestBLADETransferTasks:
    """Test BLADE transfer special handling"""
    
    def test_blade_dropoff_recipient_is_blade_team(self, blade_booking):
        """Test BLADE dropoff goes to BLADE team, not customer"""
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(blade_booking)
        
        # Pickup is still customer
        assert 'Blade Customer' in pickup.recipient_name
        
        # Dropoff is BLADE team
        assert 'BLADE' in dropoff.recipient_name
        assert 'Bowie Tam' in dropoff.recipient_name or 'Nathan' in dropoff.recipient_name
    
    def test_blade_dropoff_has_blade_phone(self, blade_booking):
        """Test BLADE dropoff has BLADE team phone number"""
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(blade_booking)
        
        # JFK should have Bowie Tam's number
        assert '+17185410177' in dropoff.recipient_phone or '7185410177' in dropoff.recipient_phone
    
    def test_blade_ewr_gets_nathan_contact(self, db):
        """Test EWR airport gets Nathan's contact"""
        pickup = Address.objects.create(
            address_line_1='123 Main St',
            city='New York',
            state='NY',
            zip_code='10001'
        )
        
        delivery = Address.objects.create(
            address_line_1='EWR Airport',
            city='Newark',
            state='NJ',
            zip_code='07114'
        )
        
        guest = GuestCheckout.objects.create(
            first_name='Blade',
            last_name='Customer',
            email='blade@example.com',
            phone='5559876543'
        )
        
        booking = Booking.objects.create(
            service_type='blade_transfer',
            guest_checkout=guest,
            pickup_address=pickup,
            delivery_address=delivery,
            pickup_date=timezone.now().date() + timedelta(days=2),
            blade_airport='EWR',  # Newark
            blade_bag_count=2,
            blade_flight_date=timezone.now().date() + timedelta(days=2),
            blade_flight_time=dt_time(16, 0),
            total_price_cents=15000,
            status='paid'
        )
        
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(booking)
        
        assert 'Nathan' in dropoff.recipient_name
        assert '+19083992284' in dropoff.recipient_phone or '9083992284' in dropoff.recipient_phone


@pytest.mark.django_db
class TestTaskCreationSignal:
    """Test automatic task creation via Django signal"""
    
    def test_signal_creates_tasks_on_paid_status(self, test_booking):
        """Test signal auto-creates tasks when booking is marked paid"""
        # Booking fixture already has status='paid', but tasks created before signal
        # Create a new booking with pending status
        test_booking.status = 'pending_payment'
        test_booking.save()
        
        # Delete any existing tasks
        OnfleetTask.objects.filter(booking=test_booking).delete()
        
        # Change status to paid (should trigger signal)
        test_booking.status = 'paid'
        test_booking.save()
        
        # Check tasks were created
        tasks = OnfleetTask.objects.filter(booking=test_booking)
        assert tasks.count() == 2
        assert tasks.filter(task_type='pickup').exists()
        assert tasks.filter(task_type='dropoff').exists()
    
    def test_signal_creates_tasks_on_confirmed_status(self, test_booking):
        """Test signal works with 'confirmed' status too"""
        test_booking.status = 'pending_payment'
        test_booking.save()
        
        OnfleetTask.objects.filter(booking=test_booking).delete()
        
        test_booking.status = 'confirmed'
        test_booking.save()
        
        tasks = OnfleetTask.objects.filter(booking=test_booking)
        assert tasks.count() == 2
    
    def test_signal_does_not_duplicate_tasks(self, test_booking):
        """Test signal doesn't create duplicate tasks"""
        # Ensure tasks exist
        integration = ToteTaxiOnfleetIntegration()
        integration.create_tasks_for_booking(test_booking)
        
        initial_count = OnfleetTask.objects.filter(booking=test_booking).count()
        
        # Update booking (should not create more tasks)
        test_booking.status = 'paid'
        test_booking.save()
        
        final_count = OnfleetTask.objects.filter(booking=test_booking).count()
        assert final_count == initial_count == 2


@pytest.mark.django_db
class TestStatusMapping:
    """Test Onfleet state to status mapping"""
    
    def test_map_onfleet_state_unassigned(self):
        """Test state 0 maps to 'created'"""
        integration = ToteTaxiOnfleetIntegration()
        assert integration._map_onfleet_state(0) == 'created'
    
    def test_map_onfleet_state_assigned(self):
        """Test state 1 maps to 'assigned'"""
        integration = ToteTaxiOnfleetIntegration()
        assert integration._map_onfleet_state(1) == 'assigned'
    
    def test_map_onfleet_state_active(self):
        """Test state 2 maps to 'active'"""
        integration = ToteTaxiOnfleetIntegration()
        assert integration._map_onfleet_state(2) == 'active'
    
    def test_map_onfleet_state_completed(self):
        """Test state 3 maps to 'completed'"""
        integration = ToteTaxiOnfleetIntegration()
        assert integration._map_onfleet_state(3) == 'completed'
    
    def test_map_onfleet_state_unknown(self):
        """Test unknown state defaults to 'created'"""
        integration = ToteTaxiOnfleetIntegration()
        assert integration._map_onfleet_state(999) == 'created'


@pytest.mark.django_db
class TestMockMode:
    """Test mock mode behavior"""
    
    def test_mock_mode_enabled_by_default(self):
        """Test mock mode is enabled in test environment"""
        service = OnfleetService()
        assert service.mock_mode is True
    
    def test_mock_mode_returns_mock_data(self, test_booking):
        """Test mock mode returns predictable mock data"""
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(test_booking)
        
        # Mock IDs should start with 'mock_'
        assert pickup.onfleet_task_id.startswith('mock_')
        assert dropoff.onfleet_task_id.startswith('mock_')
    
    def test_mock_organization_info(self):
        """Test mock organization info"""
        service = OnfleetService()
        org_info = service.get_organization_info()
        
        assert 'MOCK MODE' in org_info['name']
        assert 'workers' in org_info
        assert len(org_info['workers']) >= 2


@pytest.mark.django_db
class TestPhoneFormatting:
    """Test phone number formatting"""
    
    def test_format_phone_adds_country_code(self):
        """Test 10-digit phone gets +1 prefix"""
        integration = ToteTaxiOnfleetIntegration()
        formatted = integration._format_phone('5551234567')
        assert formatted == '+15551234567'
    
    def test_format_phone_handles_dashes(self):
        """Test phone with dashes is cleaned"""
        integration = ToteTaxiOnfleetIntegration()
        formatted = integration._format_phone('555-123-4567')
        assert formatted == '+15551234567'
    
    def test_format_phone_handles_parentheses(self):
        """Test phone with parentheses is cleaned"""
        integration = ToteTaxiOnfleetIntegration()
        formatted = integration._format_phone('(555) 123-4567')
        assert formatted == '+15551234567'
    
    def test_format_phone_handles_spaces(self):
        """Test phone with spaces is cleaned"""
        integration = ToteTaxiOnfleetIntegration()
        formatted = integration._format_phone('555 123 4567')
        assert formatted == '+15551234567'
    
    def test_format_phone_preserves_existing_country_code(self):
        """Test phone that already has +1 is preserved"""
        integration = ToteTaxiOnfleetIntegration()
        formatted = integration._format_phone('+15551234567')
        assert formatted == '+15551234567'
    
    def test_format_phone_empty_string_fallback(self):
        """Test empty phone returns fallback"""
        integration = ToteTaxiOnfleetIntegration()
        formatted = integration._format_phone('')
        assert formatted == '+1234567890'  # Fallback for testing


@pytest.mark.django_db
class TestUniqueConstraint:
    """Test database constraints"""
    
    def test_cannot_create_duplicate_pickup_task(self, test_booking):
        """Test unique constraint prevents duplicate pickup tasks"""
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(test_booking)
        
        # Try to create another pickup task directly
        with pytest.raises(Exception):
            OnfleetTask.objects.create(
                booking=test_booking,
                task_type='pickup',
                onfleet_task_id='duplicate_pickup',
                environment='sandbox'
            )
    
    def test_cannot_create_duplicate_dropoff_task(self, test_booking):
        """Test unique constraint prevents duplicate dropoff tasks"""
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(test_booking)
        
        # Try to create another dropoff task directly
        with pytest.raises(Exception):
            OnfleetTask.objects.create(
                booking=test_booking,
                task_type='dropoff',
                onfleet_task_id='duplicate_dropoff',
                environment='sandbox'
            )
```

# ==== apps/logistics/tests/test_views.py ====

```python
# backend/apps/logistics/tests/test_views.py
"""
Test logistics API endpoints
CRITICAL: API bugs = broken staff dashboard + manual task creation failures
"""
import pytest
from datetime import timedelta
from django.contrib.auth.models import User
from django.utils import timezone
from rest_framework.test import APIClient

from apps.logistics.models import OnfleetTask
from apps.logistics.services import ToteTaxiOnfleetIntegration
from apps.bookings.models import Booking, Address, GuestCheckout
from apps.services.models import MiniMovePackage
from apps.accounts.models import StaffProfile


@pytest.fixture
def staff_user(db):
    """Create staff user with profile"""
    user = User.objects.create_user(
        username='staff@example.com',
        email='staff@example.com',
        password='staffpass123',
        is_active=True
    )
    StaffProfile.objects.create(
        user=user,
        role='staff',
        phone='5551234567'
    )
    return user


@pytest.fixture
def staff_client(staff_user):
    """Create authenticated staff API client"""
    client = APIClient()
    client.force_authenticate(user=staff_user)
    return client


@pytest.fixture
def regular_user(db):
    """Create regular (non-staff) user"""
    user = User.objects.create_user(
        username='customer@example.com',
        email='customer@example.com',
        password='customerpass123',
        is_active=True
    )
    return user


@pytest.fixture
def test_booking(db):
    """Create test booking"""
    package = MiniMovePackage.objects.create(
        package_type='petite',
        name='Petite Move',
        base_price_cents=15000,
        max_items=10,
        is_active=True
    )
    
    pickup = Address.objects.create(
        address_line_1='123 Main St',
        city='New York',
        state='NY',
        zip_code='10001'
    )
    
    delivery = Address.objects.create(
        address_line_1='456 Park Ave',
        city='New York',
        state='NY',
        zip_code='10002'
    )
    
    guest = GuestCheckout.objects.create(
        first_name='Test',
        last_name='Customer',
        email='test@example.com',
        phone='5551234567'
    )
    
    booking = Booking.objects.create(
        service_type='mini_move',
        mini_move_package=package,
        guest_checkout=guest,
        pickup_address=pickup,
        delivery_address=delivery,
        pickup_date=timezone.now().date() + timedelta(days=2),
        pickup_time='morning',
        total_price_cents=15000,
        status='paid'
    )
    
    return booking


@pytest.mark.django_db
class TestLogisticsSummaryView:
    """Test GET /api/staff/logistics/summary/"""
    
    def test_summary_requires_authentication(self):
        """Test unauthenticated request is rejected"""
        client = APIClient()
        response = client.get('/api/staff/logistics/summary/')
        
        assert response.status_code == 403
    
    def test_summary_requires_staff_profile(self, regular_user):
        """Test non-staff user is rejected"""
        client = APIClient()
        client.force_authenticate(user=regular_user)
        
        response = client.get('/api/staff/logistics/summary/')
        
        assert response.status_code == 403
        assert 'staff' in str(response.data).lower()
    
    def test_summary_returns_data_for_staff(self, staff_client):
        """Test staff user gets summary data"""
        response = staff_client.get('/api/staff/logistics/summary/')
        
        assert response.status_code == 200
        assert response.data['success'] is True
        assert 'data' in response.data
        assert 'timestamp' in response.data
    
    def test_summary_includes_totetaxi_stats(self, staff_client):
        """Test summary includes ToteTaxi booking stats"""
        response = staff_client.get('/api/staff/logistics/summary/')
        
        data = response.data['data']
        assert 'totetaxi_stats' in data
        assert 'total_bookings' in data['totetaxi_stats']
        assert 'confirmed_bookings' in data['totetaxi_stats']
        assert 'completed_bookings' in data['totetaxi_stats']
    
    def test_summary_includes_onfleet_stats(self, staff_client):
        """Test summary includes Onfleet stats"""
        response = staff_client.get('/api/staff/logistics/summary/')
        
        data = response.data['data']
        assert 'onfleet_stats' in data
        assert 'active_tasks' in data['onfleet_stats']
        assert 'available_workers' in data['onfleet_stats']
        assert 'organization_name' in data['onfleet_stats']
    
    def test_summary_includes_integration_stats(self, staff_client, test_booking):
        """Test summary includes integration stats"""
        # Create tasks for today
        integration = ToteTaxiOnfleetIntegration()
        integration.create_tasks_for_booking(test_booking)
        
        response = staff_client.get('/api/staff/logistics/summary/')
        
        data = response.data['data']
        assert 'integration_stats' in data
        assert 'tasks_created_today' in data['integration_stats']
        assert 'pickup_tasks' in data['integration_stats']
        assert 'dropoff_tasks' in data['integration_stats']
        assert data['integration_stats']['tasks_created_today'] >= 2
    
    def test_summary_includes_environment(self, staff_client):
        """Test summary includes environment and mock_mode"""
        response = staff_client.get('/api/staff/logistics/summary/')
        
        data = response.data['data']
        assert 'environment' in data
        assert 'mock_mode' in data
        assert data['environment'] in ['sandbox', 'production']
        assert isinstance(data['mock_mode'], bool)


@pytest.mark.django_db
class TestManualTaskCreation:
    """Test POST /api/staff/logistics/create-task/"""
    
    def test_create_task_requires_authentication(self):
        """Test unauthenticated request is rejected"""
        client = APIClient()
        response = client.post('/api/staff/logistics/create-task/', {
            'booking_id': 'test-id'
        })
        
        assert response.status_code == 403
    
    def test_create_task_requires_staff_profile(self, regular_user):
        """Test non-staff user is rejected"""
        client = APIClient()
        client.force_authenticate(user=regular_user)
        
        response = client.post('/api/staff/logistics/create-task/', {
            'booking_id': 'test-id'
        })
        
        assert response.status_code == 403
    
    def test_create_task_requires_booking_id(self, staff_client):
        """Test booking_id is required"""
        response = staff_client.post('/api/staff/logistics/create-task/', {})
        
        assert response.status_code == 400
        assert 'booking_id' in str(response.data).lower()
    
    def test_create_task_for_valid_booking(self, staff_client, test_booking):
        """Test creating tasks for valid booking"""
        # Ensure no tasks exist
        OnfleetTask.objects.filter(booking=test_booking).delete()
        
        response = staff_client.post('/api/staff/logistics/create-task/', {
            'booking_id': str(test_booking.id)
        })
        
        assert response.status_code == 200
        assert response.data['success'] is True
        assert 'pickup_task' in response.data
        assert 'dropoff_task' in response.data
        
        # Verify tasks were created
        tasks = OnfleetTask.objects.filter(booking=test_booking)
        assert tasks.count() == 2
    
    def test_create_task_returns_task_details(self, staff_client, test_booking):
        """Test response includes task IDs and tracking URLs"""
        OnfleetTask.objects.filter(booking=test_booking).delete()
        
        response = staff_client.post('/api/staff/logistics/create-task/', {
            'booking_id': str(test_booking.id)
        })
        
        assert 'id' in response.data['pickup_task']
        assert 'onfleet_task_id' in response.data['pickup_task']
        assert 'tracking_url' in response.data['pickup_task']
        
        assert 'id' in response.data['dropoff_task']
        assert 'onfleet_task_id' in response.data['dropoff_task']
        assert 'tracking_url' in response.data['dropoff_task']
    
    def test_create_task_for_nonexistent_booking(self, staff_client):
        """Test error when booking doesn't exist"""
        response = staff_client.post('/api/staff/logistics/create-task/', {
            'booking_id': '00000000-0000-0000-0000-000000000000'
        })
        
        assert response.status_code == 500
        assert 'error' in response.data


@pytest.mark.django_db
class TestSyncOnfleetStatus:
    """Test POST /api/staff/logistics/sync/"""
    
    def test_sync_requires_authentication(self):
        """Test unauthenticated request is rejected"""
        client = APIClient()
        response = client.post('/api/staff/logistics/sync/')
        
        assert response.status_code == 403
    
    def test_sync_requires_staff_profile(self, regular_user):
        """Test non-staff user is rejected"""
        client = APIClient()
        client.force_authenticate(user=regular_user)
        
        response = client.post('/api/staff/logistics/sync/')
        
        assert response.status_code == 403
    
    def test_sync_updates_recent_tasks(self, staff_client, test_booking):
        """Test sync updates last_synced timestamp"""
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(test_booking)
        
        # Clear sync timestamps
        pickup.last_synced = None
        pickup.save()
        dropoff.last_synced = None
        dropoff.save()
        
        response = staff_client.post('/api/staff/logistics/sync/')
        
        assert response.status_code == 200
        assert response.data['success'] is True
        assert response.data['synced_count'] >= 2
        
        # Check tasks were synced
        pickup.refresh_from_db()
        dropoff.refresh_from_db()
        assert pickup.last_synced is not None
        assert dropoff.last_synced is not None
    
    def test_sync_only_syncs_incomplete_tasks(self, staff_client, test_booking):
        """Test sync only touches incomplete tasks"""
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(test_booking)
        
        # Mark pickup as completed
        pickup.status = 'completed'
        pickup.save()
        
        response = staff_client.post('/api/staff/logistics/sync/')
        
        assert response.status_code == 200
        # Should only sync the dropoff task (still 'created')
        assert response.data['synced_count'] >= 1


@pytest.mark.django_db
class TestTaskStatusView:
    """Test GET /api/staff/logistics/tasks/"""
    
    def test_tasks_requires_authentication(self):
        """Test unauthenticated request is rejected"""
        client = APIClient()
        response = client.get('/api/staff/logistics/tasks/')
        
        assert response.status_code == 403
    
    def test_tasks_requires_staff_profile(self, regular_user):
        """Test non-staff user is rejected"""
        client = APIClient()
        client.force_authenticate(user=regular_user)
        
        response = client.get('/api/staff/logistics/tasks/')
        
        assert response.status_code == 403
    
    def test_tasks_returns_list(self, staff_client, test_booking):
        """Test returns list of tasks"""
        integration = ToteTaxiOnfleetIntegration()
        integration.create_tasks_for_booking(test_booking)
        
        response = staff_client.get('/api/staff/logistics/tasks/')
        
        assert response.status_code == 200
        assert response.data['success'] is True
        assert 'tasks' in response.data
        assert 'count' in response.data
        assert response.data['count'] >= 2
    
    def test_tasks_include_booking_info(self, staff_client, test_booking):
        """Test task list includes booking details"""
        integration = ToteTaxiOnfleetIntegration()
        integration.create_tasks_for_booking(test_booking)
        
        response = staff_client.get('/api/staff/logistics/tasks/')
        
        tasks = response.data['tasks']
        assert len(tasks) >= 2
        
        task = tasks[0]
        assert 'booking_number' in task
        assert 'customer_name' in task
        assert 'task_type' in task
        assert 'status' in task
        assert 'tracking_url' in task
    
    def test_tasks_can_filter_by_booking(self, staff_client, test_booking):
        """Test filtering tasks by booking_id"""
        integration = ToteTaxiOnfleetIntegration()
        integration.create_tasks_for_booking(test_booking)
        
        response = staff_client.get(
            f'/api/staff/logistics/tasks/?booking_id={test_booking.id}'
        )
        
        assert response.status_code == 200
        assert response.data['count'] == 2  # Should only return this booking's tasks
    
    def test_tasks_can_filter_by_date(self, staff_client, test_booking):
        """Test filtering tasks by date"""
        integration = ToteTaxiOnfleetIntegration()
        integration.create_tasks_for_booking(test_booking)
        
        today = timezone.now().date()
        response = staff_client.get(f'/api/staff/logistics/tasks/?date={today}')
        
        assert response.status_code == 200
        assert response.data['count'] >= 2


@pytest.mark.django_db
class TestWebhookView:
    """Test webhook endpoint"""
    
    def test_webhook_get_verification(self):
        """Test GET request for webhook verification"""
        client = APIClient()
        
        response = client.get('/api/staff/logistics/webhook/?check=test_value_123')
        
        assert response.status_code == 200
        assert response.content.decode() == 'test_value_123'
        assert response['Content-Type'] == 'text/plain'
    
    def test_webhook_get_without_check_fails(self):
        """Test GET without check parameter fails"""
        client = APIClient()
        
        response = client.get('/api/staff/logistics/webhook/')
        
        assert response.status_code == 400
    
    def test_webhook_post_processes_event(self, test_booking):
        """Test POST webhook processes event"""
        client = APIClient()
        
        # Create tasks first
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(test_booking)
        
        # Assigned = triggerId 9
        webhook_data = {
            'triggerId': 9,
            'taskId': pickup.onfleet_task_id,
            'data': {
                'task': {'id': pickup.onfleet_task_id},
                'worker': 'worker_123'
            }
        }
        
        response = client.post(
            '/api/staff/logistics/webhook/',
            webhook_data,
            format='json'
        )
        
        assert response.status_code == 200
        assert response.data['success'] is True
        
        # Verify task was updated
        pickup.refresh_from_db()
        assert pickup.status == 'assigned'
        assert pickup.worker_id == 'worker_123'
    
    def test_webhook_csrf_exempt(self, test_booking):
        """Test webhook doesn't require CSRF token"""
        client = APIClient()
        # Don't set CSRF token
        
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(test_booking)
        
        webhook_data = {
            'triggerId': 0,
            'taskId': pickup.onfleet_task_id,
            'data': {
                'task': {'id': pickup.onfleet_task_id}
            }
        }
        
        # Should work without CSRF
        response = client.post(
            '/api/staff/logistics/webhook/',
            webhook_data,
            format='json'
        )
        
        # Should not get CSRF error
        assert response.status_code != 403
```

# ==== apps/logistics/tests/test_webhooks.py ====

```python
# backend/apps/logistics/tests/test_webhooks.py
"""
Test Onfleet webhook handling
CRITICAL: Webhook bugs = missed status updates + incorrect booking states

✅ UPDATED: Tests now use correct OnFleet webhook payload structure
Reference: https://docs.onfleet.com/reference/webhook-payload-examples
"""
import pytest
from unittest.mock import patch
from datetime import datetime
from django.test import TestCase
from django.utils import timezone
from rest_framework.test import APIClient

from apps.logistics.services import ToteTaxiOnfleetIntegration
from apps.logistics.models import OnfleetTask
from apps.bookings.models import Booking, Address, GuestCheckout
from apps.services.models import MiniMovePackage
from datetime import timedelta


@pytest.fixture
def test_booking_with_tasks(db):
    """Create test booking with Onfleet tasks"""
    package = MiniMovePackage.objects.create(
        package_type='petite',
        name='Petite Move',
        base_price_cents=15000,
        max_items=10,
        is_active=True
    )
    
    pickup = Address.objects.create(
        address_line_1='123 Main St',
        city='New York',
        state='NY',
        zip_code='10001'
    )
    
    delivery = Address.objects.create(
        address_line_1='456 Park Ave',
        city='New York',
        state='NY',
        zip_code='10002'
    )
    
    guest = GuestCheckout.objects.create(
        first_name='Test',
        last_name='Customer',
        email='test@example.com',
        phone='5551234567'
    )
    
    booking = Booking.objects.create(
        service_type='mini_move',
        mini_move_package=package,
        guest_checkout=guest,
        pickup_address=pickup,
        delivery_address=delivery,
        pickup_date=timezone.now().date() + timedelta(days=2),
        pickup_time='morning',
        total_price_cents=15000,
        status='paid'
    )
    
    # Create tasks
    integration = ToteTaxiOnfleetIntegration()
    pickup_task, dropoff_task = integration.create_tasks_for_booking(booking)
    
    return booking, pickup_task, dropoff_task


@pytest.mark.django_db
class TestWebhookTaskStarted:
    """Test webhook for task started (trigger ID 0)"""
    
    def test_task_started_updates_status(self, test_booking_with_tasks):
        """Test task started webhook updates status to 'active'"""
        booking, pickup_task, dropoff_task = test_booking_with_tasks
        
        # ✅ FIXED: Use correct OnFleet webhook structure
        webhook_data = {
            'triggerId': 0,  # Task Started
            'taskId': pickup_task.onfleet_task_id,  # ✅ At root level
            'data': {
                'task': {  # ✅ Nested in 'task' object
                    'id': pickup_task.onfleet_task_id,
                    'worker': {
                        'id': 'worker_123',
                        'name': 'John Driver'
                    }
                }
            }
        }
        
        integration = ToteTaxiOnfleetIntegration()
        success = integration.handle_webhook(webhook_data)
        
        assert success is True
        
        pickup_task.refresh_from_db()
        assert pickup_task.status == 'active'
        assert pickup_task.started_at is not None
        assert pickup_task.worker_id == 'worker_123'
        assert pickup_task.worker_name == 'John Driver'
    
    def test_task_started_sets_timestamp(self, test_booking_with_tasks):
        """Test task started sets started_at timestamp"""
        booking, pickup_task, dropoff_task = test_booking_with_tasks
        
        assert pickup_task.started_at is None
        
        # ✅ FIXED: Use correct OnFleet webhook structure
        webhook_data = {
            'triggerId': 0,
            'taskId': pickup_task.onfleet_task_id,
            'data': {
                'task': {
                    'id': pickup_task.onfleet_task_id,
                    'worker': {}
                }
            }
        }
        
        integration = ToteTaxiOnfleetIntegration()
        integration.handle_webhook(webhook_data)
        
        pickup_task.refresh_from_db()
        assert pickup_task.started_at is not None
        assert isinstance(pickup_task.started_at, datetime)


@pytest.mark.django_db
class TestWebhookTaskCompleted:
    """Test webhook for task completed (trigger ID 3)"""
    
    def test_pickup_completed_does_not_complete_booking(self, test_booking_with_tasks):
        """Test pickup completion doesn't mark booking as completed"""
        booking, pickup_task, dropoff_task = test_booking_with_tasks
        
        # ✅ FIXED: Use correct trigger ID (3, not 1) and structure
        webhook_data = {
            'triggerId': 3,  # ✅ FIXED: Task Completed is trigger 3
            'taskId': pickup_task.onfleet_task_id,
            'data': {
                'task': {
                    'id': pickup_task.onfleet_task_id,
                    'completionDetails': {
                        'signatureUploadId': 'sig_123',
                        'photoUploadIds': [{'uploadId': 'photo_456'}],
                        'notes': 'Picked up successfully'
                    }
                }
            }
        }
        
        integration = ToteTaxiOnfleetIntegration()
        integration.handle_webhook(webhook_data)
        
        pickup_task.refresh_from_db()
        assert pickup_task.status == 'completed'
        assert pickup_task.completed_at is not None
        
        # Booking should still be 'paid', not 'completed'
        booking.refresh_from_db()
        assert booking.status == 'paid'
    
    def test_dropoff_completed_marks_booking_completed(self, test_booking_with_tasks):
        """Test dropoff completion marks booking as completed"""
        booking, pickup_task, dropoff_task = test_booking_with_tasks
        
        # ✅ FIXED: Use correct trigger ID (3, not 1) and structure
        webhook_data = {
            'triggerId': 3,  # ✅ FIXED: Task Completed is trigger 3
            'taskId': dropoff_task.onfleet_task_id,
            'data': {
                'task': {
                    'id': dropoff_task.onfleet_task_id,
                    'completionDetails': {
                        'signatureUploadId': 'sig_789',
                        'photoUploadIds': [{'uploadId': 'photo_abc'}],
                        'notes': 'Delivered successfully'
                    }
                }
            }
        }
        
        integration = ToteTaxiOnfleetIntegration()
        integration.handle_webhook(webhook_data)
        
        dropoff_task.refresh_from_db()
        assert dropoff_task.status == 'completed'
        assert dropoff_task.completed_at is not None
        
        # Booking should now be 'completed'
        booking.refresh_from_db()
        assert booking.status == 'completed'
    
    def test_completed_saves_proof_of_delivery(self, test_booking_with_tasks):
        """Test completion saves signature and photos"""
        booking, pickup_task, dropoff_task = test_booking_with_tasks
        
        # ✅ FIXED: Use correct trigger ID (3, not 1) and structure
        webhook_data = {
            'triggerId': 3,  # ✅ FIXED: Task Completed is trigger 3
            'taskId': dropoff_task.onfleet_task_id,
            'data': {
                'task': {
                    'id': dropoff_task.onfleet_task_id,
                    'completionDetails': {
                        'signatureUploadId': 'sig_xyz',
                        'photoUploadIds': [
                            {'uploadId': 'photo_1'},
                            {'uploadId': 'photo_2'}
                        ],
                        'notes': 'Left at door'
                    }
                }
            }
        }
        
        integration = ToteTaxiOnfleetIntegration()
        integration.handle_webhook(webhook_data)
        
        dropoff_task.refresh_from_db()
        assert dropoff_task.signature_url == 'sig_xyz'
        assert dropoff_task.photo_urls == ['photo_1', 'photo_2']
        assert dropoff_task.delivery_notes == 'Left at door'


@pytest.mark.django_db
class TestWebhookTaskFailed:
    """Test webhook for task failed (trigger ID 4)"""
    
    def test_task_failed_updates_status(self, test_booking_with_tasks):
        """Test failed webhook updates status and saves reason"""
        booking, pickup_task, dropoff_task = test_booking_with_tasks
        
        # ✅ FIXED: Use correct trigger ID (4, not 2) and structure
        webhook_data = {
            'triggerId': 4,  # ✅ FIXED: Task Failed is trigger 4
            'taskId': pickup_task.onfleet_task_id,
            'data': {
                'task': {
                    'id': pickup_task.onfleet_task_id,
                    'completionDetails': {
                        'failureReason': 'CUSTOMER_UNAVAILABLE',
                        'failureNotes': 'Customer not home, rescheduling'
                    }
                }
            }
        }
        
        integration = ToteTaxiOnfleetIntegration()
        success = integration.handle_webhook(webhook_data)
        
        assert success is True
        
        pickup_task.refresh_from_db()
        assert pickup_task.status == 'failed'
        assert pickup_task.failure_reason == 'CUSTOMER_UNAVAILABLE'
        assert pickup_task.failure_notes == 'Customer not home, rescheduling'


@pytest.mark.django_db
class TestWebhookTaskDeleted:
    """Test webhook for task deleted (trigger ID 8)"""
    
    def test_task_deleted_updates_status(self, test_booking_with_tasks):
        """Test deleted webhook updates status to 'deleted'"""
        booking, pickup_task, dropoff_task = test_booking_with_tasks
        
        # ✅ FIXED: Use correct trigger ID (8, not 3) and structure
        webhook_data = {
            'triggerId': 8,  # ✅ FIXED: Task Deleted is trigger 8
            'taskId': pickup_task.onfleet_task_id,
            'data': {
                'task': {
                    'id': pickup_task.onfleet_task_id
                }
            }
        }
        
        integration = ToteTaxiOnfleetIntegration()
        success = integration.handle_webhook(webhook_data)
        
        assert success is True
        
        pickup_task.refresh_from_db()
        assert pickup_task.status == 'deleted'


@pytest.mark.django_db
class TestWebhookTaskETAChanged:
    """Test webhook for ETA changed (trigger ID 1)"""
    
    def test_eta_changed_updates_estimated_arrival(self, test_booking_with_tasks):
        """Test ETA webhook updates estimated_arrival field"""
        booking, pickup_task, dropoff_task = test_booking_with_tasks
        
        # Set ETA to 2 hours from now (timestamp in milliseconds)
        future_time = timezone.now() + timedelta(hours=2)
        eta_timestamp = int(future_time.timestamp() * 1000)
        
        # ✅ FIXED: Use correct trigger ID (1, not 6) and structure
        webhook_data = {
            'triggerId': 1,  # ✅ FIXED: Task ETA is trigger 1
            'taskId': pickup_task.onfleet_task_id,
            'data': {
                'task': {
                    'id': pickup_task.onfleet_task_id,
                    'estimatedCompletionTime': eta_timestamp
                }
            }
        }
        
        integration = ToteTaxiOnfleetIntegration()
        integration.handle_webhook(webhook_data)
        
        pickup_task.refresh_from_db()
        assert pickup_task.estimated_arrival is not None
        
        # Check it's approximately correct (within 1 minute)
        time_diff = abs((pickup_task.estimated_arrival - future_time).total_seconds())
        assert time_diff < 60


@pytest.mark.django_db
class TestWebhookTaskAssigned:
    """Test webhook for task assigned (trigger ID 9)"""
    
    def test_task_assigned_updates_worker(self, test_booking_with_tasks):
        """Test assigned webhook updates worker info"""
        booking, pickup_task, dropoff_task = test_booking_with_tasks
        
        # ✅ FIXED: Use correct trigger ID (9, not 8) and structure
        webhook_data = {
            'triggerId': 9,  # ✅ FIXED: Task Assigned is trigger 9
            'taskId': pickup_task.onfleet_task_id,
            'data': {
                'task': {
                    'id': pickup_task.onfleet_task_id,
                    'worker': 'worker_456'  # Can be string or dict
                }
            }
        }
        
        integration = ToteTaxiOnfleetIntegration()
        success = integration.handle_webhook(webhook_data)
        
        assert success is True
        
        pickup_task.refresh_from_db()
        assert pickup_task.status == 'assigned'
        assert pickup_task.worker_id == 'worker_456'
    
    def test_task_assigned_with_worker_dict(self, test_booking_with_tasks):
        """Test assigned webhook with worker as dictionary"""
        booking, pickup_task, dropoff_task = test_booking_with_tasks
        
        # ✅ FIXED: Use correct trigger ID (9, not 8) and structure
        webhook_data = {
            'triggerId': 9,  # ✅ FIXED: Task Assigned is trigger 9
            'taskId': dropoff_task.onfleet_task_id,
            'data': {
                'task': {
                    'id': dropoff_task.onfleet_task_id,
                    'worker': {
                        'id': 'worker_789',
                        'name': 'Jane Driver'
                    }
                }
            }
        }
        
        integration = ToteTaxiOnfleetIntegration()
        integration.handle_webhook(webhook_data)
        
        dropoff_task.refresh_from_db()
        assert dropoff_task.status == 'assigned'
        assert dropoff_task.worker_id == 'worker_789'


@pytest.mark.django_db
class TestWebhookTaskUnassigned:
    """Test webhook for task unassigned (trigger ID 10)"""
    
    def test_task_unassigned_clears_worker(self, test_booking_with_tasks):
        """Test unassigned webhook clears worker info"""
        booking, pickup_task, dropoff_task = test_booking_with_tasks
        
        # First assign the task
        pickup_task.status = 'assigned'
        pickup_task.worker_id = 'worker_123'
        pickup_task.worker_name = 'John Driver'
        pickup_task.save()
        
        # ✅ NEW: Test task unassigned (trigger 10)
        webhook_data = {
            'triggerId': 10,  # Task Unassigned
            'taskId': pickup_task.onfleet_task_id,
            'data': {
                'task': {
                    'id': pickup_task.onfleet_task_id
                }
            }
        }
        
        integration = ToteTaxiOnfleetIntegration()
        success = integration.handle_webhook(webhook_data)
        
        assert success is True
        
        pickup_task.refresh_from_db()
        assert pickup_task.status == 'created'
        assert pickup_task.worker_id == ''
        assert pickup_task.worker_name == ''


@pytest.mark.django_db
class TestWebhookErrorHandling:
    """Test webhook error handling"""
    
    def test_webhook_with_nonexistent_task_returns_false(self, test_booking_with_tasks):
        """Test webhook for non-existent task ID returns False"""
        # ✅ FIXED: Use correct OnFleet webhook structure
        webhook_data = {
            'triggerId': 3,
            'taskId': 'nonexistent_task_id',
            'data': {
                'task': {
                    'id': 'nonexistent_task_id'
                }
            }
        }
        
        integration = ToteTaxiOnfleetIntegration()
        success = integration.handle_webhook(webhook_data)
        
        assert success is False
    
    def test_webhook_without_task_id_returns_false(self, test_booking_with_tasks):
        """Test webhook without task ID returns False"""
        # ✅ FIXED: Test the actual failure case (no taskId at all)
        webhook_data = {
            'triggerId': 3,
            'data': {}  # No taskId anywhere
        }
        
        integration = ToteTaxiOnfleetIntegration()
        success = integration.handle_webhook(webhook_data)
        
        assert success is False
    
    def test_webhook_handles_unknown_trigger_gracefully(self, test_booking_with_tasks):
        """Test webhook with unknown trigger ID doesn't crash"""
        booking, pickup_task, dropoff_task = test_booking_with_tasks
        
        # ✅ FIXED: Use correct OnFleet webhook structure
        webhook_data = {
            'triggerId': 999,  # Unknown trigger
            'taskId': pickup_task.onfleet_task_id,
            'data': {
                'task': {
                    'id': pickup_task.onfleet_task_id
                }
            }
        }
        
        integration = ToteTaxiOnfleetIntegration()
        
        # Should not raise exception
        try:
            success = integration.handle_webhook(webhook_data)
            # Should return True even for unknown triggers
            assert isinstance(success, bool)
        except Exception as e:
            pytest.fail(f"Webhook handling raised unexpected exception: {e}")
    
    def test_webhook_with_old_structure_still_works(self, test_booking_with_tasks):
        """Test backward compatibility with old webhook structure (fallback)"""
        booking, pickup_task, dropoff_task = test_booking_with_tasks
        
        # Old structure (without root-level taskId)
        # This tests the fallback logic
        webhook_data = {
            'triggerId': 0,
            'data': {
                'task': {
                    'id': pickup_task.onfleet_task_id,
                    'worker': {
                        'id': 'worker_123',
                        'name': 'John Driver'
                    }
                }
            }
        }
        
        integration = ToteTaxiOnfleetIntegration()
        success = integration.handle_webhook(webhook_data)
        
        # Should work via fallback logic
        assert success is True
        
        pickup_task.refresh_from_db()
        assert pickup_task.status == 'active'


@pytest.mark.django_db
class TestWebhookTaskCreated:
    """Test webhook for task created (trigger ID 6)"""
    
    def test_task_created_webhook(self, test_booking_with_tasks):
        """Test task created webhook (informational only)"""
        booking, pickup_task, dropoff_task = test_booking_with_tasks
        
        webhook_data = {
            'triggerId': 6,  # Task Created
            'taskId': pickup_task.onfleet_task_id,
            'data': {
                'task': {
                    'id': pickup_task.onfleet_task_id,
                    'state': 0  # Unassigned
                }
            }
        }
        
        integration = ToteTaxiOnfleetIntegration()
        success = integration.handle_webhook(webhook_data)
        
        # Should return True even though we don't handle this event
        assert success is True
```

# ==== apps/logistics/urls.py ====

```python
# apps/logistics/urls.py
from django.urls import path
from . import views

app_name = 'logistics'

urlpatterns = [
    # Staff dashboard endpoints
    path('summary/', views.LogisticsSummaryView.as_view(), name='logistics-summary'),
    path('sync/', views.sync_onfleet_status, name='sync-onfleet'),
    path('tasks/', views.TaskStatusView.as_view(), name='task-status'),
    path('create-task/', views.create_task_manually, name='create-task'),
    
    # Webhook endpoint (for Onfleet to call)
    path('webhook/', views.OnfleetWebhookView.as_view(), name='onfleet-webhook'),
]
```

# ==== apps/logistics/views.py ====

```python
# apps/logistics/views.py
from rest_framework import status, permissions
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.utils import timezone
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from django.http import HttpResponse
import hmac
import hashlib
import logging

from .services import ToteTaxiOnfleetIntegration
from .models import OnfleetTask

logger = logging.getLogger(__name__)


class LogisticsSummaryView(APIView):
    """Simple logistics overview for staff dashboard"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Staff access required'}, status=403)
        
        try:
            integration = ToteTaxiOnfleetIntegration()
            summary = integration.get_dashboard_summary()
            
            return Response({
                'success': True,
                'data': summary,
                'timestamp': timezone.now()
            })
            
        except Exception as e:
            logger.error(f"Error in logistics summary: {e}")
            return Response({
                'error': 'Failed to fetch logistics data',
                'details': str(e)
            }, status=500)


@api_view(['POST'])
@permission_classes([permissions.IsAuthenticated])
def sync_onfleet_status(request):
    """Manual sync button for staff dashboard"""
    if not hasattr(request.user, 'staff_profile'):
        return Response({'error': 'Staff access required'}, status=403)
    
    try:
        # Get recent incomplete tasks
        recent_tasks = OnfleetTask.objects.filter(
            status__in=['created', 'assigned', 'active'],
            created_at__gte=timezone.now() - timezone.timedelta(days=7)
        )
        
        synced_count = 0
        for task in recent_tasks:
            # In production, you'd fetch current status from Onfleet API
            # For now, just update the sync timestamp
            task.last_synced = timezone.now()
            task.save()
            synced_count += 1
        
        return Response({
            'success': True,
            'message': f'Synced {synced_count} tasks',
            'synced_count': synced_count,
            'timestamp': timezone.now()
        })
        
    except Exception as e:
        logger.error(f"Sync error: {e}")
        return Response({
            'error': f'Sync failed: {str(e)}'
        }, status=500)


@api_view(['POST'])
@permission_classes([permissions.IsAuthenticated])
def create_task_manually(request):
    """Manually create Onfleet task for a booking"""
    if not hasattr(request.user, 'staff_profile'):
        return Response({'error': 'Staff access required'}, status=403)
    
    booking_id = request.data.get('booking_id')
    if not booking_id:
        return Response({'error': 'booking_id required'}, status=400)
    
    try:
        from apps.bookings.models import Booking
        booking = Booking.objects.get(id=booking_id, deleted_at__isnull=True)
        
        integration = ToteTaxiOnfleetIntegration()
        pickup, dropoff = integration.create_tasks_for_booking(booking)
        
        if pickup and dropoff:
            return Response({
                'success': True,
                'message': f'Created Onfleet tasks for {booking.booking_number}',
                'pickup_task': {
                    'id': str(pickup.id),
                    'onfleet_task_id': pickup.onfleet_task_id,
                    'tracking_url': pickup.tracking_url,
                },
                'dropoff_task': {
                    'id': str(dropoff.id),
                    'onfleet_task_id': dropoff.onfleet_task_id,
                    'tracking_url': dropoff.tracking_url,
                }
            })
        else:
            return Response({
                'error': 'Failed to create Onfleet tasks'
            }, status=500)
            
    except Exception as e:
        logger.error(f"Manual task creation error: {e}")
        return Response({
            'error': f'Task creation failed: {str(e)}'
        }, status=500)


@method_decorator(csrf_exempt, name='dispatch')
class OnfleetWebhookView(APIView):
    """
    Handle Onfleet webhook notifications
    
    Onfleet webhook flow:
    1. Verification: GET /webhook?check=value → respond with value (plain text)
    2. Events: POST /webhook with JSON payload → process and return 200 OK
    """
    permission_classes = []  # Webhooks don't use session auth
    authentication_classes = []  # No authentication required
    
    def get(self, request):
        """
        Handle Onfleet's webhook verification (sent as GET request)
        Onfleet sends: GET /webhook/?check=some-random-value
        We respond with: 200 OK, plain text "some-random-value"
        """
        check_value = request.query_params.get('check') or request.GET.get('check')
        
        if not check_value:
            logger.warning("Webhook verification failed: no check parameter")
            return Response({'error': 'Missing check parameter'}, status=400)
        
        logger.info(f"✅ Onfleet webhook verification successful: {check_value}")
        return HttpResponse(check_value, content_type='text/plain', status=200)
    
    def post(self, request):
        """
        Handle actual webhook events from Onfleet
        
        ✅ CRITICAL: Always return 200 OK for webhook processing
        Even if processing fails, return 200 to prevent Onfleet retries
        """
        try:
            webhook_data = request.data
            trigger_id = webhook_data.get('triggerId')
            task_id = webhook_data.get('taskId')
            
            logger.info(f"📨 Onfleet webhook received - Trigger: {trigger_id}, Task: {task_id}")
            
            # Process the webhook
            integration = ToteTaxiOnfleetIntegration()
            success = integration.handle_webhook(webhook_data)
            
            # ✅ FIX: Always return 200 OK, regardless of processing result
            # This prevents Onfleet from retrying failed webhooks
            response_data = {
                'success': success,
                'trigger_id': trigger_id,
                'task_id': task_id,
                'timestamp': timezone.now(),
                'message': 'Webhook processed successfully' if success else 'Webhook processing failed but acknowledged'
            }
            
            if success:
                logger.info(f"✅ Webhook processed successfully - Trigger: {trigger_id}")
            else:
                logger.warning(f"⚠️  Webhook processing failed but acknowledged - Trigger: {trigger_id}")
            
            return Response(response_data, status=200)  # ✅ Always 200
                
        except Exception as e:
            logger.error(f"❌ Webhook error: {e}", exc_info=True)
            
            # ✅ Even on exception, return 200 to prevent retries
            return Response({
                'success': False,
                'error': 'Webhook processing failed',
                'details': str(e),
                'timestamp': timezone.now()
            }, status=200)  # ✅ Still 200, not 500


class TaskStatusView(APIView):
    """Get status of Onfleet tasks"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        if not hasattr(request.user, 'staff_profile'):
            return Response({'error': 'Staff access required'}, status=403)
        
        # Get query params
        booking_id = request.query_params.get('booking_id')
        date_filter = request.query_params.get('date')
        
        try:
            tasks = OnfleetTask.objects.all()
            
            if booking_id:
                tasks = tasks.filter(booking_id=booking_id)
            
            if date_filter:
                tasks = tasks.filter(created_at__date=date_filter)
            
            tasks = tasks.select_related('booking').order_by('-created_at')[:50]
            
            task_data = []
            for task in tasks:
                task_data.append({
                    'id': str(task.id),
                    'booking_number': task.booking.booking_number,
                    'customer_name': task.booking.get_customer_name(),
                    'task_type': task.task_type,
                    'onfleet_task_id': task.onfleet_task_id,
                    'onfleet_short_id': task.onfleet_short_id,
                    'tracking_url': task.tracking_url,
                    'recipient_name': task.recipient_name,
                    'recipient_phone': task.recipient_phone,
                    'status': task.status,
                    'worker_name': task.worker_name,
                    'environment': task.environment,
                    'created_at': task.created_at,
                    'last_synced': task.last_synced,
                    'linked_to': str(task.linked_task.id) if task.linked_task else None
                })
            
            return Response({
                'success': True,
                'tasks': task_data,
                'count': len(task_data)
            })
            
        except Exception as e:
            logger.error(f"Error fetching tasks: {e}")
            return Response({
                'error': 'Failed to fetch tasks',
                'details': str(e)
            }, status=500)
```

# ==== apps/payments/__init__.py ====

```python

```

# ==== apps/payments/admin.py ====

```python
from django.contrib import admin
from django.utils.html import format_html
from .models import Payment, Refund, PaymentAudit

@admin.register(Payment)
class PaymentAdmin(admin.ModelAdmin):
    list_display = (
        'booking', 
        'get_customer_name', 
        'amount_dollars', 
        'status', 
        'get_status_badge',
        'created_at',
        'processed_at'
    )
    list_filter = ('status', 'created_at', 'processed_at')
    search_fields = (
        'booking__booking_number', 
        'customer__email', 
        'stripe_payment_intent_id',
        'stripe_charge_id'
    )
    readonly_fields = ('created_at', 'updated_at', 'processed_at')
    
    fieldsets = (
        ('Booking & Customer', {
            'fields': ('booking', 'customer')
        }),
        ('Payment Details', {
            'fields': ('amount_cents', 'status', 'failure_reason')
        }),
        ('Stripe Integration', {
            'fields': ('stripe_payment_intent_id', 'stripe_charge_id')
        }),
        ('Timestamps', {
            'fields': ('processed_at', 'created_at', 'updated_at'),
            'classes': ('collapse',)
        })
    )
    
    def get_customer_name(self, obj):
        if obj.customer:
            return obj.customer.full_name
        else:
            return obj.booking.get_customer_name()
    get_customer_name.short_description = 'Customer'
    
    def get_status_badge(self, obj):
        colors = {
            'pending': 'orange',
            'succeeded': 'green',
            'failed': 'red',
            'refunded': 'blue'
        }
        color = colors.get(obj.status, 'gray')
        return format_html(
            '<span style="color: {}; font-weight: bold;">{}</span>',
            color,
            obj.get_status_display()
        )
    get_status_badge.short_description = 'Status'

@admin.register(Refund)
class RefundAdmin(admin.ModelAdmin):
    list_display = (
        'payment',
        'get_booking_number',
        'amount_dollars',
        'status',
        'get_status_badge',
        'requested_by',
        'approved_by',
        'created_at'
    )
    list_filter = ('status', 'created_at', 'approved_at')
    search_fields = (
        'payment__booking__booking_number',
        'reason',
        'requested_by__email',
        'approved_by__email'
    )
    readonly_fields = ('created_at', 'approved_at', 'completed_at')
    
    fieldsets = (
        ('Refund Details', {
            'fields': ('payment', 'amount_cents', 'reason')
        }),
        ('Approval Workflow', {
            'fields': ('status', 'requested_by', 'approved_by')
        }),
        ('Stripe Integration', {
            'fields': ('stripe_refund_id',)
        }),
        ('Timestamps', {
            'fields': ('approved_at', 'completed_at', 'created_at'),
            'classes': ('collapse',)
        })
    )
    
    actions = ['approve_refunds', 'deny_refunds']
    
    def get_booking_number(self, obj):
        return obj.payment.booking.booking_number
    get_booking_number.short_description = 'Booking #'
    
    def get_status_badge(self, obj):
        colors = {
            'requested': 'orange',
            'approved': 'green',
            'denied': 'red',
            'completed': 'blue'
        }
        color = colors.get(obj.status, 'gray')
        return format_html(
            '<span style="color: {}; font-weight: bold;">{}</span>',
            color,
            obj.get_status_display()
        )
    get_status_badge.short_description = 'Status'
    
    def approve_refunds(self, request, queryset):
        """Bulk approve refunds (only if user is admin)"""
        if not request.user.can_approve_refunds:
            self.message_user(request, 'Only admin users can approve refunds.', level='ERROR')
            return
        
        approved_count = 0
        for refund in queryset.filter(status='requested'):
            try:
                refund.approve(request.user)
                approved_count += 1
            except ValueError as e:
                self.message_user(request, str(e), level='ERROR')
        
        if approved_count > 0:
            self.message_user(
                request, 
                f'Successfully approved {approved_count} refund(s).'
            )
    approve_refunds.short_description = "Approve selected refunds"
    
    def deny_refunds(self, request, queryset):
        """Bulk deny refunds"""
        if not request.user.can_approve_refunds:
            self.message_user(request, 'Only admin users can deny refunds.', level='ERROR')
            return
        
        denied_count = queryset.filter(status='requested').update(status='denied')
        self.message_user(
            request, 
            f'Successfully denied {denied_count} refund(s).'
        )
    deny_refunds.short_description = "Deny selected refunds"

@admin.register(PaymentAudit)
class PaymentAuditAdmin(admin.ModelAdmin):
    list_display = ('action', 'get_short_description', 'user', 'created_at')
    list_filter = ('action', 'created_at')
    search_fields = ('description', 'user__email')
    readonly_fields = ('created_at',)
    
    fieldsets = (
        ('Action Details', {
            'fields': ('action', 'description')
        }),
        ('Related Records', {
            'fields': ('payment', 'refund')
        }),
        ('User & Timestamp', {
            'fields': ('user', 'created_at')
        })
    )
    
    def get_short_description(self, obj):
        return obj.description[:50] + ('...' if len(obj.description) > 50 else '')
    get_short_description.short_description = 'Description'
    
    # Make it mostly read-only (audit logs shouldn't be edited)
    def has_add_permission(self, request):
        return False
    
    def has_change_permission(self, request, obj=None):
        return False
    
    def has_delete_permission(self, request, obj=None):
        return request.user.is_superuser  # Only superusers can delete audit logs
```

# ==== apps/payments/apps.py ====

```python
from django.apps import AppConfig


class PaymentsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.payments'
```

# ==== apps/payments/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.5 on 2025-09-02 20:54

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('bookings', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Payment',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('amount_cents', models.PositiveBigIntegerField()),
                ('stripe_payment_intent_id', models.CharField(blank=True, max_length=200)),
                ('stripe_charge_id', models.CharField(blank=True, max_length=200)),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('succeeded', 'Succeeded'), ('failed', 'Failed'), ('refunded', 'Refunded')], default='pending', max_length=20)),
                ('failure_reason', models.TextField(blank=True)),
                ('processed_at', models.DateTimeField(blank=True, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('booking', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='payments', to='bookings.booking')),
                ('customer', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='payments', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'payments_payment',
            },
        ),
        migrations.CreateModel(
            name='Refund',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('amount_cents', models.PositiveBigIntegerField()),
                ('reason', models.TextField()),
                ('status', models.CharField(choices=[('requested', 'Requested'), ('approved', 'Approved'), ('denied', 'Denied'), ('completed', 'Completed')], default='requested', max_length=20)),
                ('stripe_refund_id', models.CharField(blank=True, max_length=200)),
                ('approved_at', models.DateTimeField(blank=True, null=True)),
                ('completed_at', models.DateTimeField(blank=True, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('approved_by', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.PROTECT, related_name='approved_refunds', to=settings.AUTH_USER_MODEL)),
                ('payment', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='refunds', to='payments.payment')),
                ('requested_by', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='requested_refunds', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'payments_refund',
            },
        ),
        migrations.CreateModel(
            name='PaymentAudit',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('action', models.CharField(choices=[('payment_created', 'Payment Created'), ('payment_succeeded', 'Payment Succeeded'), ('payment_failed', 'Payment Failed'), ('refund_requested', 'Refund Requested'), ('refund_approved', 'Refund Approved'), ('refund_completed', 'Refund Completed')], max_length=30)),
                ('description', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('payment', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='payments.payment')),
                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL)),
                ('refund', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='payments.refund')),
            ],
            options={
                'db_table': 'payments_audit',
                'ordering': ['-created_at'],
            },
        ),
    ]
```

# ==== apps/payments/migrations/0002_payment_payments_stripe_intent_idx_and_more.py ====

```python
# Generated by Django 5.2.5 on 2025-10-20 18:33

from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('bookings', '0008_address_bookings_ad_custome_ebf57e_idx_and_more'),
        ('payments', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AddIndex(
            model_name='payment',
            index=models.Index(fields=['stripe_payment_intent_id'], name='payments_stripe_intent_idx'),
        ),
        migrations.AddIndex(
            model_name='payment',
            index=models.Index(fields=['booking'], name='payments_booking_idx'),
        ),
        migrations.AddIndex(
            model_name='payment',
            index=models.Index(fields=['customer', 'created_at'], name='payments_customer_created_idx'),
        ),
        migrations.AddIndex(
            model_name='payment',
            index=models.Index(fields=['status'], name='payments_status_idx'),
        ),
        migrations.AddIndex(
            model_name='payment',
            index=models.Index(fields=['created_at'], name='payments_created_idx'),
        ),
        migrations.AddIndex(
            model_name='paymentaudit',
            index=models.Index(fields=['payment'], name='audit_payment_idx'),
        ),
        migrations.AddIndex(
            model_name='paymentaudit',
            index=models.Index(fields=['action'], name='audit_action_idx'),
        ),
        migrations.AddIndex(
            model_name='paymentaudit',
            index=models.Index(fields=['created_at'], name='audit_created_idx'),
        ),
        migrations.AddIndex(
            model_name='refund',
            index=models.Index(fields=['payment'], name='refunds_payment_idx'),
        ),
        migrations.AddIndex(
            model_name='refund',
            index=models.Index(fields=['status'], name='refunds_status_idx'),
        ),
        migrations.AddIndex(
            model_name='refund',
            index=models.Index(fields=['created_at'], name='refunds_created_idx'),
        ),
    ]
```

# ==== apps/payments/migrations/__init__.py ====

```python

```

# ==== apps/payments/models.py ====

```python
# backend/apps/payments/models.py
import uuid
from django.db import models
from django.utils import timezone
from django.contrib.auth.models import User


class Payment(models.Model):
    """Payment records for bookings - simple Stripe integration"""
    
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('succeeded', 'Succeeded'),
        ('failed', 'Failed'),
        ('refunded', 'Refunded'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Link to booking
    booking = models.ForeignKey(
        'bookings.Booking',
        on_delete=models.PROTECT,
        related_name='payments'
    )
    
    # Customer (if authenticated)
    customer = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='payments'
    )
    
    # Payment amount
    amount_cents = models.PositiveBigIntegerField()
    
    # Stripe integration
    stripe_payment_intent_id = models.CharField(max_length=200, blank=True)
    stripe_charge_id = models.CharField(max_length=200, blank=True)
    
    # Status
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    failure_reason = models.TextField(blank=True)
    
    # Timestamps
    processed_at = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'payments_payment'
        # ✅ OPTIMIZED: Added indexes for critical queries
        indexes = [
            models.Index(fields=['stripe_payment_intent_id'], name='payments_stripe_intent_idx'),  # Webhook lookups
            models.Index(fields=['booking'], name='payments_booking_idx'),  # Booking detail views
            models.Index(fields=['customer', 'created_at'], name='payments_customer_created_idx'),  # Customer dashboard
            models.Index(fields=['status'], name='payments_status_idx'),  # Admin filtering
            models.Index(fields=['created_at'], name='payments_created_idx'),  # Ordering
        ]
    
    def __str__(self):
        return f"{self.booking.booking_number} - ${self.amount_dollars} ({self.status})"
    
    @property
    def amount_dollars(self):
        return self.amount_cents / 100


class Refund(models.Model):
    """Refund requests with simple approval workflow"""
    
    STATUS_CHOICES = [
        ('requested', 'Requested'),
        ('approved', 'Approved'),
        ('denied', 'Denied'),
        ('completed', 'Completed'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Original payment
    payment = models.ForeignKey(
        Payment,
        on_delete=models.PROTECT,
        related_name='refunds'
    )
    
    # Refund details
    amount_cents = models.PositiveBigIntegerField()
    reason = models.TextField()
    
    # Approval workflow
    requested_by = models.ForeignKey(
        User,
        on_delete=models.PROTECT,
        related_name='requested_refunds'
    )
    approved_by = models.ForeignKey(
        User,
        on_delete=models.PROTECT,
        null=True,
        blank=True,
        related_name='approved_refunds'
    )
    
    # Status and Stripe
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='requested')
    stripe_refund_id = models.CharField(max_length=200, blank=True)
    
    # Timestamps
    approved_at = models.DateTimeField(null=True, blank=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'payments_refund'
        # ✅ OPTIMIZED: Added indexes for refund queries
        indexes = [
            models.Index(fields=['payment'], name='refunds_payment_idx'),
            models.Index(fields=['status'], name='refunds_status_idx'),
            models.Index(fields=['created_at'], name='refunds_created_idx'),
        ]
    
    def __str__(self):
        return f"Refund ${self.amount_dollars} for {self.payment.booking.booking_number}"
    
    @property
    def amount_dollars(self):
        return self.amount_cents / 100
    
    def approve(self, admin_user):
        """Admin approves refund"""
        self.status = 'approved'
        self.approved_by = admin_user
        self.approved_at = timezone.now()
        self.save()


class PaymentAudit(models.Model):
    """Basic audit log for financial compliance"""
    
    ACTION_CHOICES = [
        ('payment_created', 'Payment Created'),
        ('payment_succeeded', 'Payment Succeeded'),
        ('payment_failed', 'Payment Failed'),
        ('refund_requested', 'Refund Requested'),
        ('refund_approved', 'Refund Approved'),
        ('refund_completed', 'Refund Completed'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # What happened
    action = models.CharField(max_length=30, choices=ACTION_CHOICES)
    description = models.TextField()
    
    # Related records
    payment = models.ForeignKey(Payment, on_delete=models.CASCADE, null=True, blank=True)
    refund = models.ForeignKey(Refund, on_delete=models.CASCADE, null=True, blank=True)
    
    # Who did it (staff user)
    user = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'payments_audit'
        ordering = ['-created_at']
        # ✅ OPTIMIZED: Added indexes for audit queries
        indexes = [
            models.Index(fields=['payment'], name='audit_payment_idx'),
            models.Index(fields=['action'], name='audit_action_idx'),
            models.Index(fields=['created_at'], name='audit_created_idx'),
        ]
    
    def __str__(self):
        return f"{self.action} - {self.created_at}"
    
    @classmethod
    def log(cls, action, description, payment=None, refund=None, user=None):
        """Simple audit logging"""
        return cls.objects.create(
            action=action,
            description=description,
            payment=payment,
            refund=refund,
            user=user
        )
```

# ==== apps/payments/serializers.py ====

```python
from rest_framework import serializers
from .models import Payment, Refund
from apps.bookings.models import Booking


class PaymentIntentCreateSerializer(serializers.Serializer):
    """Serializer for creating payment intent"""
    booking_id = serializers.UUIDField()
    customer_email = serializers.EmailField(required=False)
    
    def validate_booking_id(self, value):
        try:
            booking = Booking.objects.get(id=value, deleted_at__isnull=True)
            if booking.status in ['paid', 'completed']:
                raise serializers.ValidationError("Booking is already paid")
            return value
        except Booking.DoesNotExist:
            raise serializers.ValidationError("Booking not found")


class PaymentSerializer(serializers.ModelSerializer):
    amount_dollars = serializers.ReadOnlyField()
    booking_number = serializers.SerializerMethodField()
    customer_name = serializers.SerializerMethodField()
    
    class Meta:
        model = Payment
        fields = (
            'id', 'booking_number', 'customer_name', 'amount_cents', 
            'amount_dollars', 'status', 'stripe_payment_intent_id',
            'stripe_charge_id', 'failure_reason', 'processed_at', 'created_at'
        )
        read_only_fields = ('id', 'created_at')
    
    def get_booking_number(self, obj):
        return obj.booking.booking_number
    
    def get_customer_name(self, obj):
        return obj.booking.get_customer_name()


class PaymentConfirmSerializer(serializers.Serializer):
    """Serializer for payment confirmation webhook"""
    payment_intent_id = serializers.CharField()
    status = serializers.ChoiceField(choices=['succeeded', 'failed'])
    failure_reason = serializers.CharField(required=False, allow_blank=True)


class RefundCreateSerializer(serializers.Serializer):
    """Serializer for creating refunds"""
    payment_id = serializers.UUIDField()
    amount_cents = serializers.IntegerField(min_value=1)
    reason = serializers.CharField(max_length=500)
    
    def validate_payment_id(self, value):
        try:
            payment = Payment.objects.get(id=value, status='succeeded')
            return value
        except Payment.DoesNotExist:
            raise serializers.ValidationError("Payment not found or not succeeded")
    
    def validate(self, attrs):
        try:
            payment = Payment.objects.get(id=attrs['payment_id'])
            if attrs['amount_cents'] > payment.amount_cents:
                raise serializers.ValidationError("Refund amount cannot exceed payment amount")
        except Payment.DoesNotExist:
            pass  # Already handled in validate_payment_id
        return attrs


class RefundSerializer(serializers.ModelSerializer):
    amount_dollars = serializers.ReadOnlyField()
    payment_booking_number = serializers.SerializerMethodField()
    requested_by_name = serializers.SerializerMethodField()
    approved_by_name = serializers.SerializerMethodField()
    
    class Meta:
        model = Refund
        fields = (
            'id', 'payment_booking_number', 'amount_cents', 'amount_dollars',
            'reason', 'status', 'requested_by_name', 'approved_by_name',
            'approved_at', 'completed_at', 'created_at'
        )
        read_only_fields = ('id', 'created_at')
    
    def get_payment_booking_number(self, obj):
        return obj.payment.booking.booking_number
    
    def get_requested_by_name(self, obj):
        return obj.requested_by.get_full_name() if obj.requested_by else None
    
    def get_approved_by_name(self, obj):
        return obj.approved_by.get_full_name() if obj.approved_by else None
```

# ==== apps/payments/services.py ====

```python
# backend/apps/payments/services.py
import stripe
import logging
from django.conf import settings
from django.utils import timezone
from decimal import Decimal

from .models import Payment, PaymentAudit
from apps.bookings.models import Booking

logger = logging.getLogger(__name__)

stripe.api_key = settings.STRIPE_SECRET_KEY


class StripePaymentService:
    """Service layer for Stripe payment processing"""
    
    @staticmethod
    def create_payment_intent(booking, customer_email=None):
        """Create Stripe PaymentIntent for a booking"""
        try:
            intent = stripe.PaymentIntent.create(
                amount=int(booking.total_price_cents),
                currency='usd',
                metadata={
                    'booking_id': str(booking.id),
                    'booking_number': booking.booking_number,
                },
                receipt_email=customer_email or (booking.customer.email if hasattr(booking, 'customer') and booking.customer else None),
            )
            
            payment = Payment.objects.create(
                booking=booking,
                customer=booking.customer if hasattr(booking, 'customer') and booking.customer else None,
                amount_cents=booking.total_price_cents,
                stripe_payment_intent_id=intent.id,
                status='pending'
            )
            
            PaymentAudit.log(
                action='payment_created',
                description=f'PaymentIntent created for booking {booking.booking_number}',
                payment=payment,
                user=None
            )
            
            return {
                'payment': payment,
                'client_secret': intent.client_secret,
                'payment_intent_id': intent.id
            }
            
        except stripe.error.StripeError as e:
            raise Exception(f"Stripe error: {str(e)}")
        except Exception as e:
            raise Exception(f"Failed to create PaymentIntent: {str(e)}")
    
    @staticmethod
    def confirm_payment(payment_intent_id):
        """Verify payment with Stripe and update records - CRITICAL: Updates customer stats"""
        try:
            intent = stripe.PaymentIntent.retrieve(payment_intent_id)
            
            payment = Payment.objects.get(stripe_payment_intent_id=payment_intent_id)
            
            if intent.status == 'succeeded':
                payment.status = 'succeeded'
                payment.stripe_charge_id = intent.latest_charge if hasattr(intent, 'latest_charge') else ''
                payment.processed_at = timezone.now()
                payment.save()
                
                booking = payment.booking
                if booking.status == 'pending':
                    booking.status = 'paid'
                    booking.save()
                
                try:
                    if booking.customer and hasattr(booking.customer, 'customer_profile'):
                        booking.customer.customer_profile.add_booking_stats(
                            booking.total_price_cents
                        )
                        logger.info(f"Updated customer stats: {booking.customer.get_full_name()} - +${booking.total_price_dollars}")
                except Exception as stats_error:
                    logger.warning(f"Failed to update customer stats: {stats_error}")
                
                PaymentAudit.log(
                    action='payment_succeeded',
                    description=f'Payment confirmed for booking {booking.booking_number}',
                    payment=payment,
                    user=None
                )
                
                return payment
            else:
                payment.status = 'failed'
                payment.failure_reason = f"Payment status: {intent.status}"
                payment.save()
                raise Exception(f"Payment not successful: {intent.status}")
            
        except Payment.DoesNotExist:
            raise Exception("Payment not found")
        except stripe.error.StripeError as e:
            raise Exception(f"Stripe error: {str(e)}")
    
    @staticmethod
    def create_refund(payment, amount_cents, reason, requested_by_user):
        """Create refund for a payment"""
        from .models import Refund
        
        try:
            refund = stripe.Refund.create(
                payment_intent=payment.stripe_payment_intent_id,
                amount=amount_cents,
                reason='requested_by_customer',
            )
            
            refund_record = Refund.objects.create(
                payment=payment,
                amount_cents=amount_cents,
                reason=reason,
                requested_by=requested_by_user,
                stripe_refund_id=refund.id,
                status='completed'
            )
            
            payment.status = 'refunded'
            payment.save()
            
            PaymentAudit.log(
                action='refund_completed',
                description=f'Refund completed for payment {payment.id}',
                payment=payment,
                refund=refund_record,
                user=requested_by_user
            )
            
            return refund_record
            
        except stripe.error.StripeError as e:
            raise Exception(f"Stripe refund error: {str(e)}")
```

# ==== apps/payments/tests/__init__.py ====

```python

```

# ==== apps/payments/tests/test_refunds.py ====

```python
# apps/payments/tests/test_refunds.py
"""
Test refund processing
CRITICAL: Refund bugs = customer disputes + lost trust
"""
import pytest
from unittest.mock import patch, MagicMock
from datetime import date, timedelta
from django.test import TestCase
from django.contrib.auth.models import User

from apps.payments.services import StripePaymentService
from apps.payments.models import Payment, Refund, PaymentAudit
from apps.bookings.models import Booking, Address, GuestCheckout
from apps.services.models import MiniMovePackage


@pytest.mark.django_db
class TestRefundProcessing(TestCase):
    """Test refund creation and processing"""
    
    def setUp(self):
        """Create paid booking with successful payment"""
        self.package = MiniMovePackage.objects.create(
            package_type='petite',
            name='Petite Move',
            base_price_cents=15000,
            max_items=10,
            max_weight_per_item_lbs=50,
            is_active=True
        )
        
        self.guest = GuestCheckout.objects.create(
            first_name="Test",
            last_name="Customer",
            email="test@totetaxi.com",
            phone="212-555-0100"
        )
        
        self.pickup = Address.objects.create(
            address_line_1="123 Main St",
            city="New York",
            state="NY",
            zip_code="10001"
        )
        
        self.delivery = Address.objects.create(
            address_line_1="456 Park Ave",
            city="New York",
            state="NY",
            zip_code="10002"
        )
        
        self.booking = Booking.objects.create(
            service_type='mini_move',
            mini_move_package=self.package,
            guest_checkout=self.guest,
            pickup_address=self.pickup,
            delivery_address=self.delivery,
            pickup_date=date.today() + timedelta(days=7),
            pickup_time='morning',
            status='paid'
        )
        
        # Create successful payment
        self.payment = Payment.objects.create(
            booking=self.booking,
            amount_cents=15000,
            stripe_payment_intent_id='pi_paid_test',
            stripe_charge_id='ch_paid_test',
            status='succeeded'
        )
        
        # Create staff user for refund requests
        self.staff_user = User.objects.create_user(
            username='staff',
            email='staff@totetaxi.com',
            password='staffpass123'
        )
    
    @patch('stripe.Refund.create')
    def test_full_refund_processes_correctly(self, mock_refund_create):
        """Test full refund via Stripe"""
        # Mock Stripe refund response
        mock_refund_create.return_value = MagicMock(
            id='re_test123',
            amount=15000,
            status='succeeded'
        )
        
        # Process refund
        refund = StripePaymentService.create_refund(
            payment=self.payment,
            amount_cents=15000,
            reason='Customer requested cancellation',
            requested_by_user=self.staff_user
        )
        
        # Verify Stripe was called correctly
        mock_refund_create.assert_called_once()
        call_kwargs = mock_refund_create.call_args.kwargs
        assert call_kwargs['payment_intent'] == 'pi_paid_test'
        assert call_kwargs['amount'] == 15000
        assert call_kwargs['reason'] == 'requested_by_customer'
        
        # Verify refund record created
        assert refund.amount_cents == 15000
        assert refund.stripe_refund_id == 're_test123'
        assert refund.status == 'completed'
        assert refund.requested_by == self.staff_user
        
        # Verify payment marked as refunded
        self.payment.refresh_from_db()
        assert self.payment.status == 'refunded'
        
        # Verify audit log
        assert PaymentAudit.objects.filter(
            refund=refund,
            action='refund_completed'
        ).exists()
        
        print(f"✅ Full refund processed: ${refund.amount_dollars}")
    
    @patch('stripe.Refund.create')
    def test_partial_refund_processes_correctly(self, mock_refund_create):
        """Test partial refund (e.g., 50% refund)"""
        mock_refund_create.return_value = MagicMock(
            id='re_partial',
            amount=7500,
            status='succeeded'
        )
        
        # Process partial refund (50%)
        refund = StripePaymentService.create_refund(
            payment=self.payment,
            amount_cents=7500,
            reason='Partial service provided',
            requested_by_user=self.staff_user
        )
        
        # Verify correct amount refunded
        assert refund.amount_cents == 7500
        assert refund.amount_dollars == 75.0
        
        # Verify payment marked as refunded
        self.payment.refresh_from_db()
        assert self.payment.status == 'refunded'
        
        print(f"✅ Partial refund processed: ${refund.amount_dollars}")
    
    @patch('stripe.Refund.create')
    def test_refund_reason_stored_correctly(self, mock_refund_create):
        """Test that refund reason is stored"""
        mock_refund_create.return_value = MagicMock(
            id='re_reason_test',
            amount=15000,
            status='succeeded'
        )
        
        reason = "Service cancelled due to weather conditions"
        
        refund = StripePaymentService.create_refund(
            payment=self.payment,
            amount_cents=15000,
            reason=reason,
            requested_by_user=self.staff_user
        )
        
        assert refund.reason == reason
        print(f"✅ Refund reason stored: {refund.reason}")
    
    @patch('stripe.Refund.create')
    def test_stripe_error_handled_gracefully(self, mock_refund_create):
        """Test that Stripe errors are handled"""
        import stripe
        
        # Mock Stripe error
        mock_refund_create.side_effect = stripe.error.CardError(
            message='Insufficient funds',
            param='amount',
            code='insufficient_funds'
        )
        
        # Attempt refund (should raise exception with Stripe error)
        with pytest.raises(Exception) as exc_info:
            StripePaymentService.create_refund(
                payment=self.payment,
                amount_cents=15000,
                reason='Test refund',
                requested_by_user=self.staff_user
            )
        
        assert 'Stripe refund error' in str(exc_info.value)
        
        # Verify no refund record created
        assert not Refund.objects.filter(payment=self.payment).exists()
        
        # Verify payment status unchanged
        self.payment.refresh_from_db()
        assert self.payment.status == 'succeeded'
        
        print("✅ Stripe error handled correctly")
```

# ==== apps/payments/tests/test_stripe.py ====

```python
# backend/apps/payments/tests/test_stripe.py
import pytest
from unittest.mock import patch, Mock
from rest_framework.test import APIClient
from django.contrib.auth.models import User
from apps.customers.models import CustomerProfile
from apps.payments.models import Payment
from apps.bookings.models import Booking, Address, GuestCheckout
from apps.services.models import MiniMovePackage
from django.utils import timezone
from datetime import timedelta


@pytest.fixture
def test_booking(db):
    """Create test booking"""
    pickup = Address.objects.create(
        address_line_1='123 Test St',
        city='New York',
        state='NY',
        zip_code='10001'
    )
    delivery = Address.objects.create(
        address_line_1='456 Test Ave',
        city='New York',
        state='NY',
        zip_code='10002'
    )
    
    package, _ = MiniMovePackage.objects.get_or_create(
        package_type='petite',
        defaults={
            'name': 'Petite',
            'base_price_cents': 99500,
            'max_items': 15,
            'is_active': True
        }
    )
    
    guest = GuestCheckout.objects.create(
        first_name='Test',
        last_name='User',
        email='test@example.com',
        phone='5551234567'
    )
    
    booking = Booking.objects.create(
        guest_checkout=guest,
        service_type='mini_move',
        mini_move_package=package,
        pickup_address=pickup,
        delivery_address=delivery,
        pickup_date=timezone.now().date() + timedelta(days=2),
        status='pending'
    )
    
    return booking


@pytest.mark.django_db
class TestPaymentIntents:
    """Test payment intent creation"""
    
    @patch('stripe.PaymentIntent.create')
    def test_create_payment_intent_guest(self, mock_stripe):
        """Test creating payment intent for guest booking"""
        client = APIClient()
        
        # Get or create package
        package, _ = MiniMovePackage.objects.get_or_create(
            package_type='petite',
            defaults={
                'name': 'Petite',
                'base_price_cents': 99500,
                'max_items': 15,
                'is_active': True
            }
        )
        
        mock_stripe.return_value = Mock(
            id='pi_test_123',
            client_secret='pi_test_123_secret',
            amount=99500
        )
        
        response = client.post('/api/public/create-payment-intent/', {
            'service_type': 'mini_move',
            'mini_move_package_id': str(package.id),
            'pickup_date': (timezone.now().date() + timedelta(days=2)).isoformat(),
            'first_name': 'Guest',
            'last_name': 'User',
            'email': 'guest@example.com',
            'phone': '5559876543'
        }, format='json')
        
        assert response.status_code == 200
        assert 'client_secret' in response.data
        assert 'payment_intent_id' in response.data
        
        mock_stripe.assert_called_once()

# backend/apps/payments/test# backend/apps/payments/tests/test_stripe.py
# backend/apps/payments/tests/test_stripe.py

@pytest.mark.django_db
class TestStripeWebhooks:
    """Test Stripe webhook handling"""
    
    @patch('stripe.Webhook.construct_event')
    @patch('apps.logistics.models.create_onfleet_tasks_on_payment')  # ← Mock the signal
    def test_payment_succeeded_webhook(self, mock_signal, mock_construct, test_booking, settings):
        """Test handling payment_intent.succeeded webhook"""
        client = APIClient()
        
        # Mock signal to do nothing
        mock_signal.return_value = None
        
        # Create payment record
        payment = Payment.objects.create(
            booking=test_booking,
            stripe_payment_intent_id='pi_test_123',
            amount_cents=99500,
            status='processing'
        )
        
        # Mock webhook event
        mock_construct.return_value = {
            'id': 'evt_test_123',
            'type': 'payment_intent.succeeded',
            'data': {
                'object': {
                    'id': 'pi_test_123',
                    'latest_charge': 'ch_test_456',
                    'amount': 99500
                }
            }
        }
        
        response = client.post('/api/payments/webhook/', 
            data={},
            content_type='application/json',
            HTTP_STRIPE_SIGNATURE='test_signature'
        )
        
        assert response.status_code == 200
        
        # Verify payment updated
        payment.refresh_from_db()
        assert payment.status == 'succeeded'
        
        # Verify booking updated
        test_booking.refresh_from_db()
        assert test_booking.status == 'paid'
```

# ==== apps/payments/tests/test_stripe_integration.py ====

```python
# apps/payments/tests/test_stripe_integration.py
"""
Test Stripe payment integration
CRITICAL: These tests protect revenue - payment bugs = lost money
"""
import pytest
from unittest.mock import patch, MagicMock
from decimal import Decimal
from datetime import date, timedelta
from django.test import TestCase
from django.contrib.auth.models import User

from apps.payments.services import StripePaymentService
from apps.payments.models import Payment, PaymentAudit
from apps.bookings.models import Booking, Address, GuestCheckout
from apps.services.models import MiniMovePackage
from apps.customers.models import CustomerProfile


@pytest.mark.django_db
class TestStripePaymentIntegration(TestCase):
    """Test Stripe payment processing via StripePaymentService"""
    
    def setUp(self):
        """Create test booking with guest checkout"""
        self.package = MiniMovePackage.objects.create(
            package_type='petite',
            name='Petite Move',
            base_price_cents=15000,
            max_items=10,
            max_weight_per_item_lbs=50,
            is_active=True
        )
        
        self.guest = GuestCheckout.objects.create(
            first_name="Test",
            last_name="Customer",
            email="test@totetaxi.com",
            phone="212-555-0100"
        )
        
        self.pickup = Address.objects.create(
            address_line_1="123 Main St",
            city="New York",
            state="NY",
            zip_code="10001"
        )
        
        self.delivery = Address.objects.create(
            address_line_1="456 Park Ave",
            city="New York",
            state="NY",
            zip_code="10002"
        )
        
        # Get next Monday
        today = date.today()
        days_until_monday = (0 - today.weekday()) % 7
        if days_until_monday == 0:
            days_until_monday = 7
        next_monday = today + timedelta(days=days_until_monday)
        
        self.booking = Booking.objects.create(
            service_type='mini_move',
            mini_move_package=self.package,
            guest_checkout=self.guest,
            pickup_address=self.pickup,
            delivery_address=self.delivery,
            pickup_date=next_monday,
            pickup_time='morning',
            status='pending'  # ✅ FIXED: Use 'pending' not 'pending_payment'
        )
    
    @patch('stripe.PaymentIntent.create')
    def test_payment_intent_created_with_correct_amount(self, mock_create):
        """CRITICAL: Verify Stripe is charged exact booking amount"""
        # Mock Stripe API response
        mock_create.return_value = MagicMock(
            id='pi_test123',
            client_secret='secret_test123'
        )
        
        # Create payment intent
        result = StripePaymentService.create_payment_intent(
            booking=self.booking,
            customer_email='test@totetaxi.com'
        )
        
        # Verify Stripe was called with correct amount
        mock_create.assert_called_once()
        call_kwargs = mock_create.call_args.kwargs
        
        assert call_kwargs['amount'] == self.booking.total_price_cents, \
            f"Expected {self.booking.total_price_cents} cents, got {call_kwargs['amount']}"
        assert call_kwargs['currency'] == 'usd'
        assert call_kwargs['metadata']['booking_number'] == self.booking.booking_number
        assert call_kwargs['receipt_email'] == 'test@totetaxi.com'
        
        # Verify Payment record was created
        assert Payment.objects.filter(booking=self.booking).exists()
        payment = Payment.objects.get(booking=self.booking)
        assert payment.amount_cents == self.booking.total_price_cents
        assert payment.stripe_payment_intent_id == 'pi_test123'
        assert payment.status == 'pending'
        
        # Verify audit log created
        assert PaymentAudit.objects.filter(payment=payment, action='payment_created').exists()
        
        print(f"✅ Payment intent created: ${self.booking.total_price_cents/100}")
    
    @patch('stripe.PaymentIntent.retrieve')
    def test_payment_confirmation_updates_booking_status(self, mock_retrieve):
        """Test that successful payment updates booking to 'paid'"""
        # Create payment record first
        payment = Payment.objects.create(
            booking=self.booking,
            amount_cents=self.booking.total_price_cents,
            stripe_payment_intent_id='pi_test123',
            status='pending'
        )
        
        # Mock Stripe retrieve response
        mock_retrieve.return_value = MagicMock(
            id='pi_test123',
            status='succeeded',
            latest_charge='ch_test123'
        )
        
        # Confirm payment
        confirmed_payment = StripePaymentService.confirm_payment('pi_test123')
        
        # Verify payment updated
        assert confirmed_payment.status == 'succeeded'
        assert confirmed_payment.stripe_charge_id == 'ch_test123'
        assert confirmed_payment.processed_at is not None
        
        # Verify booking status updated to 'paid'
        self.booking.refresh_from_db()
        assert self.booking.status == 'paid', \
            f"Expected booking status 'paid', got '{self.booking.status}'"
        
        # Verify audit log
        assert PaymentAudit.objects.filter(
            payment=confirmed_payment,
            action='payment_succeeded'
        ).exists()
        
        print(f"✅ Payment confirmed, booking status: {self.booking.status}")
    
    @patch('stripe.PaymentIntent.retrieve')
    def test_payment_confirmation_updates_customer_stats(self, mock_retrieve):
        """Test that customer stats are updated on successful payment"""
        # Create authenticated customer with profile
        user = User.objects.create_user(
            username='testcustomer',
            email='customer@totetaxi.com',
            password='testpass123'
        )
        profile = CustomerProfile.objects.create(
            user=user,
            phone='+12125550200',  # ✅ FIXED: Valid phone format with country code
            total_bookings=0,
            total_spent_cents=0
        )
        
        # Create booking for authenticated customer (not guest)
        booking = Booking.objects.create(
            service_type='mini_move',
            mini_move_package=self.package,
            customer=user,
            pickup_address=self.pickup,
            delivery_address=self.delivery,
            pickup_date=date.today() + timedelta(days=7),
            pickup_time='morning',
            status='pending'  # ✅ FIXED: Use 'pending' not 'pending_payment'
        )
        
        # Create payment
        payment = Payment.objects.create(
            booking=booking,
            customer=user,
            amount_cents=booking.total_price_cents,
            stripe_payment_intent_id='pi_customer_test',
            status='pending'
        )
        
        # Mock Stripe
        mock_retrieve.return_value = MagicMock(
            id='pi_customer_test',
            status='succeeded',
            latest_charge='ch_test456'
        )
        
        # Confirm payment
        StripePaymentService.confirm_payment('pi_customer_test')
        
        # Verify customer stats updated
        profile.refresh_from_db()
        assert profile.total_bookings == 1, \
            f"Expected 1 booking, got {profile.total_bookings}"
        assert profile.total_spent_cents == booking.total_price_cents, \
            f"Expected ${booking.total_price_cents/100}, got ${profile.total_spent_cents/100}"
        
        print(f"✅ Customer stats updated: {profile.total_bookings} bookings, ${profile.total_spent_dollars}")
    
    @patch('stripe.PaymentIntent.retrieve')
    def test_payment_failure_keeps_booking_pending(self, mock_retrieve):
        """Test that failed payment doesn't mark booking as paid"""
        payment = Payment.objects.create(
            booking=self.booking,
            amount_cents=self.booking.total_price_cents,
            stripe_payment_intent_id='pi_fail_test',
            status='pending'
        )
        
        # Mock failed payment
        mock_retrieve.return_value = MagicMock(
            id='pi_fail_test',
            status='requires_payment_method'
        )
        
        # Attempt to confirm payment (should raise exception)
        with pytest.raises(Exception) as exc_info:
            StripePaymentService.confirm_payment('pi_fail_test')
        
        assert 'Payment not successful' in str(exc_info.value)
        
        # Verify payment marked as failed
        payment.refresh_from_db()
        assert payment.status == 'failed'
        
        # Verify booking still pending
        self.booking.refresh_from_db()
        assert self.booking.status == 'pending'
        
        print("✅ Failed payment handled correctly")
    
    @patch('stripe.PaymentIntent.retrieve')  # ✅ FIXED: Mock Stripe API call
    def test_payment_not_found_error(self, mock_retrieve):
        """Test error when payment doesn't exist"""
        # Mock Stripe to raise InvalidRequestError (payment intent not found)
        import stripe
        mock_retrieve.side_effect = stripe.error.InvalidRequestError(
            message="No such payment_intent: 'pi_nonexistent'",
            param='intent'
        )
        
        with pytest.raises(Exception) as exc_info:
            StripePaymentService.confirm_payment('pi_nonexistent')
        
        # Should get "Payment not found" from our code, not Stripe error
        # But since we're mocking Stripe to fail first, we'll get Stripe error
        # The important thing is an exception is raised
        assert 'Stripe error' in str(exc_info.value) or 'Payment not found' in str(exc_info.value)
        print("✅ Payment not found error handled")


@pytest.mark.django_db
class TestPaymentEdgeCases(TestCase):
    """Test edge cases and error handling"""
    
    def setUp(self):
        """Create minimal test data"""
        self.package = MiniMovePackage.objects.create(
            package_type='petite',
            name='Test Package',
            base_price_cents=10000,
            max_items=5,
            max_weight_per_item_lbs=50,
            is_active=True
        )
        
        self.guest = GuestCheckout.objects.create(
            first_name="Test",
            last_name="User",
            email="test@test.com",
            phone="555-0100"
        )
        
        self.pickup = Address.objects.create(
            address_line_1="123 St",
            city="New York",
            state="NY",
            zip_code="10001"
        )
        
        self.delivery = Address.objects.create(
            address_line_1="456 Ave",
            city="New York",
            state="NY",
            zip_code="10002"
        )
    
    @patch('stripe.PaymentIntent.create')
    def test_guest_checkout_email_used_when_no_customer(self, mock_create):
        """Test that guest email is used when booking has no customer"""
        mock_create.return_value = MagicMock(
            id='pi_guest',
            client_secret='secret_guest'
        )
        
        booking = Booking.objects.create(
            service_type='mini_move',
            mini_move_package=self.package,
            guest_checkout=self.guest,
            pickup_address=self.pickup,
            delivery_address=self.delivery,
            pickup_date=date.today() + timedelta(days=5),
            pickup_time='morning',
            status='pending'
        )
        
        # Create payment intent without providing email
        # (should handle missing customer gracefully)
        result = StripePaymentService.create_payment_intent(booking=booking)
        
        # Should succeed without error
        assert result['payment_intent_id'] == 'pi_guest'
        print("✅ Guest checkout handled correctly")
```

# ==== apps/payments/urls.py ====

```python
# backend/apps/payments/urls.py
from django.urls import path
from django.conf import settings
from . import views

urlpatterns = [
    # Public payment endpoints
    path('create-intent/', views.PaymentIntentCreateView.as_view(), name='payment-intent-create'),
    path('status/<str:booking_number>/', views.PaymentStatusView.as_view(), name='payment-status'),
    path('webhook/', views.StripeWebhookView.as_view(), name='stripe-webhook'),
    path('confirm/', views.PaymentConfirmView.as_view(), name='payment-confirm'),
    
    # Staff endpoints
    path('payments/', views.PaymentListView.as_view(), name='payment-list'),
    path('refunds/', views.RefundListView.as_view(), name='refund-list'),
    path('refunds/create/', views.RefundCreateView.as_view(), name='refund-create'),
    path('refunds/process/', views.RefundProcessView.as_view(), name='refund-process'),
]

# Mock endpoints (only available in DEBUG mode)
if settings.DEBUG:
    urlpatterns.append(
        path('mock-confirm/', views.MockPaymentConfirmView.as_view(), name='mock-payment-confirm')
    )
```

# ==== apps/payments/views.py ====

```python
# backend/apps/payments/views.py
import stripe
import logging
from rest_framework import generics, status, permissions
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.shortcuts import get_object_or_404
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from django.http import HttpResponse
from django.conf import settings
from django.utils import timezone
from django.core.cache import cache
from django.db import transaction, models  # ADDED models HERE
from django.contrib.auth import get_user_model  # NEW

from .models import Payment, Refund, PaymentAudit
from .serializers import (
    PaymentIntentCreateSerializer,
    PaymentSerializer,
    PaymentConfirmSerializer,
    RefundCreateSerializer,
    RefundSerializer
)
from .services import StripePaymentService
from apps.bookings.models import Booking
from apps.accounts.models import StaffProfile, StaffAction  # NEW

logger = logging.getLogger(__name__)


def _get_system_staff_user():
    """
    Ensure we have a system staff user for webhook-originated actions.
    Prevents IntegrityError when StaffAction.staff_user is NOT NULL.
    """
    User = get_user_model()
    user, _ = User.objects.get_or_create(
        username='system_webhook',
        defaults={'email': 'system@totetaxi.com', 'is_active': True}
    )
    StaffProfile.objects.get_or_create(
        user=user,
        defaults={'role': 'staff', 'phone': '0000000000'}
    )
    return user


class PaymentIntentCreateView(APIView):
    """Create Stripe PaymentIntent for a booking - no authentication required for guest bookings"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = PaymentIntentCreateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        booking_id = serializer.validated_data['booking_id']
        customer_email = serializer.validated_data.get('customer_email')
        
        try:
            booking = Booking.objects.get(id=booking_id, deleted_at__isnull=True)
            
            # Check if payment already exists
            existing_payment = Payment.objects.filter(booking=booking).first()
            if existing_payment and existing_payment.status == 'succeeded':
                return Response(
                    {'error': 'Booking is already paid'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Create PaymentIntent
            payment_data = StripePaymentService.create_payment_intent(
                booking=booking,
                customer_email=customer_email
            )
            
            return Response({
                'payment_intent_id': payment_data['payment_intent_id'],
                'client_secret': payment_data['client_secret'],
                'amount_cents': booking.total_price_cents,
                'amount_dollars': booking.total_price_dollars,
                'booking_number': booking.booking_number
            })
            
        except Booking.DoesNotExist:
            return Response(
                {'error': 'Booking not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            logger.error(f"Error creating payment intent: {str(e)}", exc_info=True)
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class PaymentStatusView(APIView):
    """Check payment status by booking number - no authentication required"""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request, booking_number):
        try:
            booking = Booking.objects.get(booking_number=booking_number, deleted_at__isnull=True)
            payment = Payment.objects.filter(booking=booking).first()
            
            if not payment:
                return Response({
                    'booking_number': booking_number,
                    'payment_status': 'not_created',
                    'booking_status': booking.status
                })
            
            return Response({
                    'booking_number': booking_number,
                    'payment_status': payment.status,
                    'booking_status': booking.status,
                    'amount_dollars': payment.amount_dollars,
                    'processed_at': payment.processed_at
            })
            
        except Booking.DoesNotExist:
            return Response(
                {'error': 'Booking not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )


@method_decorator(csrf_exempt, name='dispatch')
class StripeWebhookView(APIView):
    """
    Production webhook handler for Stripe events
    - Verifies webhook signatures
    - Handles payment_intent.succeeded and payment_intent.payment_failed
    - Idempotent (won't process same event twice)
    - Comprehensive logging and audit trail
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        payload = request.body
        sig_header = request.META.get('HTTP_STRIPE_SIGNATURE')
        
        # Verify webhook signature
        try:
            event = stripe.Webhook.construct_event(
                payload, 
                sig_header, 
                settings.STRIPE_WEBHOOK_SECRET
            )
        except ValueError:
            logger.error("Webhook: Invalid payload")
            return Response(
                {'error': 'Invalid payload'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        except stripe.error.SignatureVerificationError:
            logger.error("Webhook: Invalid signature")
            return Response(
                {'error': 'Invalid signature'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Extract event data
        event_id = event['id']
        event_type = event['type']
        
        # Idempotency check - prevent processing same event twice
        cache_key = f'stripe_event_{event_id}'
        if cache.get(cache_key):
            logger.info(f"Webhook: Event {event_id} already processed, skipping")
            return Response({'status': 'already_processed'}, status=status.HTTP_200_OK)
        
        # Mark event as processed (cache for 24 hours)
        cache.set(cache_key, True, timeout=86400)
        
        logger.info(f"Webhook: Processing event {event_id} of type {event_type}")
        
        # Handle different event types
        if event_type == 'payment_intent.succeeded':
            return self._handle_payment_succeeded(event)
        elif event_type == 'payment_intent.payment_failed':
            return self._handle_payment_failed(event)
        else:
            logger.info(f"Webhook: Unhandled event type {event_type}")
            return Response({'status': 'ignored'}, status=status.HTTP_200_OK)
    
    def _handle_payment_succeeded(self, event):
        """Handle successful payment - update Payment and Booking status"""
        payment_intent = event['data']['object']
        payment_intent_id = payment_intent['id']
        
        try:
            # Find payment record
            payment = Payment.objects.select_related('booking').get(
                stripe_payment_intent_id=payment_intent_id
            )
            
            # Skip if already processed
            if payment.status == 'succeeded':
                logger.info(f"Webhook: Payment {payment.id} already marked as succeeded")
                return Response({'status': 'already_succeeded'}, status=status.HTTP_200_OK)
            
            # Update payment status
            payment.status = 'succeeded'
            payment.stripe_charge_id = payment_intent.get('latest_charge', '')
            payment.processed_at = timezone.now()
            payment.save()
            
            # Update booking status from pending to paid
            booking = payment.booking
            if booking.status == 'pending':
                old_status = booking.status
                booking.status = 'paid'
                booking.save()
                
                logger.info(
                    f"Webhook: Booking {booking.booking_number} status updated: "
                    f"{old_status} → {booking.status}"
                )
                
                # Create audit log (system action, no user)
                StaffAction.objects.create(
                    staff_user=_get_system_staff_user(),  # ← use system staff user
                    action_type='modify_booking',
                    description=(
                        f"Booking {booking.booking_number} automatically confirmed via Stripe webhook. "
                        f"Payment: ${payment.amount_dollars:.2f}"
                    ),
                    ip_address='127.0.0.1',
                    user_agent='Stripe Webhook',
                    booking_id=booking.id
                )
            
            # Log payment audit
            PaymentAudit.log(
                action='payment_succeeded',
                description=(
                    f"Payment succeeded for booking {booking.booking_number} "
                    f"via Stripe webhook (Event: {event['id']})"
                ),
                payment=payment,
                user=None
            )
            
            logger.info(
                f"Webhook: Successfully processed payment_intent.succeeded for "
                f"booking {booking.booking_number}"
            )
            
            return Response({
                'status': 'success',
                'booking_number': booking.booking_number,
                'booking_status': booking.status
            }, status=status.HTTP_200_OK)
            
        except Payment.DoesNotExist:
            logger.error(
                f"Webhook: Payment not found for payment_intent_id {payment_intent_id}"
            )
            return Response(
                {'error': 'Payment not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            logger.error(
                f"Webhook: Error processing payment_intent.succeeded: {str(e)}",
                exc_info=True
            )
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
    
    def _handle_payment_failed(self, event):
        """Handle failed payment - mark as failed, keep booking pending"""
        payment_intent = event['data']['object']
        payment_intent_id = payment_intent['id']
        
        try:
            payment = Payment.objects.select_related('booking').get(
                stripe_payment_intent_id=payment_intent_id
            )
            
            # Update payment to failed
            payment.status = 'failed'
            payment.failure_reason = payment_intent.get(
                'last_payment_error', {}
            ).get('message', 'Payment failed')
            payment.save()
            
            # Keep booking as pending so customer can retry
            booking = payment.booking
            if booking.status != 'pending':
                booking.status = 'pending'
                booking.save()
            
            # Log audit
            PaymentAudit.log(
                action='payment_failed',
                description=(
                    f"Payment failed for booking {booking.booking_number}. "
                    f"Reason: {payment.failure_reason}"
                ),
                payment=payment,
                user=None
            )
            
            logger.warning(
                f"Webhook: Payment failed for booking {booking.booking_number}. "
                f"Reason: {payment.failure_reason}"
            )
            
            return Response({
                'status': 'payment_failed',
                'booking_number': booking.booking_number,
                'reason': payment.failure_reason
            }, status=status.HTTP_200_OK)
            
        except Payment.DoesNotExist:
            logger.error(
                f"Webhook: Payment not found for failed payment_intent {payment_intent_id}"
            )
            return Response(
                {'error': 'Payment not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            logger.error(
                f"Webhook: Error processing payment_intent.payment_failed: {str(e)}",
                exc_info=True
            )
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class MockPaymentConfirmView(APIView):
    """Mock payment confirmation for testing - disable in production"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = PaymentConfirmSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        payment_intent_id = serializer.validated_data['payment_intent_id']
        status_value = serializer.validated_data['status']
        
        try:
            if status_value == 'succeeded':
                # Confirm payment (updates Payment record)
                payment = StripePaymentService.confirm_payment(payment_intent_id)
                
                if payment and payment.booking:
                    # Update booking status from pending to paid
                    if payment.booking.status == 'pending':
                        payment.booking.status = 'paid'
                        payment.booking.save()
                        logger.info(f"Mock payment: Booking {payment.booking.booking_number} status updated to 'paid'")
                
                return Response({
                    'message': 'Payment confirmed successfully',
                    'payment': PaymentSerializer(payment).data,
                    'booking_status': payment.booking.status if payment else 'unknown'
                })
            else:
                # Handle failed payment
                payment = Payment.objects.get(stripe_payment_intent_id=payment_intent_id)
                payment.status = 'failed'
                payment.failure_reason = serializer.validated_data.get('failure_reason', 'Payment failed')
                payment.save()
                
                # Keep booking as pending for failed payments
                payment.booking.status = 'pending'
                payment.booking.save()
                
                return Response({
                    'message': 'Payment marked as failed',
                    'payment': PaymentSerializer(payment).data,
                    'booking_status': payment.booking.status
                })
                
        except Payment.DoesNotExist:
            return Response(
                {'error': 'Payment not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            logger.error(f"Mock payment error: {str(e)}", exc_info=True)
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class PaymentConfirmView(APIView):
    """Confirm payment after Stripe processes it - called from frontend"""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        payment_intent_id = request.data.get('payment_intent_id')
        
        if not payment_intent_id:
            return Response(
                {'error': 'payment_intent_id is required'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Service handles payment update, booking status, customer stats
            payment = StripePaymentService.confirm_payment(payment_intent_id)
            
            if not payment:
                return Response(
                    {'error': 'Payment confirmation failed'}, 
                    status=status.HTTP_500_INTERNAL_SERVER_ERROR
                )
            
            return Response({
                'message': 'Payment confirmed successfully',
                'booking_status': payment.booking.status if payment.booking else None,
                'payment_status': payment.status
            })
            
        except Payment.DoesNotExist:
            return Response(
                {'error': 'Payment not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            logger.error(f"Payment confirm error: {str(e)}", exc_info=True)
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


# Staff payment management views
class PaymentListView(generics.ListAPIView):
    """List all payments - staff only"""
    serializer_class = PaymentSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        if not hasattr(self.request.user, 'staff_profile'):
            return Payment.objects.none()
        return Payment.objects.all().order_by('-created_at')


class RefundListView(generics.ListAPIView):
    """List all refunds - staff only, optionally filter by booking"""
    serializer_class = RefundSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        if not hasattr(self.request.user, 'staff_profile'):
            return Refund.objects.none()
        
        queryset = Refund.objects.select_related(
            'payment__booking', 'requested_by', 'approved_by'
        ).order_by('-created_at')
        
        # Filter by booking if provided
        booking_id = self.request.query_params.get('booking_id')
        if booking_id:
            queryset = queryset.filter(payment__booking__id=booking_id)
        
        # Filter by payment if provided
        payment_id = self.request.query_params.get('payment_id')
        if payment_id:
            queryset = queryset.filter(payment__id=payment_id)
        
        return queryset


class RefundCreateView(generics.CreateAPIView):
    """Create refund request - staff only"""
    serializer_class = RefundCreateSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def perform_create(self, serializer):
        if not hasattr(self.request.user, 'staff_profile'):
            raise permissions.PermissionDenied('Not a staff account')
        
        serializer.save(requested_by=self.request.user)


class RefundProcessView(APIView):
    """Process refund immediately - staff only (direct refund, no approval)"""
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        # Verify staff
        if not hasattr(request.user, 'staff_profile'):
            return Response(
                {'error': 'Not a staff account'}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        # Validate input
        payment_id = request.data.get('payment_id')
        amount_cents = request.data.get('amount_cents')
        reason = request.data.get('reason', 'No reason provided').strip()
        
        if not payment_id or not amount_cents:
            return Response(
                {'error': 'payment_id and amount_cents are required'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            amount_cents = int(amount_cents)
            if amount_cents <= 0:
                raise ValueError("Amount must be positive")
        except (ValueError, TypeError):
            return Response(
                {'error': 'Invalid amount_cents'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # REMOVED THE 10 CHARACTER MINIMUM CHECK
        
        try:
            # Get payment
            payment = Payment.objects.select_related('booking').get(id=payment_id)
            
            # Validate payment status
            if payment.status != 'succeeded':
                return Response(
                    {'error': f'Cannot refund payment with status: {payment.status}'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Validate amount
            if amount_cents > payment.amount_cents:
                return Response(
                    {'error': f'Refund amount cannot exceed payment amount (${payment.amount_dollars})'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Check if already refunded
            existing_refunds_total = Refund.objects.filter(
                payment=payment,
                status='completed'
            ).aggregate(total=models.Sum('amount_cents'))['total'] or 0
            
            if existing_refunds_total + amount_cents > payment.amount_cents:
                remaining = payment.amount_cents - existing_refunds_total
                return Response(
                    {'error': f'Only ${remaining/100:.2f} remaining to refund'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Process refund via Stripe
            with transaction.atomic():
                refund = StripePaymentService.create_refund(
                    payment=payment,
                    amount_cents=amount_cents,
                    reason=reason,
                    requested_by_user=request.user
                )
                
                logger.info(
                    f"Refund processed by {request.user.get_full_name()}: "
                    f"${amount_cents/100:.2f} for booking {payment.booking.booking_number}"
                )
            
            # Return success with refund details
            return Response({
                'message': 'Refund processed successfully',
                'refund': RefundSerializer(refund).data
            }, status=status.HTTP_201_CREATED)
            
        except Payment.DoesNotExist:
            return Response(
                {'error': 'Payment not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            logger.error(f"Refund processing error: {str(e)}", exc_info=True)
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
```

# ==== apps/services/__init__.py ====

```python

```

# ==== apps/services/admin.py ====

```python
# backend/apps/services/admin.py
from django.contrib import admin
from django.utils.html import format_html
from .models import (
    MiniMovePackage, 
    OrganizingService,
    StandardDeliveryConfig, 
    SpecialtyItem, 
    SurchargeRule
)


@admin.register(MiniMovePackage)
class MiniMovePackageAdmin(admin.ModelAdmin):
    list_display = ('name', 'package_type', 'base_price_dollars', 'max_items', 'coi_included', 'is_most_popular', 'is_active', 'get_organizing_services')
    list_filter = ('package_type', 'coi_included', 'is_most_popular', 'is_active')
    search_fields = ('name', 'description')
    ordering = ('base_price_cents',)
    
    fieldsets = (
        ('Package Details', {
            'fields': ('package_type', 'name', 'description', 'is_most_popular', 'is_active')
        }),
        ('Pricing', {
            'fields': ('base_price_cents', 'coi_included', 'coi_fee_cents')
        }),
        ('Limits & Features', {
            'fields': ('max_items', 'max_weight_per_item_lbs', 'priority_scheduling', 'protective_wrapping')
        })
    )
    
    def get_organizing_services(self, obj):
        organizing_services = OrganizingService.objects.filter(
            mini_move_tier=obj.package_type,
            is_active=True
        )
        if organizing_services.exists():
            services = []
            for service in organizing_services:
                service_type = "📦 Packing" if service.is_packing_service else "📤 Unpacking"
                services.append(f"{service_type}: ${service.price_dollars}")
            return format_html("<br>".join(services))
        return "❌ No organizing services"
    get_organizing_services.short_description = 'Available Organizing Services'


@admin.register(OrganizingService)
class OrganizingServiceAdmin(admin.ModelAdmin):
    list_display = (
        'name', 
        'get_tier_badge', 
        'get_service_type_badge', 
        'price_dollars', 
        'duration_hours', 
        'organizer_count',
        'supplies_allowance_dollars',
        'is_active'
    )
    list_filter = ('mini_move_tier', 'is_packing_service', 'is_active')
    search_fields = ('name', 'description')
    ordering = ('mini_move_tier', 'is_packing_service', 'price_cents')
    
    fieldsets = (
        ('Service Details', {
            'fields': ('service_type', 'mini_move_tier', 'name', 'description', 'is_active')
        }),
        ('Pricing & Specs', {
            'fields': ('price_cents', 'duration_hours', 'organizer_count')
        }),
        ('Service Classification', {
            'fields': ('is_packing_service', 'supplies_allowance_cents')
        })
    )
    
    readonly_fields = ('service_type',)
    
    def get_tier_badge(self, obj):
        colors = {
            'petite': '#fbbf24',
            'standard': '#3b82f6',
            'full': '#10b981'
        }
        color = colors.get(obj.mini_move_tier, '#6b7280')
        return format_html(
            '<span style="background: {}; color: white; padding: 2px 8px; border-radius: 4px; font-weight: bold;">{}</span>',
            color,
            obj.mini_move_tier.title()
        )
    get_tier_badge.short_description = 'Move Tier'
    
    def get_service_type_badge(self, obj):
        if obj.is_packing_service:
            return format_html(
                '<span style="color: #059669;">📦 Packing</span>'
            )
        else:
            return format_html(
                '<span style="color: #0284c7;">📤 Unpacking</span>'
            )
    get_service_type_badge.short_description = 'Service Type'
    
    def save_model(self, request, obj, form, change):
        service_prefix = f"{obj.mini_move_tier}_"
        service_suffix = "packing" if obj.is_packing_service else "unpacking"
        obj.service_type = service_prefix + service_suffix
        super().save_model(request, obj, form, change)


@admin.register(StandardDeliveryConfig)
class StandardDeliveryConfigAdmin(admin.ModelAdmin):
    list_display = ('price_per_item_dollars', 'minimum_items', 'minimum_charge_dollars', 'same_day_flat_rate_dollars', 'is_active')
    fieldsets = (
        ('Per-Item Pricing', {
            'fields': ('price_per_item_cents', 'minimum_items', 'minimum_charge_cents')
        }),
        ('Same-Day Delivery', {
            'fields': ('same_day_flat_rate_cents',)
        }),
        ('Constraints', {
            'fields': ('max_weight_per_item_lbs', 'is_active')
        })
    )
    
    def same_day_flat_rate_dollars(self, obj):
        return f"${obj.same_day_flat_rate_cents / 100:.0f}"
    same_day_flat_rate_dollars.short_description = 'Same-Day Rate'


# apps/services/admin.py

@admin.register(SpecialtyItem)
class SpecialtyItemAdmin(admin.ModelAdmin):
    list_display = ('name', 'item_type', 'price_dollars', 'special_handling', 'is_active')
    list_filter = ('item_type', 'special_handling', 'is_active')
    search_fields = ('name', 'description')
    
    # ✅ ADD THIS: Bulk actions
    actions = ['mark_as_inactive', 'mark_as_active']
    
    fieldsets = (
        ('Item Details', {
            'fields': ('item_type', 'name', 'description', 'is_active')
        }),
        ('Pricing', {
            'fields': ('price_cents',)
        }),
        ('Requirements', {
            'fields': ('special_handling',)
        })
    )
    
    # ✅ ADD THESE METHODS:
    @admin.action(description='Mark selected items as inactive')
    def mark_as_inactive(self, request, queryset):
        updated = queryset.update(is_active=False)
        self.message_user(request, f'{updated} specialty item(s) marked as inactive.')
    
    @admin.action(description='Mark selected items as active')
    def mark_as_active(self, request, queryset):
        updated = queryset.update(is_active=True)
        self.message_user(request, f'{updated} specialty item(s) marked as active.')
        
@admin.register(SurchargeRule)
class SurchargeRuleAdmin(admin.ModelAdmin):
    list_display = ('name', 'surcharge_type', 'applies_to_service_type', 'calculation_type', 'get_surcharge_display', 'get_applies_to', 'is_active')
    list_filter = ('surcharge_type', 'applies_to_service_type', 'calculation_type', 'is_active', 'applies_saturday', 'applies_sunday')
    search_fields = ('name', 'description')
    
    fieldsets = (
        ('Rule Details', {
            'fields': ('surcharge_type', 'name', 'description', 'applies_to_service_type', 'is_active')
        }),
        ('Calculation', {
            'fields': ('calculation_type', 'percentage', 'fixed_amount_cents')
        }),
        ('Date Rules', {
            'fields': ('specific_date', 'applies_saturday', 'applies_sunday'),
            'description': 'Set specific date OR weekend days, not both'
        })
    )
    
    def get_surcharge_display(self, obj):
        if obj.calculation_type == 'percentage' and obj.percentage:
            return format_html('<span style="color: #059669; font-weight: bold;">{}%</span>', obj.percentage)
        elif obj.calculation_type == 'fixed_amount' and obj.fixed_amount_cents:
            return format_html('<span style="color: #dc2626; font-weight: bold;">${}</span>', obj.fixed_amount_cents / 100)
        return "❌ Not configured"
    get_surcharge_display.short_description = 'Surcharge Amount'
    
    def get_applies_to(self, obj):
        applies_to = []
        if obj.specific_date:
            applies_to.append(f"📅 {obj.specific_date}")
        if obj.applies_saturday:
            applies_to.append("🗓️ Saturdays")
        if obj.applies_sunday:
            applies_to.append("🗓️ Sundays")
        
        if applies_to:
            return format_html("<br>".join(applies_to))
        return "❓ No dates set"
    get_applies_to.short_description = 'Applies To'


admin.site.site_header = "ToteTaxi Admin"
admin.site.site_title = "ToteTaxi Admin Portal"
admin.site.index_title = "Welcome to ToteTaxi Administration"
```

# ==== apps/services/apps.py ====

```python
from django.apps import AppConfig


class ServicesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.services'
```

# ==== apps/services/management/__init__.py ====

```python

```

# ==== apps/services/management/commands/__init__.py ====

```python

```

# ==== apps/services/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.5 on 2025-09-02 20:54

import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='MiniMovePackage',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('package_type', models.CharField(choices=[('petite', 'Petite'), ('standard', 'Standard'), ('full', 'Full Move')], max_length=20, unique=True)),
                ('name', models.CharField(max_length=50)),
                ('description', models.TextField()),
                ('base_price_cents', models.PositiveBigIntegerField()),
                ('max_items', models.PositiveIntegerField(blank=True, help_text='Maximum items allowed (null = unlimited for Full Move)', null=True)),
                ('max_weight_per_item_lbs', models.PositiveIntegerField(default=50)),
                ('coi_included', models.BooleanField(default=False)),
                ('coi_fee_cents', models.PositiveBigIntegerField(default=5000, help_text='COI fee in cents if not included')),
                ('priority_scheduling', models.BooleanField(default=False)),
                ('protective_wrapping', models.BooleanField(default=False)),
                ('is_most_popular', models.BooleanField(default=False)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'services_mini_move_package',
                'ordering': ['base_price_cents'],
            },
        ),
        migrations.CreateModel(
            name='SpecialtyItem',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('item_type', models.CharField(choices=[('peloton', 'Peloton'), ('surfboard', 'Surfboard'), ('crib', 'Crib'), ('wardrobe_box', 'Wardrobe Box')], max_length=30, unique=True)),
                ('name', models.CharField(max_length=100)),
                ('description', models.TextField(blank=True)),
                ('price_cents', models.PositiveBigIntegerField()),
                ('requires_van_schedule', models.BooleanField(default=True, help_text='Can only be booked when van is already scheduled')),
                ('special_handling', models.BooleanField(default=True)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'services_specialty_item',
            },
        ),
        migrations.CreateModel(
            name='StandardDeliveryConfig',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('price_per_item_cents', models.PositiveBigIntegerField(default=9500, help_text='Price per item in cents')),
                ('minimum_items', models.PositiveIntegerField(default=3, help_text='Minimum number of items for delivery')),
                ('minimum_charge_cents', models.PositiveBigIntegerField(default=28500, help_text='Minimum delivery charge in cents')),
                ('same_day_flat_rate_cents', models.PositiveBigIntegerField(default=36000, help_text='Flat rate for same-day delivery')),
                ('max_weight_per_item_lbs', models.PositiveIntegerField(default=50, help_text='Maximum weight per item in pounds')),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'services_standard_delivery_config',
            },
        ),
        migrations.CreateModel(
            name='SurchargeRule',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('surcharge_type', models.CharField(choices=[('weekend', 'Weekend Surcharge'), ('holiday', 'Holiday Surcharge'), ('peak_date', 'Peak Date Surcharge')], max_length=20)),
                ('name', models.CharField(max_length=100)),
                ('description', models.TextField(blank=True)),
                ('calculation_type', models.CharField(choices=[('percentage', 'Percentage'), ('fixed_amount', 'Fixed Amount')], max_length=20)),
                ('percentage', models.DecimalField(blank=True, decimal_places=2, help_text='Percentage surcharge (e.g., 15.00 for 15%)', max_digits=5, null=True)),
                ('fixed_amount_cents', models.PositiveBigIntegerField(blank=True, help_text='Fixed surcharge amount in cents', null=True)),
                ('specific_date', models.DateField(blank=True, help_text='Specific date for peak date surcharges', null=True)),
                ('applies_saturday', models.BooleanField(default=False)),
                ('applies_sunday', models.BooleanField(default=False)),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'services_surcharge_rule',
            },
        ),
        migrations.CreateModel(
            name='VanSchedule',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date', models.DateField(unique=True)),
                ('is_available', models.BooleanField(default=True, help_text='Van is available for pickups on this date')),
                ('mini_moves_booked', models.PositiveIntegerField(default=0)),
                ('specialty_items_booked', models.PositiveIntegerField(default=0)),
                ('max_capacity', models.PositiveIntegerField(default=10, help_text='Maximum bookings for this date')),
                ('notes', models.TextField(blank=True, help_text='Internal notes about availability or restrictions')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'services_van_schedule',
                'ordering': ['date'],
            },
        ),
    ]
```

# ==== apps/services/migrations/0002_organizingservice.py ====

```python
# Generated by Django 5.2.5 on 2025-09-08 21:42

import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('services', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='OrganizingService',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('service_type', models.CharField(choices=[('petite_packing', 'Petite Packing'), ('standard_packing', 'Standard Packing'), ('full_packing', 'Full Packing'), ('petite_unpacking', 'Petite Unpacking'), ('standard_unpacking', 'Standard Unpacking'), ('full_unpacking', 'Full Unpacking')], max_length=30, unique=True)),
                ('mini_move_tier', models.CharField(choices=[('petite', 'Petite'), ('standard', 'Standard'), ('full', 'Full')], max_length=20)),
                ('name', models.CharField(max_length=100)),
                ('description', models.TextField(blank=True)),
                ('price_cents', models.PositiveBigIntegerField()),
                ('duration_hours', models.PositiveIntegerField()),
                ('organizer_count', models.PositiveIntegerField()),
                ('supplies_allowance_cents', models.PositiveBigIntegerField(default=0, help_text='Supplies allowance in cents (packing services only)')),
                ('is_packing_service', models.BooleanField(help_text='True for packing services (with supplies), False for unpacking (organizing only)')),
                ('is_active', models.BooleanField(default=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'services_organizing_service',
                'ordering': ['mini_move_tier', 'is_packing_service', 'price_cents'],
            },
        ),
    ]
```

# ==== apps/services/migrations/0003_populate_organizing_services.py ====

```python
# Generated by Django 5.2.5 on 2025-09-08 21:42

from django.db import migrations


def populate_organizing_services(apps, schema_editor):
    """Populate organizing services with initial pricing data"""
    OrganizingService = apps.get_model('services', 'OrganizingService')
    
    # Create all 6 organizing services
    organizing_services = [
        # PETITE TIER
        {
            'service_type': 'petite_packing',
            'mini_move_tier': 'petite',
            'name': 'Petite Packing',
            'description': '1/2 day (up to 4 hours) with 2 organizers. Includes garment bags, moving bags + additional packing supplies upon request (up to $250).',
            'price_cents': 140000,  # $1,400
            'duration_hours': 4,
            'organizer_count': 2,
            'supplies_allowance_cents': 25000,  # $250
            'is_packing_service': True,
            'is_active': True,
        },
        {
            'service_type': 'petite_unpacking',
            'mini_move_tier': 'petite',
            'name': 'Petite Unpacking',
            'description': '1/2 day (up to 4 hours) with 2 organizers. Organizing light (no supplies).',
            'price_cents': 113000,  # $1,130
            'duration_hours': 4,
            'organizer_count': 2,
            'supplies_allowance_cents': 0,  # No supplies for unpacking
            'is_packing_service': False,
            'is_active': True,
        },
        
        # STANDARD TIER
        {
            'service_type': 'standard_packing',
            'mini_move_tier': 'standard',
            'name': 'Standard Packing',
            'description': '1 day (up to 8 hours) with 2 organizers. Includes garment bags, moving bags + additional packing supplies upon request (up to $250).',
            'price_cents': 253500,  # $2,535
            'duration_hours': 8,
            'organizer_count': 2,
            'supplies_allowance_cents': 25000,  # $250
            'is_packing_service': True,
            'is_active': True,
        },
        {
            'service_type': 'standard_unpacking',
            'mini_move_tier': 'standard',
            'name': 'Standard Unpacking',
            'description': '1 day (up to 8 hours) with 2 organizers. Organizing light (no supplies).',
            'price_cents': 226500,  # $2,265
            'duration_hours': 8,
            'organizer_count': 2,
            'supplies_allowance_cents': 0,  # No supplies for unpacking
            'is_packing_service': False,
            'is_active': True,
        },
        
        # FULL TIER
        {
            'service_type': 'full_packing',
            'mini_move_tier': 'full',
            'name': 'Full Packing',
            'description': '1 day (up to 8 hours) with 4 organizers. Includes garment bags, moving bags + additional packing supplies upon request (up to $500).',
            'price_cents': 507000,  # $5,070
            'duration_hours': 8,
            'organizer_count': 4,
            'supplies_allowance_cents': 50000,  # $500
            'is_packing_service': True,
            'is_active': True,
        },
        {
            'service_type': 'full_unpacking',
            'mini_move_tier': 'full',
            'name': 'Full Unpacking',
            'description': '1 day (up to 8 hours) with 4 organizers. Organizing light (no supplies).',
            'price_cents': 452500,  # $4,525
            'duration_hours': 8,
            'organizer_count': 4,
            'supplies_allowance_cents': 0,  # No supplies for unpacking
            'is_packing_service': False,
            'is_active': True,
        },
    ]
    
    # Create all organizing services
    for service_data in organizing_services:
        OrganizingService.objects.get_or_create(
            service_type=service_data['service_type'],
            defaults=service_data
        )


def reverse_populate_organizing_services(apps, schema_editor):
    """Remove organizing services data"""
    OrganizingService = apps.get_model('services', 'OrganizingService')
    OrganizingService.objects.all().delete()


class Migration(migrations.Migration):

    dependencies = [
        ('services', '0002_organizingservice'),
    ]

    operations = [
        migrations.RunPython(
            populate_organizing_services,
            reverse_populate_organizing_services
        ),
    ]
```

# ==== apps/services/migrations/0004_surchargerule_applies_to_service_type.py ====

```python
# Generated by Django 5.2.5 on 2025-09-20 16:20

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('services', '0003_populate_organizing_services'),
    ]

    operations = [
        migrations.AddField(
            model_name='surchargerule',
            name='applies_to_service_type',
            field=models.CharField(choices=[('all', 'All Services'), ('mini_move', 'Mini Moves Only'), ('standard_delivery', 'Standard Delivery Only'), ('specialty_item', 'Specialty Items Only')], default='all', help_text='Which service types this surcharge applies to', max_length=20),
        ),
    ]
```

# ==== apps/services/migrations/0005_remove_van_schedule.py ====

```python
# Generated by Django 5.2.5 on 2025-09-20 16:41

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('services', '0004_surchargerule_applies_to_service_type'),
    ]

    operations = [
        migrations.DeleteModel(
            name='VanSchedule',
        ),
    ]
```

# ==== apps/services/migrations/0006_remove_specialtyitem_requires_van_schedule.py ====

```python
# Generated by Django 5.2.5 on 2025-10-02 15:14

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('services', '0005_remove_van_schedule'),
    ]

    operations = [
        migrations.RemoveField(
            model_name='specialtyitem',
            name='requires_van_schedule',
        ),
    ]
```

# ==== apps/services/migrations/0007_remove_specialty_item_choices.py ====

```python
# Generated by Django 5.2.5 on 2025-10-18 16:33

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('services', '0006_remove_specialtyitem_requires_van_schedule'),
    ]

    operations = [
        migrations.AlterField(
            model_name='specialtyitem',
            name='item_type',
            field=models.CharField(help_text="Unique identifier for this specialty item (e.g., 'bicycle', 'kayak')", max_length=30, unique=True),
        ),
    ]
```

# ==== apps/services/migrations/__init__.py ====

```python

```

# ==== apps/services/models.py ====

```python
# backend/apps/services/models.py
import uuid
from django.db import models
from django.utils import timezone
from decimal import Decimal


class MiniMovePackage(models.Model):
    """Mini Move service packages from homework: Petite, Standard, Full"""
    
    PACKAGE_TYPES = [
        ('petite', 'Petite'),
        ('standard', 'Standard'), 
        ('full', 'Full Move'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Package details
    package_type = models.CharField(max_length=20, choices=PACKAGE_TYPES, unique=True)
    name = models.CharField(max_length=50)
    description = models.TextField()
    
    # Pricing
    base_price_cents = models.PositiveBigIntegerField()
    
    # Item limits
    max_items = models.PositiveIntegerField(
        null=True, 
        blank=True,
        help_text="Maximum items allowed (null = unlimited for Full Move)"
    )
    max_weight_per_item_lbs = models.PositiveIntegerField(default=50)
    
    # COI handling
    coi_included = models.BooleanField(default=False)
    coi_fee_cents = models.PositiveBigIntegerField(
        default=5000,  # $50
        help_text="COI fee in cents if not included"
    )
    
    # Features
    priority_scheduling = models.BooleanField(default=False)
    protective_wrapping = models.BooleanField(default=False)
    
    # Marketing
    is_most_popular = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'services_mini_move_package'
        ordering = ['base_price_cents']
    
    def __str__(self):
        return f"{self.name} - ${self.base_price_dollars}"
    
    @property
    def base_price_dollars(self):
        return self.base_price_cents / 100
    
    @property
    def coi_fee_dollars(self):
        return self.coi_fee_cents / 100


class OrganizingService(models.Model):
    """Professional packing/unpacking services tied to Mini Move tiers"""
    
    ORGANIZING_TYPES = [
        ('petite_packing', 'Petite Packing'),
        ('standard_packing', 'Standard Packing'),
        ('full_packing', 'Full Packing'),
        ('petite_unpacking', 'Petite Unpacking'),
        ('standard_unpacking', 'Standard Unpacking'),
        ('full_unpacking', 'Full Unpacking'),
    ]
    
    MINI_MOVE_TIERS = [
        ('petite', 'Petite'),
        ('standard', 'Standard'),
        ('full', 'Full'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Service details
    service_type = models.CharField(max_length=30, choices=ORGANIZING_TYPES, unique=True)
    mini_move_tier = models.CharField(max_length=20, choices=MINI_MOVE_TIERS)
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    
    # Pricing
    price_cents = models.PositiveBigIntegerField()
    
    # Service specs
    duration_hours = models.PositiveIntegerField()
    organizer_count = models.PositiveIntegerField()
    supplies_allowance_cents = models.PositiveBigIntegerField(
        default=0,
        help_text="Supplies allowance in cents (packing services only)"
    )
    
    # Service type classification
    is_packing_service = models.BooleanField(
        help_text="True for packing services (with supplies), False for unpacking (organizing only)"
    )
    
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'services_organizing_service'
        ordering = ['mini_move_tier', 'is_packing_service', 'price_cents']
    
    def __str__(self):
        return f"{self.name} - ${self.price_dollars}"
    
    @property
    def price_dollars(self):
        return self.price_cents / 100
    
    @property
    def supplies_allowance_dollars(self):
        return self.supplies_allowance_cents / 100
    
    def can_be_added_to_mini_move(self, mini_move_package_type):
        """Check if this organizing service can be added to a specific mini move tier"""
        return self.mini_move_tier == mini_move_package_type


class StandardDeliveryConfig(models.Model):
    """Configuration for Standard Delivery pricing from homework"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Per-item pricing
    price_per_item_cents = models.PositiveBigIntegerField(
        default=9500,  # $95
        help_text="Price per item in cents"
    )
    
    # Minimums
    minimum_items = models.PositiveIntegerField(
        default=3,
        help_text="Minimum number of items for delivery"
    )
    minimum_charge_cents = models.PositiveBigIntegerField(
        default=28500,  # $285
        help_text="Minimum delivery charge in cents"
    )
    
    # Same-day delivery
    same_day_flat_rate_cents = models.PositiveBigIntegerField(
        default=36000,  # $360
        help_text="Flat rate for same-day delivery"
    )
    
    # Item constraints
    max_weight_per_item_lbs = models.PositiveIntegerField(
        default=50,
        help_text="Maximum weight per item in pounds"
    )
    
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'services_standard_delivery_config'
    
    def __str__(self):
        return f"Standard Delivery - ${self.price_per_item_dollars}/item"
    
    @property
    def price_per_item_dollars(self):
        return self.price_per_item_cents / 100
    
    @property
    def minimum_charge_dollars(self):
        return self.minimum_charge_cents / 100
    
    def calculate_total(self, item_count, is_same_day=False):
        """Calculate total for standard delivery"""
        # FIXED: Calculate base delivery cost first
        item_total = self.price_per_item_cents * item_count
        base_cost = max(item_total, self.minimum_charge_cents)
        
        # FIXED: ADD same-day surcharge on top of base cost
        if is_same_day:
            return base_cost + self.same_day_flat_rate_cents
        
        return base_cost


class SpecialtyItem(models.Model):
    """Specialty items - NOW FULLY DYNAMIC (no hardcoded choices)"""
    
    # ✅ REMOVED: ITEM_TYPES constant - items are now fully configurable
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Item details
    item_type = models.CharField(
        max_length=30, 
        unique=True,
        help_text="Unique identifier for this specialty item (e.g., 'bicycle', 'kayak')"
    )
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    
    # Pricing
    price_cents = models.PositiveBigIntegerField()
    
    # Requirements
    special_handling = models.BooleanField(default=True)
    
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'services_specialty_item'
    
    def __str__(self):
        return f"{self.name} - ${self.price_dollars}"
    
    @property
    def price_dollars(self):
        return self.price_cents / 100


class SurchargeRule(models.Model):
    """Weekend, holiday, and peak date surcharges from homework"""
    
    SURCHARGE_TYPES = [
        ('weekend', 'Weekend Surcharge'),
        ('holiday', 'Holiday Surcharge'),
        ('peak_date', 'Peak Date Surcharge'),
    ]
    
    CALCULATION_TYPES = [
        ('percentage', 'Percentage'),
        ('fixed_amount', 'Fixed Amount'),
    ]
    
    SERVICE_TYPE_CHOICES = [
        ('all', 'All Services'),
        ('mini_move', 'Mini Moves Only'),
        ('standard_delivery', 'Standard Delivery Only'),
        ('specialty_item', 'Specialty Items Only'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Surcharge details
    surcharge_type = models.CharField(max_length=20, choices=SURCHARGE_TYPES)
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    
    # Service type filter
    applies_to_service_type = models.CharField(
        max_length=20,
        choices=SERVICE_TYPE_CHOICES,
        default='all',
        help_text='Which service types this surcharge applies to'
    )
    
    # Calculation
    calculation_type = models.CharField(max_length=20, choices=CALCULATION_TYPES)
    percentage = models.DecimalField(
        max_digits=5, 
        decimal_places=2, 
        null=True, 
        blank=True,
        help_text="Percentage surcharge (e.g., 15.00 for 15%)"
    )
    fixed_amount_cents = models.PositiveBigIntegerField(
        null=True,
        blank=True,
        help_text="Fixed surcharge amount in cents"
    )
    
    # Date rules (for specific dates like Sept 1)
    specific_date = models.DateField(
        null=True,
        blank=True,
        help_text="Specific date for peak date surcharges"
    )
    
    # Day of week rules (for weekend surcharges)
    applies_saturday = models.BooleanField(default=False)
    applies_sunday = models.BooleanField(default=False)
    
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'services_surcharge_rule'
    
    def __str__(self):
        return self.name
    
    def calculate_surcharge(self, base_amount_cents, booking_date, service_type=None):
        """Calculate surcharge for given base amount, date, and service type"""
        if not self.is_active:
            return 0
        
        if not self.applies_to_date(booking_date):
            return 0
        
        if self.applies_to_service_type != 'all':
            if service_type != self.applies_to_service_type:
                return 0
        
        if self.calculation_type == 'percentage' and self.percentage:
            return int(base_amount_cents * (self.percentage / 100))
        elif self.calculation_type == 'fixed_amount' and self.fixed_amount_cents:
            return self.fixed_amount_cents
        
        return 0
    
    def applies_to_date(self, booking_date):
        """Check if surcharge rule applies to given date"""
        if self.specific_date and self.specific_date == booking_date:
            return True
        
        weekday = booking_date.weekday()
        if weekday == 5 and self.applies_saturday:
            return True
        if weekday == 6 and self.applies_sunday:
            return True
        
        return False
    
```

# ==== apps/services/serializers.py ====

```python
# backend/apps/services/serializers.py
from rest_framework import serializers
from .models import (
    MiniMovePackage, 
    OrganizingService, 
    StandardDeliveryConfig, 
    SpecialtyItem, 
    SurchargeRule
)


class MiniMovePackageSerializer(serializers.ModelSerializer):
    base_price_dollars = serializers.ReadOnlyField()
    coi_fee_dollars = serializers.ReadOnlyField()
    
    class Meta:
        model = MiniMovePackage
        fields = (
            'id', 'package_type', 'name', 'description',
            'base_price_dollars', 'max_items', 'coi_included', 'coi_fee_dollars',
            'is_most_popular', 'priority_scheduling', 'protective_wrapping'
        )


class OrganizingServiceSerializer(serializers.ModelSerializer):
    price_dollars = serializers.ReadOnlyField()
    supplies_allowance_dollars = serializers.ReadOnlyField()
    
    class Meta:
        model = OrganizingService
        fields = (
            'id', 'service_type', 'mini_move_tier', 'name', 'description',
            'price_dollars', 'duration_hours', 'organizer_count',
            'supplies_allowance_dollars', 'is_packing_service'
        )


class SpecialtyItemSerializer(serializers.ModelSerializer):
    price_dollars = serializers.ReadOnlyField()
    
    class Meta:
        model = SpecialtyItem
        fields = (
            'id', 'item_type', 'name', 'description', 'price_dollars',
            'special_handling'
        )


class StandardDeliveryConfigSerializer(serializers.ModelSerializer):
    price_per_item_dollars = serializers.ReadOnlyField()
    minimum_charge_dollars = serializers.ReadOnlyField()
    same_day_flat_rate_dollars = serializers.SerializerMethodField()
    
    class Meta:
        model = StandardDeliveryConfig
        fields = (
            'price_per_item_dollars', 'minimum_items', 'minimum_charge_dollars',
            'same_day_flat_rate_dollars', 'max_weight_per_item_lbs'
        )
    
    def get_same_day_flat_rate_dollars(self, obj):
        return obj.same_day_flat_rate_cents / 100


class SurchargeRuleSerializer(serializers.ModelSerializer):
    fixed_amount_dollars = serializers.SerializerMethodField()
    
    class Meta:
        model = SurchargeRule
        fields = (
            'id', 'surcharge_type', 'name', 'description',
            'calculation_type', 'percentage', 'fixed_amount_dollars',
            'specific_date', 'applies_saturday', 'applies_sunday'
        )
    
    def get_fixed_amount_dollars(self, obj):
        return obj.fixed_amount_cents / 100 if obj.fixed_amount_cents else None


class ServiceCatalogSerializer(serializers.Serializer):
    """Complete service catalog with all available services and organizing options"""
    
    mini_move_packages = MiniMovePackageSerializer(many=True, read_only=True)
    organizing_services = OrganizingServiceSerializer(many=True, read_only=True)
    standard_delivery = StandardDeliveryConfigSerializer(read_only=True)
    specialty_items = SpecialtyItemSerializer(many=True, read_only=True)
    
    surcharge_rules = SurchargeRuleSerializer(many=True, read_only=True, required=False)


class OrganizingServicesByTierSerializer(serializers.Serializer):
    """Organizing services grouped by Mini Move tier for easy frontend consumption"""
    
    def to_representation(self, instance):
        organizing_services = OrganizingService.objects.filter(is_active=True)
        
        result = {}
        for tier in ['petite', 'standard', 'full']:
            tier_services = organizing_services.filter(mini_move_tier=tier)
            packing_service = tier_services.filter(is_packing_service=True).first()
            unpacking_service = tier_services.filter(is_packing_service=False).first()
            
            result[tier] = {
                'packing': OrganizingServiceSerializer(packing_service).data if packing_service else None,
                'unpacking': OrganizingServiceSerializer(unpacking_service).data if unpacking_service else None
            }
        
        return result


class MiniMoveWithOrganizingSerializer(serializers.Serializer):
    """Mini Move packages with their available organizing services"""
    
    def to_representation(self, instance):
        packages = MiniMovePackage.objects.filter(is_active=True).order_by('base_price_cents')
        
        result = []
        for package in packages:
            organizing_services = OrganizingService.objects.filter(
                mini_move_tier=package.package_type,
                is_active=True
            )
            
            packing_service = organizing_services.filter(is_packing_service=True).first()
            unpacking_service = organizing_services.filter(is_packing_service=False).first()
            
            package_data = MiniMovePackageSerializer(package).data
            package_data['organizing_options'] = {
                'packing': OrganizingServiceSerializer(packing_service).data if packing_service else None,
                'unpacking': OrganizingServiceSerializer(unpacking_service).data if unpacking_service else None
            }
            
            result.append(package_data)
        
        return result
```

# ==== apps/services/views.py ====

```python
# services/views.py
from django.shortcuts import render

# Create your views here.
```

# ========================= SCRIPTS & UTILITIES =========================


# ==== scripts/back_export.py ====

```python
#!/usr/bin/env python3
"""
ToteTaxi Backend Export - Code Files Only
"""
import os
from pathlib import Path
from datetime import datetime

def get_file_content(file_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        return f"# Error reading file: {e}"

def should_include_file(file_path, base_dir):
    """Smart file inclusion rules for ToteTaxi Backend - Code Only"""
    rel_path = file_path.relative_to(base_dir)
    path_str = str(rel_path)
    
    # Skip patterns - SECURITY: Handle .env files separately
    skip_patterns = [
        '__pycache__', '.pyc', '.git/', '.pytest_cache/', 'htmlcov/',
        'staticfiles/', 'media/', 'logs/', '.coverage', 'db.sqlite3',
        'back_export.txt', 'totetaxi_backend_snapshot.txt',
        '.DS_Store', '*.swp', '*.swo',
        'README.md', 'CHANGELOG.md'  # Skip documentation files
    ]
    
    if any(pattern in path_str for pattern in skip_patterns):
        return False
    
    # SECURITY: Skip .env files (contain secrets)
    if file_path.name.startswith('.env'):
        return False
    
    # Include patterns - Code files only
    include_extensions = {'.py', '.txt', '.yml', '.yaml', '.toml', '.sh', '.ini', '.conf'}
    include_files = {
        'Dockerfile', 'Dockerfile.dev', '.dockerignore', '.gitignore', 
        'manage.py', 'docker-compose.yml', 'docker-compose.prod.yml',
        'gunicorn.conf.py', 'pytest.ini', 'requirements.txt'
    }
    
    return (
        file_path.suffix in include_extensions or 
        file_path.name in include_files
    )

def categorize_file(file_path, base_dir):
    """Auto-categorize files for ToteTaxi structure"""
    rel_path = file_path.relative_to(base_dir)
    path_str = str(rel_path)
    
    # Configuration files (root level)
    if (rel_path.parent == Path('.') or 
        file_path.name in ['manage.py', 'requirements.txt', 'gunicorn.conf.py', 'pytest.ini']):
        return 'config'
    
    # ToteTaxi Django apps - UPDATED to 6 apps only
    totetaxi_apps = [
        'accounts/', 'bookings/', 'customers/', 
        'logistics/', 'payments/', 'services/'
    ]
    if any(f'apps/{app}' in path_str for app in totetaxi_apps):
        return 'apps'
    
    # Django project settings (config/ directory)
    if 'config/' in path_str:
        return 'project'
    
    # Scripts directory
    if 'scripts/' in path_str:
        return 'scripts'
    
    # Everything else
    return 'other'

def main():
    backend_dir = Path(__file__).parent.parent
    output_file = backend_dir / 'scripts' / 'back_export.txt'
    
    print(f"🔍 Auto-discovering ToteTaxi backend files in: {backend_dir}")
    
    # Auto-discover all relevant files
    all_files = []
    for file_path in backend_dir.rglob('*'):
        if file_path.is_file() and should_include_file(file_path, backend_dir):
            all_files.append(file_path)
    
    # Categorize files
    categories = {
        'config': [],
        'project': [],
        'apps': [],
        'scripts': [],
        'other': []
    }
    
    for file_path in all_files:
        category = categorize_file(file_path, backend_dir)
        categories[category].append(file_path)
    
    # Sort within categories
    for category in categories:
        categories[category].sort()
    
    print(f"📊 Found {len(all_files)} files:")
    for cat, files in categories.items():
        if files:
            print(f"  - {cat}: {len(files)} files")
    
    # Generate snapshot
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# TOTETAXI - BACKEND CODE SNAPSHOT\n")
        f.write("# AUTO-GENERATED - CODE FILES ONLY\n")
        f.write(f"# Created: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"# Total files: {len(all_files)}\n")
        f.write("# 🔒 SECURITY: .env files excluded (contain secrets)\n")
        f.write("# 📋 INCLUDES: All Django apps, migrations, configuration\n")
        f.write("# Apps: accounts (STAFF), bookings, customers, logistics, payments, services\n")  # UPDATED
        f.write("# Tech Stack: Django 5.2.5, DRF 3.16.1, PostgreSQL, Redis, Celery\n")
        f.write("# Integration: S3 storage, SES email, mocked Stripe/Onfleet\n\n\n")
        
        # Output by category
        section_names = {
            'config': 'CONFIGURATION & ROOT FILES',
            'project': 'DJANGO PROJECT SETTINGS (config/)',
            'apps': 'DJANGO APPLICATIONS (apps/)',
            'scripts': 'SCRIPTS & UTILITIES',
            'other': 'OTHER FILES'
        }
        
        for category, section_name in section_names.items():
            if categories[category]:
                f.write("# " + "="*25 + f" {section_name} " + "="*25 + "\n\n\n")
                
                for file_path in categories[category]:
                    rel_path = file_path.relative_to(backend_dir)
                    f.write(f"# ==== {rel_path} ====\n\n")
                    
                    # Smart syntax highlighting
                    if file_path.suffix == '.py':
                        f.write("```python\n")
                    elif file_path.suffix in ['.yml', '.yaml']:
                        f.write("```yaml\n")
                    elif file_path.suffix == '.toml':
                        f.write("```toml\n")
                    elif file_path.suffix == '.sh':
                        f.write("```bash\n")
                    elif file_path.name in ['Dockerfile', 'Dockerfile.dev']:
                        f.write("```dockerfile\n")
                    elif file_path.suffix == '.ini':
                        f.write("```ini\n")
                    else:
                        f.write("```\n")
                    
                    content = get_file_content(file_path)
                    f.write(content)
                    if not content.endswith('\n'):
                        f.write('\n')
                    f.write("```\n\n")
    
    print(f"✅ Auto-generated ToteTaxi backend snapshot: {output_file}")
    print("🔒 SECURITY: .env files excluded (contain secrets)")
    print("📋 INCLUDES: All 6 Django apps with migrations")  # UPDATED
    print("🏗️  STRUCTURE: accounts (staff), bookings, customers, logistics, payments, services")  # UPDATED
    print("🐳 DOCKER: Configuration and compose files included")
    print("📁 CODE ONLY: Documentation files excluded")

if __name__ == "__main__":
    main()
```

# ==== scripts/entrypoint.sh ====

```bash
#!/bin/bash
set -e

echo "Starting ToteTaxi Backend..."

# CRITICAL FIX: Unset docker-compose DB variables on Fly.io
unset DB_HOST
unset DB_NAME
unset DB_USER
unset DB_PASSWORD
unset DB_PORT

# Wait for database if DB_HOST is set (won't happen after unset)
if [ -n "$DB_HOST" ]; then
    echo "Waiting for postgres at $DB_HOST:${DB_PORT:-5432}..."
    while ! pg_isready -h "$DB_HOST" -p "${DB_PORT:-5432}" -U "${DB_USER:-postgres}"; do
      sleep 1
    done
    echo "PostgreSQL is ready!"
fi

# Run migrations
echo "Running database migrations..."
python manage.py migrate --no-input

# Collect static files (in case not done in Dockerfile)
echo "Collecting static files..."
python manage.py collectstatic --no-input --clear || true

# Create cache table if needed
python manage.py createcachetable || true

# Create superuser if specified (optional)
if [ -n "$DJANGO_SUPERUSER_EMAIL" ] && [ -n "$DJANGO_SUPERUSER_PASSWORD" ]; then
    echo "Creating superuser..."
    python manage.py shell -c "
from django.contrib.auth import get_user_model
User = get_user_model()
if not User.objects.filter(email='$DJANGO_SUPERUSER_EMAIL').exists():
    User.objects.create_superuser('$DJANGO_SUPERUSER_EMAIL', '$DJANGO_SUPERUSER_EMAIL', '$DJANGO_SUPERUSER_PASSWORD')
    print('Superuser created')
else:
    print('Superuser already exists')
" || true
fi

echo "Starting application..."
exec "$@"
```

# ==== scripts/validate_ses_setup.py ====

```python
# backend/scripts/validate_ses_setup.py
"""
Validate SES setup for production
Run locally: docker-compose exec web python manage.py shell < scripts/validate_ses_setup.py
Run on Fly.io: fly ssh console -a totetaxi-backend -C "python manage.py shell < scripts/validate_ses_setup.py"
"""
import sys
from django.core.mail import send_mail
from django.conf import settings

print("🔍 Validating SES Configuration...")
print(f"EMAIL_BACKEND: {settings.EMAIL_BACKEND}")
print(f"EMAIL_HOST: {settings.EMAIL_HOST}")
print(f"EMAIL_PORT: {settings.EMAIL_PORT}")
print(f"EMAIL_USE_TLS: {settings.EMAIL_USE_TLS}")
print(f"DEFAULT_FROM_EMAIL: {settings.DEFAULT_FROM_EMAIL}")

# Check if using SES in production
if 'ses' not in settings.EMAIL_BACKEND.lower() and not settings.DEBUG:
    print("⚠️  WARNING: Not using SES backend in production!")
    print(f"Current backend: {settings.EMAIL_BACKEND}")
    sys.exit(1)

# In local dev, skip SES validation
if settings.DEBUG and 'console' in settings.EMAIL_BACKEND.lower():
    print("ℹ️  Running in DEBUG mode with console backend - SES validation skipped")
    print("✅ Email configuration is correct for local development")
    sys.exit(0)

print("\n📧 Sending test email to mnraynor90@gmail.com...")
try:
    send_mail(
        subject='ToteTaxi SES Test - Production Email Validation',
        message='''This is a test email from ToteTaxi to validate SES setup.

If you received this email, your SES configuration is working correctly!

Test Details:
- Backend: {backend}
- From: {from_email}
- Host: {host}
- Port: {port}

Next steps:
1. Check AWS SES dashboard for delivery metrics
2. Verify email templates are rendering correctly
3. Test all email types (welcome, verification, password reset, bookings)

ToteTaxi Backend Team
'''.format(
            backend=settings.EMAIL_BACKEND,
            from_email=settings.DEFAULT_FROM_EMAIL,
            host=settings.EMAIL_HOST,
            port=settings.EMAIL_PORT
        ),
        from_email=settings.DEFAULT_FROM_EMAIL,
        recipient_list=['mnraynor90@gmail.com'],
        fail_silently=False,
    )
    print("✅ Test email sent successfully!")
    print("📬 Check mnraynor90@gmail.com inbox to confirm delivery.")
    print("\n✨ SES validation complete!")
except Exception as e:
    print(f"❌ Failed to send email: {e}")
    print("\nTroubleshooting steps:")
    print("1. Verify SES sender identity is verified in AWS console")
    print("2. Check AWS credentials (ACCESS_KEY_ID and SECRET_ACCESS_KEY)")
    print("3. Confirm DEFAULT_FROM_EMAIL matches verified identity")
    print("4. Check SES is out of sandbox mode (or recipient is verified)")
    print("5. Review CloudWatch logs for detailed error messages")
    sys.exit(1)
```

# ========================= OTHER FILES =========================


# ==== apps/__init__.py ====

```python

```

# ==== templates/emails/booking_confirmation.txt ====

```
Booking Confirmation - {{ booking.booking_number }}

Hi {{ customer_name }},

Your Tote Taxi booking has been confirmed!

=== BOOKING DETAILS ===
- Booking Number: {{ booking.booking_number }}
- Service: {{ booking.get_service_type_display }}
{% if booking.service_type == 'blade_transfer' %}
- Airport: {% if booking.blade_airport == 'JFK' %}JFK International Airport{% elif booking.blade_airport == 'EWR' %}Newark Liberty International Airport{% else %}{{ booking.blade_airport }}{% endif %}
- Flight Date: {% if booking.blade_flight_date %}{{ booking.blade_flight_date|date:"l, F j, Y" }}{% endif %}
- Flight Departure: {% if booking.blade_flight_time %}{{ booking.blade_flight_time|time:"g:i A" }}{% endif %}
- Number of Bags: {{ booking.blade_bag_count }}
- Bags Ready By: {% if booking.blade_ready_time %}{{ booking.blade_ready_time|time:"g:i A" }}{% endif %}
{% else %}
- Pickup Date: {{ booking.pickup_date|date:"l, F j, Y" }}
- Pickup Time: {{ booking.get_pickup_time_display }}
{% endif %}
- Total: ${{ booking.total_price_dollars }}

{% if booking.service_type == 'blade_transfer' %}
=== BLADE TRANSFER DETAILS ===
• Rate: $75 per bag (minimum 2 bags = $150)
• Weight limit: 50 lbs per bag
• Overweight bags: $100 additional per bag
• NYC to airport service

{% elif booking.service_type == 'mini_move' %}
=== MINI MOVE DETAILS ===
{% if booking.mini_move_package %}
• Package: {{ booking.mini_move_package.name }}
• Description: {{ booking.mini_move_package.description }}
{% if booking.mini_move_package.max_items %}• Item limit: {{ booking.mini_move_package.max_items }} pieces{% endif %}
• Weight limit: {{ booking.mini_move_package.max_weight_per_item_lbs }} lbs per item
{% endif %}

{% if booking.include_packing %}
• Packing service included
{% endif %}
{% if booking.include_unpacking %}
• Unpacking service included
{% endif %}

{% elif booking.service_type == 'standard_delivery' %}
=== STANDARD DELIVERY DETAILS ===
{% if booking.standard_delivery_item_count %}• Items: {{ booking.standard_delivery_item_count }} pieces{% endif %}
• Rate: $9.50 per item (minimum $28.50)
• Weight limit: 50 lbs per item
{% if booking.is_same_day_delivery %}• Same-day delivery: $360{% endif %}

{% if booking.bookingspecialtyitem_set.exists %}
Specialty items:
{% for booking_item in booking.bookingspecialtyitem_set.all %}• {{ booking_item.specialty_item.name }}: {{ booking_item.quantity }} items
{% endfor %}
{% endif %}

{% elif booking.service_type == 'specialty_item' %}
=== SPECIALTY ITEM DELIVERY ===
{% for booking_item in booking.bookingspecialtyitem_set.all %}• {{ booking_item.specialty_item.name }}: {{ booking_item.quantity }} items
{% endfor %}
{% if booking.is_same_day_delivery %}• Same-day delivery: $360{% endif %}

{% endif %}

=== ADDRESSES ===
Pickup Address:
{{ booking.pickup_address.address_line_1 }}
{% if booking.pickup_address.address_line_2 %}{{ booking.pickup_address.address_line_2 }}{% endif %}
{{ booking.pickup_address.city }}, {{ booking.pickup_address.state }} {{ booking.pickup_address.zip_code }}

{% if booking.service_type != 'blade_transfer' %}
Delivery Address:
{{ booking.delivery_address.address_line_1 }}
{% if booking.delivery_address.address_line_2 %}{{ booking.delivery_address.address_line_2 }}{% endif %}
{{ booking.delivery_address.city }}, {{ booking.delivery_address.state }} {{ booking.delivery_address.zip_code }}
{% endif %}

{% if booking.special_instructions %}
Special Instructions:
{{ booking.special_instructions }}
{% endif %}

{% if booking.coi_required %}
Certificate of Insurance: Included
{% endif %}

We'll send you updates as your booking progresses.

Questions? Contact us at info@totetaxi.com or call (631) 595-5100

Best regards,
The Tote Taxi Team

---
This is an automated message. Please do not reply to this email.
```

# ==== templates/emails/booking_reminder.txt ====

```
Booking Confirmation - {{ booking.booking_number }}

Hi {{ customer_name }},

Your Tote Taxi booking has been confirmed!

Booking Details:
- Booking Number: {{ booking.booking_number }}
- Service: {{ booking.get_service_type_display }}
- Pickup Date: {{ booking.pickup_date }}
- Pickup Time: {{ booking.get_pickup_time_display }}
- Total: ${{ booking.total_price_dollars }}

Pickup Address:
{{ booking.pickup_address.address_line_1 }}
{% if booking.pickup_address.address_line_2 %}{{ booking.pickup_address.address_line_2 }}{% endif %}
{{ booking.pickup_address.city }}, {{ booking.pickup_address.state }} {{ booking.pickup_address.zip_code }}

Delivery Address:
{{ booking.delivery_address.address_line_1 }}
{% if booking.delivery_address.address_line_2 %}{{ booking.delivery_address.address_line_2 }}{% endif %}
{{ booking.delivery_address.city }}, {{ booking.delivery_address.state }} {{ booking.delivery_address.zip_code }}

{% if booking.special_instructions %}
Special Instructions:
{{ booking.special_instructions }}
{% endif %}

We'll send you an update when your booking status changes.

Questions? Contact us at info@totetaxi.com or call (631) 595-5100

Best regards,
The Tote Taxi Team

---
This is an automated message. Please do not reply to this email.
```

# ==== templates/emails/booking_status_update.txt ====

```
Booking Status Update - {{ booking.booking_number }}

Hi {{ customer_name }},

Your booking status has been updated.

Booking Number: {{ booking.booking_number }}
Status: {{ old_status }} → {{ new_status }}

Service: {{ booking.get_service_type_display }}
Pickup Date: {{ booking.pickup_date }}

{% if new_status == 'confirmed' %}
Your booking has been confirmed by our team. We're all set for your scheduled pickup!
{% elif new_status == 'completed' %}
Your booking has been completed. Thank you for choosing Tote Taxi!
{% elif new_status == 'cancelled' %}
Your booking has been cancelled. If you have questions, please contact us.
{% endif %}

View your booking details: https://totetaxi.netlify.app/dashboard

Questions? Contact us at info@totetaxi.com or call (631) 595-5100

Best regards,
The Tote Taxi Team

---
This is an automated message. Please do not reply to this email.
```

# ==== templates/emails/email_verification.txt ====

```
Verify Your Tote Taxi Account

Hi {{ user_name }},

Thank you for registering with Tote Taxi! 

To complete your registration, please verify your email address by clicking the link below:

{{ verify_url }}

This link will expire in 48 hours.

If you didn't create a Tote Taxi account, please ignore this email.

Best regards,
The Tote Taxi Team

---
This is an automated message. Please do not reply to this email.
```

# ==== templates/emails/password_reset.txt ====

```
Verify Your Tote Taxi Account

Hi {{ user_name }},

Thank you for registering with Tote Taxi! 

To complete your registration, please verify your email address by clicking the link below:

{{ verify_url }}

This link will expire in 48 hours.

If you didn't create a Tote Taxi account, please ignore this email.

Best regards,
The Tote Taxi Team

---
This is an automated message. Please do not reply to this email.
```

# ==== templates/emails/welcome.txt ====

```
Verify Your Tote Taxi Account

Hi {{ user_name }},

Thank you for registering with Tote Taxi! 

To complete your registration, please verify your email address by clicking the link below:

{{ verify_url }}

This link will expire in 48 hours.

If you didn't create a Tote Taxi account, please ignore this email.

Best regards,
The Tote Taxi Team

---
This is an automated message. Please do not reply to this email.
```

